diff --git a/README b/README
index e24e7a30e6..c9e1f54819 100644
--- a/README
+++ b/README
@@ -1,3 +1,15 @@
+Gem5-AVX -------------------------------------------------------------------
+
+This repo adds partial AVX2 and AVX-512 support to gem5. Key features:
+- Supports many common instructions (passed the dense_mv test in avx_test).
+- Most arithmetic instructions are broken into a single microop.
+- No support for masking or broadcast.
+For more details, please refer to: https://seanzw.github.io/posts/gem5-avx/
+
+Feel free to use and extend it. Please note that the code is not throughly
+tested, and almost certainly contains bugs. Use it at your own risk.
+
+Original README ------------------------------------------------------------
 This is the gem5 simulator.
 
 The main website can be found at http://www.gem5.org
diff --git a/avx-test/Makefile b/avx-test/Makefile
new file mode 100644
index 0000000000..052b6e81da
--- /dev/null
+++ b/avx-test/Makefile
@@ -0,0 +1,6 @@
+test: dense_mv_blk.exe
+	../build/X86/gem5.opt ../configs/example/se.py --cmd='./dense_mv_blk.exe' --cpu-type=DerivO3CPU --caches 
+
+%.exe: %.c
+	gcc -O3 -mavx512f -static $^ -o $@
+
diff --git a/avx-test/dense_mv_blk.c b/avx-test/dense_mv_blk.c
new file mode 100644
index 0000000000..dfeeada1d1
--- /dev/null
+++ b/avx-test/dense_mv_blk.c
@@ -0,0 +1,80 @@
+#include <malloc.h>
+#include <math.h>
+#include <stdint.h>
+#include <stdio.h>
+#include <stdlib.h>
+
+#include "immintrin.h"
+
+typedef float Value;
+
+#define CHECK
+// #define WARM_CACHE
+
+#define N 256
+#define M 1024
+#define Bx 16
+#define By 4
+
+__attribute__((noinline)) Value foo(Value *A, Value *B, Value *C) {
+  // #pragma clang loop vectorize(disable)
+  for (uint64_t i = 0; i < N; i += By) {
+    Value localSum[By][Bx] = {0};
+    for (uint64_t j = 0; j < M; j += Bx) {
+      __m512 valB = _mm512_load_ps(B + j);
+      for (uint64_t by = 0; by < By; ++by) {
+        uint64_t idxA = (i + by) * M + j;
+        __m512 valA = _mm512_load_ps(A + idxA);
+        __m512 valC = _mm512_load_ps(localSum[by]);
+        __m512 valM = _mm512_mul_ps(valA, valB);
+        __m512 valS = _mm512_add_ps(valM, valC);
+        _mm512_store_ps(localSum[by], valS);
+      }
+    }
+    #pragma GCC unroll 1
+    for (uint64_t by = 0; by < By; ++by) {
+      __m512 valS = _mm512_load_ps(localSum[by]);
+      Value sum = _mm512_reduce_add_ps(valS);
+      C[i + by] = sum;
+    }
+  }
+  return 0.0f;
+}
+
+#define CACHE_BLOCK_SIZE 64
+
+int main() {
+
+  Value *A = (Value *)aligned_alloc(CACHE_BLOCK_SIZE, N * M * sizeof(Value));
+  Value *B = (Value *)aligned_alloc(CACHE_BLOCK_SIZE, M * sizeof(Value));
+  Value *C = (Value *)aligned_alloc(CACHE_BLOCK_SIZE, N * sizeof(Value));
+  for (int i = 0; i < N * M; ++i) {
+    A[i] = 1 % N;
+  }
+  for (int i = 0; i < M; ++i) {
+    B[i] = i;
+  }
+
+  printf("Begin foo.\n");
+  volatile Value c = foo(A, B, C);
+  printf("End foo.\n");
+
+#ifdef CHECK
+  int pass = 1;
+  for (int i = 0; i < N; ++i) {
+    Value expected = 0;
+    for (int j = 0; j < M; ++j) {
+      expected += A[i * M + j] * B[j];
+    }
+    if (fabs(expected - C[i]) > 0.001f) {
+      printf("Error in result %d, expected %f, got %f.\n", i, expected, C[i]);
+      pass = 0;
+    }
+  }
+  if (pass) {
+    printf("Passed test.\n");
+  }
+#endif
+
+  return 0;
+}
diff --git a/avx-test/dense_mv_blk.exe b/avx-test/dense_mv_blk.exe
new file mode 100755
index 0000000000..3bd176d068
Binary files /dev/null and b/avx-test/dense_mv_blk.exe differ
diff --git a/src/arch/isa_parser/isa_parser.py b/src/arch/isa_parser/isa_parser.py
index ff54889fe7..c616461d10 100755
--- a/src/arch/isa_parser/isa_parser.py
+++ b/src/arch/isa_parser/isa_parser.py
@@ -666,6 +666,14 @@ class ISAParser(Grammar):
                     print('#define __SPLIT %u' % i, file=f)
                 print('#include "%s"' % fn, file=f)
                 print('}', file=f)
+        
+        # max_inst_regs.hh
+        # ! Make sure x86 has at least 8 dest regs and 24 src regs.
+        if self.namespace == 'X86ISAInst':
+            if self.maxInstDestRegs < 8:
+                self.maxInstDestRegs = 8
+            if self.maxInstSrcRegs < 24:
+                self.maxInstSrcRegs = 24
 
         # max_inst_regs.hh
         self.update('max_inst_regs.hh',
diff --git a/src/arch/x86/SConscript b/src/arch/x86/SConscript
index f790ec19b6..f5ce07b648 100644
--- a/src/arch/x86/SConscript
+++ b/src/arch/x86/SConscript
@@ -42,9 +42,9 @@ Import('*')
 
 if env['TARGET_ISA'] != 'x86':
     Return()
-
 Source('cpuid.cc')
 Source('decoder.cc')
+Source('decompress_displacement.cc')
 Source('decoder_tables.cc')
 Source('emulenv.cc')
 Source('faults.cc')
@@ -53,6 +53,7 @@ Source('insts/badmicroop.cc')
 Source('insts/microfpop.cc')
 Source('insts/microldstop.cc')
 Source('insts/micromediaop.cc')
+Source('insts/microavxop.cc')
 Source('insts/microop.cc')
 Source('insts/microregop.cc')
 Source('insts/static_inst.cc')
@@ -81,6 +82,7 @@ DebugFlag('PageTableWalker', \
           "Page table walker state machine debugging")
 DebugFlag('Decoder', "Decoder debug output")
 DebugFlag('X86', "Generic X86 ISA debugging")
+DebugFlag('X86MediaMicroop', "X86 Media Microop debugging")
 
 python_files = (
     '__init__.py',
diff --git a/src/arch/x86/decoder.cc b/src/arch/x86/decoder.cc
index 415c7b4c84..2b600db396 100644
--- a/src/arch/x86/decoder.cc
+++ b/src/arch/x86/decoder.cc
@@ -47,9 +47,11 @@ Decoder::doResetState()
     instBytes = &decodePages->lookup(origPC);
     chunkIdx = 0;
 
+    name();
+
     emi.rex = 0;
     emi.legacy = 0;
-    emi.vex = 0;
+    emi.evex = 0;
 
     emi.opcode.type = BadOpcode;
     emi.opcode.op = 0;
@@ -73,11 +75,11 @@ Decoder::doResetState()
 void
 Decoder::process()
 {
-    // This function drives the decoder state machine.
+    //This function drives the decoder state machine.
 
-    // Some sanity checks. You shouldn't try to process more bytes if
-    // there aren't any, and you shouldn't overwrite an already decoded
-    // ExtMachInst.
+    //Some sanity checks. You shouldn't try to process more bytes if
+    //there aren't any, and you shouldn't overwrite an already
+    //decoder ExtMachInst.
     assert(!outOfBytes);
     assert(!instDone);
 
@@ -89,7 +91,7 @@ Decoder::process()
         instBytes->chunks.push_back(fetchChunk);
     }
 
-    // While there's still something to do...
+    //While there's still something to do...
     while (!instDone && !outOfBytes) {
         uint8_t nextByte = getNextByte();
         switch (state) {
@@ -108,6 +110,15 @@ Decoder::process()
           case VexOpcodeState:
             state = doVexOpcodeState(nextByte);
             break;
+          case EVex2Of4State:
+            state = doEVex2Of4State(nextByte);
+            break;
+          case EVex3Of4State:
+            state = doEVex3Of4State(nextByte);
+            break;
+          case EVex4Of4State:
+            state = doEVex4Of4State(nextByte);
+            break;
           case OneByteOpcodeState:
             state = doOneByteOpcodeState(nextByte);
             break;
@@ -172,8 +183,8 @@ Decoder::doFromCacheState()
     }
 }
 
-// Either get a prefix and record it in the ExtMachInst, or send the
-// state machine on to get the opcode(s).
+//Either get a prefix and record it in the ExtMachInst, or send the
+//state machine on to get the opcode(s).
 Decoder::State
 Decoder::doPrefixState(uint8_t nextByte)
 {
@@ -184,8 +195,9 @@ Decoder::doPrefixState(uint8_t nextByte)
         prefix = 0;
     if (prefix)
         consumeByte();
-    switch(prefix) {
-        // Operand size override prefixes
+    switch(prefix)
+    {
+        //Operand size override prefixes
       case OperandSizeOverride:
         DPRINTF(Decoder, "Found operand size override prefix.\n");
         emi.legacy.op = true;
@@ -194,7 +206,7 @@ Decoder::doPrefixState(uint8_t nextByte)
         DPRINTF(Decoder, "Found address size override prefix.\n");
         emi.legacy.addr = true;
         break;
-        // Segment override prefixes
+        //Segment override prefixes
       case CSOverride:
       case DSOverride:
       case ESOverride:
@@ -222,14 +234,19 @@ Decoder::doPrefixState(uint8_t nextByte)
         break;
       case Vex2Prefix:
         DPRINTF(Decoder, "Found VEX two-byte prefix %#x.\n", nextByte);
-        emi.vex.present = 1;
+        emi.evex.vex_present = 1;
         nextState = Vex2Of2State;
         break;
       case Vex3Prefix:
         DPRINTF(Decoder, "Found VEX three-byte prefix %#x.\n", nextByte);
-        emi.vex.present = 1;
+        emi.evex.vex_present = 1;
         nextState = Vex2Of3State;
         break;
+      case EVexPrefix:
+        DPRINTF(Decoder, "Found EVEX prefix %#x.\n", nextByte);
+        emi.evex.evex_present = 1;
+        nextState = EVex2Of4State;
+        break;
       case 0:
         nextState = OneByteOpcodeState;
         break;
@@ -248,8 +265,8 @@ Decoder::doVex2Of2State(uint8_t nextByte)
 
     emi.rex.r = !vex.r;
 
-    emi.vex.l = vex.l;
-    emi.vex.v = ~vex.v;
+    emi.evex.l = vex.l;
+    emi.evex.v = ~vex.v;
 
     switch (vex.p) {
       case 0:
@@ -275,7 +292,7 @@ Decoder::doVex2Of3State(uint8_t nextByte)
 {
     if (emi.mode.submode != SixtyFourBitMode && bits(nextByte, 7, 6) == 0x3) {
         // This was actually an LDS instruction. Reroute to that path.
-        emi.vex.present = 0;
+        emi.evex.vex_present = 0;
         emi.opcode.type = OneByteOpcode;
         emi.opcode.op = 0xC4;
         return processOpcode(ImmediateTypeOneByte, UsesModRMOneByte,
@@ -316,7 +333,7 @@ Decoder::doVex3Of3State(uint8_t nextByte)
 {
     if (emi.mode.submode != SixtyFourBitMode && bits(nextByte, 7, 6) == 0x3) {
         // This was actually an LES instruction. Reroute to that path.
-        emi.vex.present = 0;
+        emi.evex.vex_present = 0;
         emi.opcode.type = OneByteOpcode;
         emi.opcode.op = 0xC5;
         return processOpcode(ImmediateTypeOneByte, UsesModRMOneByte,
@@ -328,8 +345,8 @@ Decoder::doVex3Of3State(uint8_t nextByte)
 
     emi.rex.w = vex.w;
 
-    emi.vex.l = vex.l;
-    emi.vex.v = ~vex.v;
+    emi.evex.l = vex.l;
+    emi.evex.v = ~vex.v;
 
     switch (vex.p) {
       case 0:
@@ -359,9 +376,10 @@ Decoder::doVexOpcodeState(uint8_t nextByte)
     switch (emi.opcode.type) {
       case TwoByteOpcode:
         return processOpcode(ImmediateTypeTwoByte, UsesModRMTwoByte);
-      case ThreeByte0F38Opcode:
+      case ThreeByte0F38Opcode: {
         return processOpcode(ImmediateTypeThreeByte0F38,
                              UsesModRMThreeByte0F38);
+      }
       case ThreeByte0F3AOpcode:
         return processOpcode(ImmediateTypeThreeByte0F3A,
                              UsesModRMThreeByte0F3A);
@@ -370,6 +388,100 @@ Decoder::doVexOpcodeState(uint8_t nextByte)
     }
 }
 
+Decoder::State
+Decoder::doEVex2Of4State(uint8_t nextByte)
+{
+    consumeByte();
+    EVex2Of4 evex = nextByte;
+
+    emi.rex.r = !evex.r;
+    emi.rex.x = !evex.x;
+    emi.rex.b = !evex.b;
+
+    emi.evex.r = !evex.r;
+    emi.evex.r_prime = !evex.r_prime;
+
+    switch (evex.m) {
+      case 1:
+        emi.opcode.type = TwoByteOpcode;
+        break;
+      case 2:
+        emi.opcode.type = ThreeByte0F38Opcode;
+        break;
+      case 3:
+        emi.opcode.type = ThreeByte0F3AOpcode;
+        break;
+      default:
+        // These encodings are reserved. Pretend this was an undefined
+        // instruction so the main decoder will behave correctly, and stop
+        // trying to interpret bytes.
+        emi.opcode.type = TwoByteOpcode;
+        emi.opcode.op = 0x0B;
+        instDone = true;
+        return ResetState;
+    }
+    return EVex3Of4State;
+}
+
+Decoder::State
+Decoder::doEVex3Of4State(uint8_t nextByte)
+{
+    consumeByte();
+    EVex3Of4 evex = nextByte;
+
+    emi.rex.w = evex.w;
+    emi.evex.v = ~evex.v;
+
+    switch (evex.p) {
+      case 0:
+        break;
+      case 1:
+        emi.legacy.op = 1;
+        break;
+      case 2:
+        emi.legacy.rep = 1;
+        break;
+      case 3:
+        emi.legacy.repne = 1;
+        break;
+    }
+    DPRINTF(Decoder, "EVEX-3: w-%d p-%d v-%d.\n",
+        emi.rex.w,
+        evex.p,
+        emi.evex.v
+    );
+
+    return EVex4Of4State;
+}
+
+Decoder::State
+Decoder::doEVex4Of4State(uint8_t nextByte)
+{
+    consumeByte();
+    EVex4Of4 evex = nextByte;
+
+    emi.evex.a = evex.a;
+    emi.evex.b = evex.b;
+    emi.evex.z = evex.z;
+    emi.evex.l = evex.l;
+    emi.evex.l_prime = evex.l_prime;
+    emi.evex.v_prime = !evex.v_prime;
+
+    if (emi.evex.a != 0) {
+      warn("Can not handle mask register in evex %#x.", origPC);
+    }
+    if (emi.evex.b != 0) {
+      warn("Can not handle embed broadcast in evex %#x.", origPC);
+    }
+    DPRINTF(Decoder, "EVEX-4: L'-%d L-%d a-%d.\n",
+        emi.evex.l_prime,
+        emi.evex.l,
+        emi.evex.a
+    );
+
+    return VexOpcodeState;
+}
+
 // Load the first opcode byte. Determine if there are more opcode bytes, and
 // if not, what immediate and/or ModRM is needed.
 Decoder::State
@@ -425,7 +537,6 @@ Decoder::doThreeByte0F38OpcodeState(uint8_t nextByte)
     DPRINTF(Decoder, "Found three byte 0F38 opcode %#x.\n", nextByte);
     emi.opcode.type = ThreeByte0F38Opcode;
     emi.opcode.op = nextByte;
-
     return processOpcode(ImmediateTypeThreeByte0F38, UsesModRMThreeByte0F38);
 }
 
@@ -452,8 +563,8 @@ Decoder::processOpcode(ByteTable &immTable, ByteTable &modrmTable,
     State nextState = ErrorState;
     const uint8_t opcode = emi.opcode.op;
 
-    // Figure out the effective operand size. This can be overriden to
-    // a fixed value at the decoder level.
+    //Figure out the effective operand size. This can be overriden to
+    //a fixed value at the decoder level.
     int logOpSize;
     if (emi.rex.w)
         logOpSize = 3; // 64 bit operand size
@@ -462,33 +573,33 @@ Decoder::processOpcode(ByteTable &immTable, ByteTable &modrmTable,
     else
         logOpSize = defOp;
 
-    // Set the actual op size.
+    //Set the actual op size
     emi.opSize = 1 << logOpSize;
 
-    // Figure out the effective address size. This can be overriden to
-    // a fixed value at the decoder level.
+    //Figure out the effective address size. This can be overriden to
+    //a fixed value at the decoder level.
     int logAddrSize;
     if (emi.legacy.addr)
         logAddrSize = altAddr;
     else
         logAddrSize = defAddr;
 
-    // Set the actual address size.
+    //Set the actual address size
     emi.addrSize = 1 << logAddrSize;
 
-    // Figure out the effective stack width. This can be overriden to
-    // a fixed value at the decoder level.
+    //Figure out the effective stack width. This can be overriden to
+    //a fixed value at the decoder level.
     emi.stackSize = 1 << stack;
 
-    // Figure out how big of an immediate we'll retreive based
-    // on the opcode.
+    //Figure out how big of an immediate we'll retreive based
+    //on the opcode.
     int immType = immTable[opcode];
     if (addrSizedImm)
         immediateSize = SizeTypeToSize[logAddrSize - 1][immType];
     else
         immediateSize = SizeTypeToSize[logOpSize - 1][immType];
 
-    // Determine what to expect next.
+    //Determine what to expect next
     if (modrmTable[opcode]) {
         nextState = ModRMState;
     } else {
@@ -499,12 +610,13 @@ Decoder::processOpcode(ByteTable &immTable, ByteTable &modrmTable,
             nextState = ResetState;
         }
     }
+
     return nextState;
 }
 
-// Get the ModRM byte and determine what displacement, if any, there is.
-// Also determine whether or not to get the SIB byte, displacement, or
-// immediate next.
+//Get the ModRM byte and determine what displacement, if any, there is.
+//Also determine whether or not to get the SIB byte, displacement, or
+//immediate next.
 Decoder::State
 Decoder::doModRMState(uint8_t nextByte)
 {
@@ -512,7 +624,7 @@ Decoder::doModRMState(uint8_t nextByte)
     ModRM modRM = nextByte;
     DPRINTF(Decoder, "Found modrm byte %#x.\n", nextByte);
     if (defOp == 1) {
-        // Figure out 16 bit displacement size.
+        //figure out 16 bit displacement size
         if ((modRM.mod == 0 && modRM.rm == 6) || modRM.mod == 2)
             displacementSize = 2;
         else if (modRM.mod == 1)
@@ -520,7 +632,7 @@ Decoder::doModRMState(uint8_t nextByte)
         else
             displacementSize = 0;
     } else {
-        // Figure out 32/64 bit displacement size.
+        //figure out 32/64 bit displacement size
         if ((modRM.mod == 0 && modRM.rm == 5) || modRM.mod == 2)
             displacementSize = 4;
         else if (modRM.mod == 1)
@@ -538,8 +650,8 @@ Decoder::doModRMState(uint8_t nextByte)
            immediateSize = (emi.opSize == 8) ? 4 : emi.opSize;
     }
 
-    // If there's an SIB, get that next.
-    // There is no SIB in 16 bit mode.
+    //If there's an SIB, get that next.
+    //There is no SIB in 16 bit mode.
     if (modRM.rm == 4 && modRM.mod != 3) {
             // && in 32/64 bit mode)
         nextState = SIBState;
@@ -551,15 +663,15 @@ Decoder::doModRMState(uint8_t nextByte)
         instDone = true;
         nextState = ResetState;
     }
-    // The ModRM byte is consumed no matter what.
+    //The ModRM byte is consumed no matter what
     consumeByte();
     emi.modRM = modRM;
     return nextState;
 }
 
-// Get the SIB byte. We don't do anything with it at this point, other
-// than storing it in the ExtMachInst. Determine if we need to get a
-// displacement or immediate next.
+//Get the SIB byte. We don't do anything with it at this point, other
+//than storing it in the ExtMachInst. Determine if we need to get a
+//displacement or immediate next.
 Decoder::State
 Decoder::doSIBState(uint8_t nextByte)
 {
@@ -580,7 +692,8 @@ Decoder::doSIBState(uint8_t nextByte)
     return nextState;
 }
 
-// Gather up the displacement, or at least as much of it as we can get.
+//Gather up the displacement, or at least as much of it
+//as we can get.
 Decoder::State
 Decoder::doDisplacementState()
 {
@@ -594,9 +707,9 @@ Decoder::doDisplacementState()
             displacementSize, immediateCollected);
 
     if (displacementSize == immediateCollected) {
-        // Reset this for other immediates.
+        //Reset this for other immediates.
         immediateCollected = 0;
-        // Sign extend the displacement.
+        //Sign extend the displacement
         switch(displacementSize)
         {
           case 1:
@@ -611,46 +724,53 @@ Decoder::doDisplacementState()
           default:
             panic("Undefined displacement size!\n");
         }
-        DPRINTF(Decoder, "Collected displacement %#x.\n",
-                emi.displacement);
+
+        emi.dispSize = displacementSize;
+        processCompressedDisplacement();
+
+        DPRINTF(Decoder, "Collected displacement %d bytes: %#x.\n",
+                emi.dispSize, emi.displacement);
         if (immediateSize) {
             nextState = ImmediateState;
         } else {
             instDone = true;
             nextState = ResetState;
         }
-
-        emi.dispSize = displacementSize;
     }
     else
         nextState = DisplacementState;
     return nextState;
 }
 
-// Gather up the immediate, or at least as much of it as we can get.
+//Gather up the immediate, or at least as much of it
+//as we can get
 Decoder::State
 Decoder::doImmediateState()
 {
     State nextState = ErrorState;
 
-    getImmediate(immediateCollected, emi.immediate, immediateSize);
+    getImmediate(immediateCollected,
+            emi.immediate,
+            immediateSize);
 
     DPRINTF(Decoder, "Collecting %d byte immediate, got %d bytes.\n",
             immediateSize, immediateCollected);
 
-    if (immediateSize == immediateCollected) {
-        // Reset this for other immediates.
+    if (immediateSize == immediateCollected)
+    {
+        //Reset this for other immediates.
         immediateCollected = 0;
 
         //XXX Warning! The following is an observed pattern and might
-        // not always be true!
-
-        // Instructions which use 64 bit operands but 32 bit immediates
-        // need to have the immediate sign extended to 64 bits.
-        // Instructions which use true 64 bit immediates won't be
-        // affected, and instructions that use true 32 bit immediates
-        // won't notice.
-        switch(immediateSize) {
+        //not always be true!
+
+        //Instructions which use 64 bit operands but 32 bit immediates
+        //need to have the immediate sign extended to 64 bits.
+        //Instructions which use true 64 bit immediates won't be
+        //affected, and instructions that use true 32 bit immediates
+        //won't notice.
+        switch(immediateSize)
+        {
           case 4:
             emi.immediate = sext<32>(emi.immediate);
             break;
@@ -662,9 +782,9 @@ Decoder::doImmediateState()
                 emi.immediate);
         instDone = true;
         nextState = ResetState;
-    } else {
-        nextState = ImmediateState;
     }
+    else
+        nextState = ImmediateState;
     return nextState;
 }
 
@@ -679,6 +799,12 @@ Decoder::decode(ExtMachInst mach_inst, Addr addr)
         return iter->second;
 
     StaticInstPtr si = decodeInst(mach_inst);
+    if (mach_inst.evex.present) {
+        if (si->getName() == "ud2" || si->getName() == "unknown") {
+            warn("Invalid op decoded at %#x %s.\n", origPC, mach_inst);
+        }
+    }
+
     (*instMap)[mach_inst] = si;
     return si;
 }
diff --git a/src/arch/x86/decoder.hh b/src/arch/x86/decoder.hh
index 94ebd0cf2f..7c95ab1619 100644
--- a/src/arch/x86/decoder.hh
+++ b/src/arch/x86/decoder.hh
@@ -84,59 +84,60 @@ class Decoder : public InstDecoder
 
     static InstBytes dummy;
 
-    // The bytes to be predecoded.
+    // For DPRINTF.
+    const std::string _name;
+    const std::string &name() const { return _name; }
+
+    //The bytes to be predecoded
     MachInst fetchChunk;
-    InstBytes *instBytes = &dummy;
+    InstBytes *instBytes;
     int chunkIdx;
-    // The pc of the start of fetchChunk.
-    Addr basePC = 0;
-    // The pc the current instruction started at.
-    Addr origPC = 0;
-    // The offset into fetchChunk of current processing.
-    int offset = 0;
-    // The extended machine instruction being generated.
+    //The pc of the start of fetchChunk
+    Addr basePC;
+    //The pc the current instruction started at
+    Addr origPC;
+    //The offset into fetchChunk of current processing
+    int offset;
+    //The extended machine instruction being generated
     ExtMachInst emi;
-    // Predecoding state.
-    X86Mode mode = LongMode;
-    X86SubMode submode = SixtyFourBitMode;
-    uint8_t altOp = 0;
-    uint8_t defOp = 0;
-    uint8_t altAddr = 0;
-    uint8_t defAddr = 0;
-    uint8_t stack = 0;
-
-    uint8_t
-    getNextByte()
+    //Predecoding state
+    X86Mode mode;
+    X86SubMode submode;
+    uint8_t altOp;
+    uint8_t defOp;
+    uint8_t altAddr;
+    uint8_t defAddr;
+    uint8_t stack;
+
+    uint8_t getNextByte()
     {
         return ((uint8_t *)&fetchChunk)[offset];
     }
 
-    void
-    getImmediate(int &collected, uint64_t &current, int size)
+    void getImmediate(int &collected, uint64_t &current, int size)
     {
-        // Figure out how many bytes we still need to get for the
-        // immediate.
+        //Figure out how many bytes we still need to get for the
+        //immediate.
         int toGet = size - collected;
-        // Figure out how many bytes are left in our "buffer".
+        //Figure out how many bytes are left in our "buffer"
         int remaining = sizeof(MachInst) - offset;
-        // Get as much as we need, up to the amount available.
+        //Get as much as we need, up to the amount available.
         toGet = toGet > remaining ? remaining : toGet;
 
-        // Shift the bytes we want to be all the way to the right
+        //Shift the bytes we want to be all the way to the right
         uint64_t partialImm = fetchChunk >> (offset * 8);
-        // Mask off what we don't want.
+        //Mask off what we don't want
         partialImm &= mask(toGet * 8);
-        // Shift it over to overlay with our displacement.
+        //Shift it over to overlay with our displacement.
         partialImm <<= (immediateCollected * 8);
-        // Put it into our displacement.
+        //Put it into our displacement
         current |= partialImm;
-        // Update how many bytes we've collected.
+        //Update how many bytes we've collected.
         collected += toGet;
         consumeBytes(toGet);
     }
 
-    void
-    updateOffsetState()
+    void updateOffsetState()
     {
         assert(offset <= sizeof(MachInst));
         if (offset == sizeof(MachInst)) {
@@ -153,32 +154,30 @@ class Decoder : public InstDecoder
         }
     }
 
-    void
-    consumeByte()
+    void consumeByte()
     {
         offset++;
         updateOffsetState();
     }
 
-    void
-    consumeBytes(int numBytes)
+    void consumeBytes(int numBytes)
     {
         offset += numBytes;
         updateOffsetState();
     }
 
-    // State machine state.
+    //State machine state
   protected:
-    // Whether or not we're out of bytes.
-    bool outOfBytes = true;
-    // Whether we've completed generating an ExtMachInst.
-    bool instDone = false;
-    // The size of the displacement value.
+    //Whether or not we're out of bytes
+    bool outOfBytes;
+    //Whether we've completed generating an ExtMachInst
+    bool instDone;
+    //The size of the displacement value
     int displacementSize;
-    // The size of the immediate value.
+    //The size of the immediate value
     int immediateSize;
-    // This is how much of any immediate value we've gotten. This is used
-    // for both the actual immediate and the displacement.
+    //This is how much of any immediate value we've gotten. This is used
+    //for both the actual immediate and the displacement.
     int immediateCollected;
 
     enum State {
@@ -189,6 +188,9 @@ class Decoder : public InstDecoder
         Vex2Of3State,
         Vex3Of3State,
         VexOpcodeState,
+        EVex2Of4State,
+        EVex3Of4State,
+        EVex4Of4State,
         OneByteOpcodeState,
         TwoByteOpcodeState,
         ThreeByte0F38OpcodeState,
@@ -197,19 +199,22 @@ class Decoder : public InstDecoder
         SIBState,
         DisplacementState,
         ImmediateState,
-        // We should never get to this state. Getting here is an error.
+        //We should never get to this state. Getting here is an error.
         ErrorState
     };
 
-    State state = ResetState;
+    State state;
 
-    // Functions to handle each of the states
+    //Functions to handle each of the states
     State doResetState();
     State doFromCacheState();
     State doPrefixState(uint8_t);
     State doVex2Of2State(uint8_t);
     State doVex2Of3State(uint8_t);
     State doVex3Of3State(uint8_t);
+    State doEVex2Of4State(uint8_t);
+    State doEVex3Of4State(uint8_t);
+    State doEVex4Of4State(uint8_t);
     State doVexOpcodeState(uint8_t);
     State doOneByteOpcodeState(uint8_t);
     State doTwoByteOpcodeState(uint8_t);
@@ -220,37 +225,53 @@ class Decoder : public InstDecoder
     State doDisplacementState();
     State doImmediateState();
 
-    // Process the actual opcode found earlier, using the supplied tables.
+    //Process the actual opcode found earlier, using the supplied tables.
     State processOpcode(ByteTable &immTable, ByteTable &modrmTable,
                         bool addrSizedImm = false);
     // Process the opcode found with VEX / XOP prefix.
     State processExtendedOpcode(ByteTable &immTable);
 
+    // Process the Compressed displacement in EVEX.
+    void processCompressedDisplacement();
+
   protected:
     /// Caching for decoded instruction objects.
 
     typedef RegVal CacheKey;
 
     typedef DecodeCache::AddrMap<Decoder::InstBytes> DecodePages;
-    DecodePages *decodePages = nullptr;
+    DecodePages *decodePages;
     typedef std::unordered_map<CacheKey, DecodePages *> AddrCacheMap;
     AddrCacheMap addrCacheMap;
 
-    DecodeCache::InstMap<ExtMachInst> *instMap = nullptr;
+    DecodeCache::InstMap<ExtMachInst> *instMap;
     typedef std::unordered_map<
             CacheKey, DecodeCache::InstMap<ExtMachInst> *> InstCacheMap;
     static InstCacheMap instCacheMap;
 
   public:
-    Decoder(ISA *isa=nullptr)
+    Decoder(ISA* isa = nullptr, int thread_id = 0)
+        : _name(std::string("decoder") + std::to_string(thread_id)),
+        basePC(0), origPC(0), offset(0),
+        outOfBytes(true), instDone(false),
+        state(ResetState)
     {
         emi.reset();
+        mode = LongMode;
+        submode = SixtyFourBitMode;
         emi.mode.mode = mode;
         emi.mode.submode = submode;
+        altOp = 0;
+        defOp = 0;
+        altAddr = 0;
+        defAddr = 0;
+        stack = 0;
+        instBytes = &dummy;
+        decodePages = NULL;
+        instMap = NULL;
     }
 
-    void
-    setM5Reg(HandyM5Reg m5Reg)
+    void setM5Reg(HandyM5Reg m5Reg)
     {
         mode = (X86Mode)(uint64_t)m5Reg.mode;
         submode = (X86SubMode)(uint64_t)m5Reg.submode;
@@ -279,8 +300,7 @@ class Decoder : public InstDecoder
         }
     }
 
-    void
-    takeOverFrom(Decoder *old)
+    void takeOverFrom(Decoder *old)
     {
         mode = old->mode;
         submode = old->submode;
@@ -291,16 +311,26 @@ class Decoder : public InstDecoder
         altAddr = old->altAddr;
         defAddr = old->defAddr;
         stack = old->stack;
+
+        // Also takes over the decodePages and instMap.
+        if (!this->decodePages) {
+            this->decodePages = old->decodePages;
+        }
+        if (!this->instMap) {
+            this->instMap = old->instMap;
+        }
     }
 
-    void reset() { state = ResetState; }
+    void reset()
+    {
+        state = ResetState;
+    }
 
     void process();
 
-    // Use this to give data to the decoder. This should be used
-    // when there is control flow.
-    void
-    moreBytes(const PCState &pc, Addr fetchPC, MachInst data)
+    //Use this to give data to the decoder. This should be used
+    //when there is control flow.
+    void moreBytes(const PCState &pc, Addr fetchPC, MachInst data)
     {
         DPRINTF(Decoder, "Getting more bytes.\n");
         basePC = fetchPC;
@@ -310,8 +340,15 @@ class Decoder : public InstDecoder
         process();
     }
 
-    bool needMoreBytes() { return outOfBytes; }
-    bool instReady() { return instDone; }
+    bool needMoreBytes()
+    {
+        return outOfBytes;
+    }
+
+    bool instReady()
+    {
+        return instDone;
+    }
 
     void
     updateNPC(X86ISA::PCState &nextPC)
diff --git a/src/arch/x86/decoder_tables.cc b/src/arch/x86/decoder_tables.cc
index 7ee5e0185a..a68ecf75fa 100644
--- a/src/arch/x86/decoder_tables.cc
+++ b/src/arch/x86/decoder_tables.cc
@@ -55,6 +55,7 @@ namespace X86ISA
     const uint8_t RX = RexPrefix;
     const uint8_t V2 = Vex2Prefix;
     const uint8_t V3 = Vex3Prefix;
+    const uint8_t EV = EVexPrefix;
 
     //This table identifies whether a byte is a prefix, and if it is,
     //which prefix it is.
@@ -67,7 +68,7 @@ namespace X86ISA
 /*   3*/ 0 , 0 , 0 , 0 , 0 , 0 , SS, 0 , 0 , 0 , 0 , 0 , 0 , 0 , DS, 0,
 /*   4*/ RX, RX, RX, RX, RX, RX, RX, RX, RX, RX, RX, RX, RX, RX, RX, RX,
 /*   5*/ 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0,
-/*   6*/ 0 , 0 , 0 , 0 , FS, GS, OO, AO, 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0,
+/*   6*/ 0 , 0 , EV, 0 , FS, GS, OO, AO, 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0,
 /*   7*/ 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0,
 /*   8*/ 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0,
 /*   9*/ 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0,
@@ -111,7 +112,7 @@ namespace X86ISA
 /*  4 */ 1 , 1 , 1 , 1 , 1 , 1 , 1 , 1 , 1 , 1 , 1 , 1 , 1 , 1 , 1 , 1,
 /*  5 */ 1 , 1 , 1 , 1 , 1 , 1 , 1 , 1 , 1 , 1 , 1 , 1 , 1 , 1 , 1 , 1,
 /*  6 */ 1 , 1 , 1 , 1 , 1 , 1 , 1 , 1 , 1 , 1 , 1 , 1 , 1 , 1 , 1 , 1,
-/*  7 */ 1 , 1 , 1 , 1 , 1 , 1 , 1 , 0 , 0 , 0 , 0 , 0 , 1 , 1 , 1 , 1,
+/*  7 */ 1 , 1 , 1 , 1 , 1 , 1 , 1 , 0 , 0 , 0 , 0 , 1 , 1 , 1 , 1 , 1,
 /*  8 */ 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0,
 /*  9 */ 1 , 1 , 1 , 1 , 1 , 1 , 1 , 1 , 1 , 1 , 1 , 1 , 1 , 1 , 1 , 1,
 /*  A */ 0 , 0 , 0 , 1 , 1 , 1 , 1 , 1 , 0 , 0 , 0 , 1 , 1 , 1 , 1 , 1,
@@ -126,17 +127,17 @@ namespace X86ISA
     {    //LSB
 // MSB   0 | 1 | 2 | 3 | 4 | 5 | 6 | 7 | 8 | 9 | A | B | C | D | E | F
 /*  0 */ 1 , 1 , 1 , 1 , 1 , 1 , 1 , 1 , 1 , 1 , 1 , 1 , 0 , 0 , 0 , 0,
-/*  1 */ 1 , 0 , 0 , 0 , 1 , 1 , 0 , 1 , 0 , 0 , 0 , 0 , 1 , 1 , 1 , 0,
+/*  1 */ 1 , 0 , 0 , 0 , 1 , 1 , 0 , 1 , 1 , 1 , 0 , 0 , 1 , 1 , 1 , 0,
 /*  2 */ 1 , 1 , 1 , 1 , 1 , 1 , 0 , 0 , 1 , 1 , 1 , 1 , 0 , 0 , 0 , 0,
 /*  3 */ 1 , 1 , 1 , 1 , 1 , 1 , 0 , 1 , 1 , 1 , 1 , 1 , 1 , 1 , 1 , 1,
 /*  4 */ 1 , 1 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0,
-/*  5 */ 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0,
+/*  5 */ 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 1 , 1 , 0 , 0 , 0 , 0 , 0 , 0,
 /*  6 */ 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0,
-/*  7 */ 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0,
+/*  7 */ 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 1 , 0 , 0 , 0 , 1 , 0 , 0 , 0,
 /*  8 */ 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0,
 /*  9 */ 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0,
 /*  A */ 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0,
-/*  B */ 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0,
+/*  B */ 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 1 , 0 , 0 , 0 , 0 , 0 , 0 , 0,
 /*  C */ 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0,
 /*  D */ 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 1 , 1 , 1 , 1 , 1,
 /*  E */ 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0,
@@ -146,10 +147,10 @@ namespace X86ISA
     const Decoder::ByteTable Decoder::UsesModRMThreeByte0F3A =
     {    //LSB
 // MSB   0 | 1 | 2 | 3 | 4 | 5 | 6 | 7 | 8 | 9 | A | B | C | D | E | F
-/*  0 */ 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 1 , 1 , 1 , 1 , 1 , 1 , 1 , 1,
-/*  1 */ 0 , 0 , 0 , 0 , 1 , 1 , 1 , 1 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0,
-/*  2 */ 1 , 1 , 1 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0,
-/*  3 */ 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0,
+/*  0 */ 0 , 0 , 0 , 1 , 1 , 1 , 0 , 0 , 1 , 1 , 1 , 1 , 1 , 1 , 1 , 1,
+/*  1 */ 0 , 0 , 0 , 0 , 1 , 1 , 1 , 1 , 1 , 1 , 1 , 1 , 0 , 0 , 0 , 0,
+/*  2 */ 1 , 1 , 1 , 0 , 0 , 1 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0,
+/*  3 */ 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 1 , 1 , 1 , 0 , 0 , 0 , 0,
 /*  4 */ 1 , 1 , 1 , 0 , 1 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0,
 /*  5 */ 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0,
 /*  6 */ 1 , 1 , 1 , 1 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0,
@@ -265,10 +266,10 @@ namespace X86ISA
     const Decoder::ByteTable Decoder::ImmediateTypeThreeByte0F3A =
     {    //LSB
 // MSB   0 | 1 | 2 | 3 | 4 | 5 | 6 | 7 | 8 | 9 | A | B | C | D | E | F
-/*  0 */ 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , BY, BY, BY, BY, BY, BY, BY, BY,
-/*  1 */ 0 , 0 , 0 , 0 , BY, BY, BY, BY, 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 ,
-/*  2 */ BY, BY, BY, 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 ,
-/*  3 */ 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 ,
+/*  0 */ 0 , 0 , 0 , BY, BY, BY, 0 , 0 , BY, BY, BY, BY, BY, BY, BY, BY,
+/*  1 */ 0 , 0 , 0 , 0 , BY, BY, BY, BY, BY, BY, BY, BY, 0 , 0 , 0 , 0 ,
+/*  2 */ BY, BY, BY, 0 , 0 , BY, 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 ,
+/*  3 */ 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , BY, BY, BY, 0 , 0 , 0 , 0 ,
 /*  4 */ BY, BY, BY, 0 , BY, 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 ,
 /*  5 */ 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 ,
 /*  6 */ BY, BY, BY, BY, 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 ,
diff --git a/src/arch/x86/decompress_displacement.cc b/src/arch/x86/decompress_displacement.cc
new file mode 100644
index 0000000000..a77cba81c2
--- /dev/null
+++ b/src/arch/x86/decompress_displacement.cc
@@ -0,0 +1,373 @@
+#include "arch/x86/decoder.hh"
+
+#include "arch/x86/regs/misc.hh"
+#include "base/logging.hh"
+#include "base/trace.hh"
+#include "base/types.hh"
+#include "debug/Decoder.hh"
+
+#include <unordered_set>
+
+namespace X86ISA {
+
+namespace {
+enum EVEXTupleType {
+  NOT_IMPLEMENTED = 0,
+  O = NOT_IMPLEMENTED,
+  FULL,
+  FU = FULL,
+  HALF,
+  HA = HALF,
+  FULL_MEM,
+  FM = FULL_MEM,
+  TUPLE1_SCALAR,
+  TS = TUPLE1_SCALAR,
+  TUPLE1_FIXED,
+  TF = TUPLE1_FIXED,
+  TUPLE1_4X,
+  TX = TUPLE1_4X,
+  TUPLE2,
+  T2 = TUPLE2,
+  TUPLE4,
+  T4 = TUPLE4,
+  TUPLE8,
+  T8 = TUPLE8,
+  HALF_MEM,
+  HM = HALF_MEM,
+  QUARTER_MEM,
+  QM = QUARTER_MEM,
+  EIGHTH_MEM,
+  EM = EIGHTH_MEM,
+  MEM128,
+  MX = MEM128,
+  MOVDDUP,
+  MO = MOVDDUP,
+};
+
+/****************************************************************
+ * Implemeted.
+ * 66 10 vmovups(load)        FULL_MEM
+ * 66 11 vmovups(store)       FULL_MEM
+ * 66 16 vmovhpd(load)        TUPLE1_SCALAR
+ * 66 28 vmovaps(load)        FULL_MEM
+ * 66 29 vmovaps(store)       FULL_MEM
+ * 66 58 vaddpd         FULL
+ * 66 59 vmulpd         FULL
+ * 66 5A vcvtpd2ps      FULL
+ * 66 5B vcvtdq2ps      FULL
+ * 66 5C vsubpd         FULL
+ * 66 5E vdivpd         FULL
+ * 66 6F vmovdqa(load)  FULL_MEM
+ * 66 7F vmovdqa(store) FULL_MEM
+ * 66 D4 vpaddq         FULL
+ * 66 DB vpandd         FULL
+ * 66 D6 vmovq          TUPLE1_SCALAR
+ * 66 FB vpsubq         FULL
+ * 66 FE vpaddd         FULL
+ */
+const EVEXTupleType EVEXTupleTypeTwoByte66[256] =
+    {    //LSB
+// MSB   O | 1 | 2 | 3 | 4 | 5 | 6 | 7 | 8 | 9 | A | B | C | D | E | F
+/*  O */ O , O , O , O , O , O , O , O , O , O , O , O , O , O , O , O ,
+/*  1 */ FM, FM, O , O , O , O , TS, O , O , O , O , O , O , O , O , O ,
+/*  2 */ O , O , O , O , O , O , O , O , FM, FM, O , O , O , O , O , O ,
+/*  3 */ O , O , O , O , O , O , O , O , O , O , O , O , O , O , O , O ,
+/*  4 */ O , O , O , O , O , O , O , O , O , O , O , O , O , O , O , O ,
+/*  5 */ O , O , O , O , O , O , O , O , FU, FU, FU, FU, FU, O , FU, O ,
+/*  6 */ O , O , O , O , O , O , O , O , O , O , O , O , O , O , O , FM,
+/*  7 */ O , O , O , O , O , O , O , O , O , O , O , O , O , O , O , FM,
+/*  8 */ O , O , O , O , O , O , O , O , O , O , O , O , O , O , O , O ,
+/*  9 */ O , O , O , O , O , O , O , O , O , O , O , O , O , O , O , O ,
+/*  A */ O , O , O , O , O , O , O , O , O , O , O , O , O , O , O , O ,
+/*  B */ O , O , O , O , O , O , O , O , O , O , O , O , O , O , O , O ,
+/*  C */ O , O , O , O , O , O , O , O , O , O , O , O , O , O , O , O ,
+/*  D */ O , O , O , O , FU, O , TS, O , O , O , O , FU, O , O , O , O ,
+/*  E */ O , O , O , O , O , O , O , O , O , O , O , O , O , O , O , O ,
+/*  F */ O , O , O , O , O , O , O , O , O , O , O , FU, O , O , FU, O
+    };
+/****************************************************************
+ * Implemeted.
+ * F3 10 vmovss         TUPLE1_SCALAR
+ * F3 2D vcvttss2si     TUPLE1_SCALAR
+ * F3 58 vaddss         TUPLE1_SCALAR
+ * F3 59 vmulss         TUPLE1_SCALAR
+ * F3 5A vcvtss2sd      TUPLE1_SCALAR
+ * F3 5C vsubss         TUPLE1_SCALAR
+ * F3 5E vdivss         TUPLE1_SCALAR
+ * F3 6F vmovdqu(load)  FULL_MEM
+ * F3 7B vcvtusi2ss     TUPLE1_SCALAR
+ * F3 7F vmovdqu(store) FULL_MEM
+ * F3 E6 vcvtdq2pd      HALF
+ */
+const EVEXTupleType EVEXTupleTypeTwoByteF3[256] =
+    {    //LSB
+// MSB   O | 1 | 2 | 3 | 4 | 5 | 6 | 7 | 8 | 9 | A | B | C | D | E | F
+/*  O */ O , O , O , O , O , O , O , O , O , O , O , O , O , O , O , O ,
+/*  1 */ TS, O , O , O , O , O , O , O , O , O , O , O , O , O , O , O ,
+/*  2 */ O , O , O , O , O , O , O , O , O , O , TS, O , O , TS, O , O ,
+/*  3 */ O , O , O , O , O , O , O , O , O , O , O , O , O , O , O , O ,
+/*  4 */ O , O , O , O , O , O , O , O , O , O , O , O , O , O , O , O ,
+/*  5 */ O , O , O , O , O , O , O , O , TS, TS, TS, O , TS, O , TS, O ,
+/*  6 */ O , O , O , O , O , O , O , O , O , O , O , O , O , O , O , FM,
+/*  7 */ O , O , O , O , O , O , O , O , O , O , O , TS, O , O , O , FM,
+/*  8 */ O , O , O , O , O , O , O , O , O , O , O , O , O , O , O , O ,
+/*  9 */ O , O , O , O , O , O , O , O , O , O , O , O , O , O , O , O ,
+/*  A */ O , O , O , O , O , O , O , O , O , O , O , O , O , O , O , O ,
+/*  B */ O , O , O , O , O , O , O , O , O , O , O , O , O , O , O , O ,
+/*  C */ O , O , O , O , O , O , O , O , O , O , O , O , O , O , O , O ,
+/*  D */ O , O , O , O , O , O , O , O , O , O , O , O , O , O , O , O ,
+/*  E */ O , O , O , O , O , O , HA, O , O , O , O , O , O , O , O , O ,
+/*  F */ O , O , O , O , O , O , O , O , O , O , O , O , O , O , O , O
+    };
+/****************************************************************
+ * Implemeted.
+ * F2 10 vmovsd(load)   TUPLE1_SCALAR
+ * F2 12 vmovddup(load) MOVDDUP
+ * F2 2A vcvtsi2sd      TUPLE1_SCALAR
+ * F2 58 vaddsd         TUPLE1_SCALAR
+ * F2 59 vmulsd         TUPLE1_SCALAR
+ * F2 5C vsubsd         TUPLE1_SCALAR
+ * F2 5A vcvtsd2ss      TUPLE1_SCALAR
+ * F2 5E vdivsd         TUPLE1_SCALAR
+ */
+const EVEXTupleType EVEXTupleTypeTwoByteF2[256] =
+    {    //LSB
+// MSB   O | 1 | 2 | 3 | 4 | 5 | 6 | 7 | 8 | 9 | A | B | C | D | E | F
+/*  O */ O , O , O , O , O , O , O , O , O , O , O , O , O , O , O , O ,
+/*  1 */ TS, O , MO, O , O , O , O , O , O , O , O , O , O , O , O , O ,
+/*  2 */ O , O , O , O , O , O , O , O , O , O , TS, O , O , O , O , O ,
+/*  3 */ O , O , O , O , O , O , O , O , O , O , O , O , O , O , O , O ,
+/*  4 */ O , O , O , O , O , O , O , O , O , O , O , O , O , O , O , O ,
+/*  5 */ O , O , O , O , O , O , O , O , TS, TS, TS, O , TS, O , TS, O ,
+/*  6 */ O , O , O , O , O , O , O , O , O , O , O , O , O , O , O , O ,
+/*  7 */ O , O , O , O , O , O , O , O , O , O , O , O , O , O , O , O ,
+/*  8 */ O , O , O , O , O , O , O , O , O , O , O , O , O , O , O , O ,
+/*  9 */ O , O , O , O , O , O , O , O , O , O , O , O , O , O , O , O ,
+/*  A */ O , O , O , O , O , O , O , O , O , O , O , O , O , O , O , O ,
+/*  B */ O , O , O , O , O , O , O , O , O , O , O , O , O , O , O , O ,
+/*  C */ O , O , O , O , O , O , O , O , O , O , O , O , O , O , O , O ,
+/*  D */ O , O , O , O , O , O , O , O , O , O , O , O , O , O , O , O ,
+/*  E */ O , O , O , O , O , O , O , O , O , O , O , O , O , O , O , O ,
+/*  F */ O , O , O , O , O , O , O , O , O , O , O , O , O , O , O , O
+    };
+/****************************************************************
+ * Implemeted.
+ * 10 vmovups(load)        FULL_MEM
+ * 11 vmovups(store)       FULL_MEM
+ * 28 vmovaps(load)        FULL_MEM
+ * 29 vmovaps(store)       FULL_MEM
+ * 58 vaddps               FULL
+ * 59 vmulps               FULL
+ * 5A vcvtps2pd            HALF
+ * 5C vsubps               FULL
+ * 5E vdivps               FULL
+ */
+const EVEXTupleType EVEXTupleTypeTwoByte[256] =
+    {    //LSB
+// MSB   O | 1 | 2 | 3 | 4 | 5 | 6 | 7 | 8 | 9 | A | B | C | D | E | F
+/*  O */ O , O , O , O , O , O , O , O , O , O , O , O , O , O , O , O ,
+/*  1 */ FM, FM, O , O , O , O , O , O , O , O , O , O , O , O , O , O ,
+/*  2 */ O , O , O , O , O , O , O , O , FM, FM, O , O , O , O , O , O ,
+/*  3 */ O , O , O , O , O , O , O , O , O , O , O , O , O , O , O , O ,
+/*  4 */ O , O , O , O , O , O , O , O , O , O , O , O , O , O , O , O ,
+/*  5 */ O , O , O , O , O , O , O , O , FU, FU, HA, O , FU, O , FU, O ,
+/*  6 */ O , O , O , O , O , O , O , O , O , O , O , O , O , O , O , O ,
+/*  7 */ O , O , O , O , O , O , O , O , O , O , O , O , O , O , O , O ,
+/*  8 */ O , O , O , O , O , O , O , O , O , O , O , O , O , O , O , O ,
+/*  9 */ O , O , O , O , O , O , O , O , O , O , O , O , O , O , O , O ,
+/*  A */ O , O , O , O , O , O , O , O , O , O , O , O , O , O , O , O ,
+/*  B */ O , O , O , O , O , O , O , O , O , O , O , O , O , O , O , O ,
+/*  C */ O , O , O , O , O , O , O , O , O , O , O , O , O , O , O , O ,
+/*  D */ O , O , O , O , O , O , O , O , O , O , O , O , O , O , O , O ,
+/*  E */ O , O , O , O , O , O , O , O , O , O , O , O , O , O , O , O ,
+/*  F */ O , O , O , O , O , O , O , O , O , O , O , O , O , O , O , O
+    };
+/****************************************************************
+ * Implemeted.
+ *   66 18 vbroadcastss           TUPLE1_SCALAR
+ *   66 19 vbroadcastsd(W1)       TUPLE1_SCALAR
+ * ! 66 19 vbroadcastf32x2(W0)    TUPLE2
+ *   66 39 vpminsd,vpminsq        FULL
+ *   66 58 vbroadcastd            TUPLE1_SCALAR
+ *   66 B8 vfmadd231ps            FULL
+ */
+const EVEXTupleType EVEXTupleTypeThreeByte660F38[256] =
+    {    //LSB
+// MSB   O | 1 | 2 | 3 | 4 | 5 | 6 | 7 | 8 | 9 | A | B | C | D | E | F
+/*  O */ O , O , O , O , O , O , O , O , O , O , O , O , O , O , O , O ,
+/*  1 */ O , O , O , O , O , O , O , O , TS, TS, O , O , O , O , O , O ,
+/*  2 */ O , O , O , O , O , O , O , O , O , O , O , O , O , O , O , O ,
+/*  3 */ O , O , O , O , O , O , O , O , O , FU, O , O , O , O , O , O ,
+/*  4 */ O , O , O , O , O , O , O , O , O , O , O , O , O , O , O , O ,
+/*  5 */ O , O , O , O , O , O , O , O , TS, O , O , O , O , O , O , O ,
+/*  6 */ O , O , O , O , O , O , O , O , O , O , O , O , O , O , O , O ,
+/*  7 */ O , O , O , O , O , O , O , O , O , O , O , O , O , O , O , O ,
+/*  8 */ O , O , O , O , O , O , O , O , O , O , O , O , O , O , O , O ,
+/*  9 */ O , O , O , O , O , O , O , O , O , O , O , O , O , O , O , O ,
+/*  A */ O , O , O , O , O , O , O , O , O , O , O , O , O , O , O , O ,
+/*  B */ O , O , O , O , O , O , O , O , FU, O , O , O , O , O , O , O ,
+/*  C */ O , O , O , O , O , O , O , O , O , O , O , O , O , O , O , O ,
+/*  D */ O , O , O , O , O , O , O , O , O , O , O , O , O , O , O , O ,
+/*  E */ O , O , O , O , O , O , O , O , O , O , O , O , O , O , O , O ,
+/*  F */ O , O , O , O , O , O , O , O , O , O , O , O , O , O , O , O
+    };
+/****************************************************************
+ * Implemeted.
+ *   F3 35 vpmovda                HALF_MEM
+ */
+const EVEXTupleType EVEXTupleTypeThreeByteF30F38[256] =
+    {    //LSB
+// MSB   O | 1 | 2 | 3 | 4 | 5 | 6 | 7 | 8 | 9 | A | B | C | D | E | F
+/*  O */ O , O , O , O , O , O , O , O , O , O , O , O , O , O , O , O ,
+/*  1 */ O , O , O , O , O , O , O , O , O , O , O , O , O , O , O , O ,
+/*  2 */ O , O , O , O , O , O , O , O , O , O , O , O , O , O , O , O ,
+/*  3 */ O , O , O , O , O , HM, O , O , O , O , O , O , O , O , O , O ,
+/*  4 */ O , O , O , O , O , O , O , O , O , O , O , O , O , O , O , O ,
+/*  5 */ O , O , O , O , O , O , O , O , O , O , O , O , O , O , O , O ,
+/*  6 */ O , O , O , O , O , O , O , O , O , O , O , O , O , O , O , O ,
+/*  7 */ O , O , O , O , O , O , O , O , O , O , O , O , O , O , O , O ,
+/*  8 */ O , O , O , O , O , O , O , O , O , O , O , O , O , O , O , O ,
+/*  9 */ O , O , O , O , O , O , O , O , O , O , O , O , O , O , O , O ,
+/*  A */ O , O , O , O , O , O , O , O , O , O , O , O , O , O , O , O ,
+/*  B */ O , O , O , O , O , O , O , O , O , O , O , O , O , O , O , O ,
+/*  C */ O , O , O , O , O , O , O , O , O , O , O , O , O , O , O , O ,
+/*  D */ O , O , O , O , O , O , O , O , O , O , O , O , O , O , O , O ,
+/*  E */ O , O , O , O , O , O , O , O , O , O , O , O , O , O , O , O ,
+/*  F */ O , O , O , O , O , O , O , O , O , O , O , O , O , O , O , O
+    };
+/****************************************************************
+ * Implemeted.
+ *   66 03 valign                  FULL
+ *   66 05 vpermilpd               FULL
+ *   66 16 vpextrq                 TUPLE1_SCALAR
+ * ! 66 18 vinsertf128             TUPLE2/TUPLE4
+ *   66 25 vpternlog               FULL
+ * ! 66 39 vextracti128            TUPLE2/TUPLE4
+ */
+const EVEXTupleType EVEXTupleTypeThreeByte660F3A[256] =
+    {    //LSB
+// MSB   O | 1 | 2 | 3 | 4 | 5 | 6 | 7 | 8 | 9 | A | B | C | D | E | F
+/*  O */ O , O , O , FU, O , FU, O , O , O , O , O , O , O , O , O , O ,
+/*  1 */ O , O , O , O , O , O , TS, O , T2, O , O , O , O , O , O , O ,
+/*  2 */ O , O , O , O , O , FU, O , O , O , O , O , O , O , O , O , O ,
+/*  3 */ O , O , O , O , O , O , O , O , O , T2, O , O , O , O , O , O ,
+/*  4 */ O , O , O , O , O , O , O , O , O , O , O , O , O , O , O , O ,
+/*  5 */ O , O , O , O , O , O , O , O , O , O , O , O , O , O , O , O ,
+/*  6 */ O , O , O , O , O , O , O , O , O , O , O , O , O , O , O , O ,
+/*  7 */ O , O , O , O , O , O , O , O , O , O , O , O , O , O , O , O ,
+/*  8 */ O , O , O , O , O , O , O , O , O , O , O , O , O , O , O , O ,
+/*  9 */ O , O , O , O , O , O , O , O , O , O , O , O , O , O , O , O ,
+/*  A */ O , O , O , O , O , O , O , O , O , O , O , O , O , O , O , O ,
+/*  B */ O , O , O , O , O , O , O , O , O , O , O , O , O , O , O , O ,
+/*  C */ O , O , O , O , O , O , O , O , O , O , O , O , O , O , O , O ,
+/*  D */ O , O , O , O , O , O , O , O , O , O , O , O , O , O , O , O ,
+/*  E */ O , O , O , O , O , O , O , O , O , O , O , O , O , O , O , O ,
+/*  F */ O , O , O , O , O , O , O , O , O , O , O , O , O , O , O , O
+    };
+/**
+ * TODO: I did not handle tuple type of 66 0F 3A as they are often
+ * TODO: dependent on W -> tuple type. So far I just make them panic.
+ */
+}
+
+void Decoder::processCompressedDisplacement() {
+  /**
+   * ! Compressed Displacement.
+   * EVEX instructions with one byte displacement always
+   * uses compressed displacement. The displacement should
+   * be multiplied by a factor N.
+   *
+   * It is quite complicated, so far we only do this in adhoc way.
+   *
+   */
+  if (!emi.evex.evex_present) {
+    return;
+  }
+  if (emi.dispSize != 1) {
+    return;
+  }
+
+  EVEXTupleType tupleType = EVEXTupleType::NOT_IMPLEMENTED;
+  switch (emi.opcode.type) {
+    case OneByteOpcode: break;
+    case TwoByteOpcode: {
+      switch (emi.legacy.decodeVal) {
+        case 0x1: tupleType = EVEXTupleTypeTwoByte66[emi.opcode.op]; break;
+        case 0x4: tupleType = EVEXTupleTypeTwoByteF3[emi.opcode.op]; break;
+        case 0x8: tupleType = EVEXTupleTypeTwoByteF2[emi.opcode.op]; break;
+        case 0x0: tupleType = EVEXTupleTypeTwoByte[emi.opcode.op]; break;
+      }
+      break;
+    }
+    case ThreeByte0F38Opcode: {
+      switch (emi.legacy.decodeVal) {
+        case 0x1: tupleType = EVEXTupleTypeThreeByte660F38[emi.opcode.op]; break;
+        case 0x4: tupleType = EVEXTupleTypeThreeByteF30F38[emi.opcode.op]; break;
+      }
+      break;
+    }
+    case ThreeByte0F3AOpcode: {
+      switch (emi.legacy.decodeVal) {
+        case 0x1: {
+          tupleType = EVEXTupleTypeThreeByte660F38[emi.opcode.op];
+          if (emi.opcode.op == 0x18) {
+          // Special case for 66 0F 3A 18 vinsert32x4/vinsertf64x2.
+            tupleType = emi.rex.w ? EVEXTupleType::TUPLE2 : EVEXTupleType::TUPLE4;
+          } else if (emi.opcode.op == 0x39) {
+          // Special case for 66 0F 3A 39 vextracti32x4/vextracti64x2.
+            tupleType = emi.rex.w ? EVEXTupleType::TUPLE2 : EVEXTupleType::TUPLE4;
+          }
+          break;
+        }
+      }
+      break;
+    }
+    case BadOpcode: break;
+  }
+
+  // Convert to signed int64_t.
+  // assert(tupleType != EVEXTupleType::NOT_IMPLEMENTED && "TupleType not implemented.\n");
+  int64_t displacment = emi.displacement;
+  int64_t N = 1;
+  switch (tupleType) {
+    case FULL: {
+      if (emi.evex.b) {
+        N = emi.rex.w ? 8 : 4;
+      } else {
+        N = 16 * (emi.evex.l_extend << 1);
+      }
+      break;
+    }
+    case HALF: {
+      if (emi.evex.b) {
+        N = 4;
+      } else {
+        N = 8 * (emi.evex.l_extend << 1);
+      }
+      break;
+    }
+    case FULL_MEM:      N = 16 * (emi.evex.l_extend << 1); break;
+    case HALF_MEM:      N = 8 * (emi.evex.l_extend << 1); break;
+    case TUPLE1_SCALAR: N = emi.rex.w ? 8 : 4; break;
+    case TUPLE2:        N = emi.rex.w ? 16 : 8; break;
+    case TUPLE4:        N = emi.rex.w ? 32 : 16; break;
+    case MOVDDUP: {
+      switch (emi.evex.l_extend) {
+        case 0: N = 8; break;
+        case 1: N = 32; break;
+        case 2: N = 64; break;
+      }
+      break;
+    }
+    default: {
+      warn("Don't know how to expand displacement for %#x %s.\n", this->origPC,
+            emi);
+      break;
+    }
+  }
+  DPRINTF(Decoder, "Expand displacement pc %#x op %x %lld x %lld = %lld.\n",
+          this->origPC, emi.opcode.op, displacment, N, displacment * N);
+  emi.displacement = displacment * N;
+}
+
+} // namespace X86ISA
diff --git a/src/arch/x86/insts/macroop.hh b/src/arch/x86/insts/macroop.hh
index 5b27127e97..aba09fb3aa 100644
--- a/src/arch/x86/insts/macroop.hh
+++ b/src/arch/x86/insts/macroop.hh
@@ -73,7 +73,7 @@ class MacroopBase : public X86StaticInst
     StaticInstPtr * microops;
 
     StaticInstPtr
-    fetchMicroop(MicroPC microPC) const override
+    fetchMicroop(MicroPC microPC) const
     {
         if (microPC >= numMicroops)
             return badMicroop;
@@ -82,8 +82,7 @@ class MacroopBase : public X86StaticInst
     }
 
     std::string
-    generateDisassembly(Addr pc,
-                        const Loader::SymbolTable *symtab) const override
+    generateDisassembly(Addr pc, const Loader::SymbolTable *symtab) const
     {
         return mnemonic;
     }
@@ -100,6 +99,8 @@ class MacroopBase : public X86StaticInst
     {
         return env;
     }
+
+    uint32_t getNumMicroops() const { return this->numMicroops; }
 };
 }
 
diff --git a/src/arch/x86/insts/microavxop.cc b/src/arch/x86/insts/microavxop.cc
new file mode 100644
index 0000000000..c87bef3596
--- /dev/null
+++ b/src/arch/x86/insts/microavxop.cc
@@ -0,0 +1,153 @@
+#include "arch/x86/insts/microavxop.hh"
+
+#include <string>
+
+#include "arch/x86/regs/misc.hh"
+#include "cpu/exec_context.hh"
+
+namespace X86ISA {
+std::string
+AVXOpBase::generateDisassembly(Addr pc,
+                               const ::Loader::SymbolTable *symtab) const {
+  std::stringstream response;
+
+  printMnemonic(response, instMnem, mnemonic);
+  printDestReg(response, 0, destSize);
+  if (this->srcType == SrcType::Non) {
+    return response.str();
+  }
+  response << ", ";
+  printSrcReg(response, 0, srcSize);
+  switch (this->srcType) {
+  case RegReg: {
+    response << ", ";
+    printSrcReg(response, 1, srcSize);
+    break;
+  }
+  case RegImm: {
+    ccprintf(response, ", %#x", imm8);
+    break;
+  }
+  case RegRegImm: {
+    response << ", ";
+    printSrcReg(response, 1, srcSize);
+    ccprintf(response, ", %#x", imm8);
+    break;
+  }
+  case RegRegReg: {
+    response << ", ";
+    printSrcReg(response, 1, srcSize);
+    response << ", ";
+    printSrcReg(response, 2, srcSize);
+    break;
+  }
+  default:
+    break;
+  }
+  return response.str();
+}
+
+AVXOpBase::FloatInt AVXOpBase::calcPackedBinaryOp(FloatInt src1, FloatInt src2,
+                                                  BinaryOp op) const {
+  FloatInt dest;
+  if (this->srcSize == 4) {
+    // 2 float.
+    switch (op) {
+    case BinaryOp::FloatAdd:
+      dest.f.f1 = src1.f.f1 + src2.f.f1;
+      dest.f.f2 = src1.f.f2 + src2.f.f2;
+      break;
+    case BinaryOp::FloatSub:
+      dest.f.f1 = src1.f.f1 - src2.f.f1;
+      dest.f.f2 = src1.f.f2 - src2.f.f2;
+      break;
+    case BinaryOp::FloatMul:
+      dest.f.f1 = src1.f.f1 * src2.f.f1;
+      dest.f.f2 = src1.f.f2 * src2.f.f2;
+      break;
+    case BinaryOp::FloatDiv:
+      dest.f.f1 = src1.f.f1 / src2.f.f1;
+      dest.f.f2 = src1.f.f2 / src2.f.f2;
+      break;
+    case BinaryOp::IntAdd:
+      dest.si.i1 = src1.si.i1 + src2.si.i1;
+      dest.si.i2 = src1.si.i2 + src2.si.i2;
+      break;
+    case BinaryOp::IntSub:
+      dest.si.i1 = src1.si.i1 - src2.si.i1;
+      dest.si.i2 = src1.si.i2 - src2.si.i2;
+      break;
+    case BinaryOp::IntAnd:
+      dest.si.i1 = src1.si.i1 & src2.si.i1;
+      dest.si.i2 = src1.si.i2 & src2.si.i2;
+      break;
+    case BinaryOp::SIntMin:
+      dest.si.i1 = std::min(src1.si.i1, src2.si.i1);
+      dest.si.i2 = std::min(src1.si.i2, src2.si.i2);
+      break;
+    default:
+      assert(false && "Invalid op type.");
+    }
+  } else {
+    // 1 double;
+    switch (op) {
+    case BinaryOp::FloatAdd:
+      dest.d = src1.d + src2.d;
+      break;
+    case BinaryOp::FloatSub:
+      dest.d = src1.d - src2.d;
+      break;
+    case BinaryOp::FloatMul:
+      dest.d = src1.d * src2.d;
+      break;
+    case BinaryOp::FloatDiv:
+      dest.d = src1.d / src2.d;
+      break;
+    case BinaryOp::IntAdd:
+      dest.sl = src1.sl + src2.sl;
+      break;
+    case BinaryOp::IntSub:
+      dest.sl = src1.sl - src2.sl;
+      break;
+    case BinaryOp::IntAnd:
+      dest.sl = src1.sl & src2.sl;
+      break;
+    case BinaryOp::SIntMin:
+      dest.sl = std::min(src1.sl, src2.sl);
+      break;
+    default:
+      assert(false && "Invalid op type.");
+    }
+  }
+  return dest;
+}
+
+void AVXOpBase::doPackedBinaryOp(ExecContext *xc, BinaryOp op) const {
+  auto vRegs = destVL / sizeof(uint64_t);
+  FloatInt src1;
+  FloatInt src2;
+  for (int i = 0; i < vRegs; i++) {
+    src1.ul = xc->readFloatRegOperandBits(this, i * 2 + 0);
+    src2.ul = xc->readFloatRegOperandBits(this, i * 2 + 1);
+    auto dest = this->calcPackedBinaryOp(src1, src2, op);
+    xc->setFloatRegOperandBits(this, i, dest.ul);
+  }
+}
+
+void AVXOpBase::doFusedPackedBinaryOp(ExecContext *xc, BinaryOp op1,
+                                      BinaryOp op2) const {
+  auto vRegs = destVL / sizeof(uint64_t);
+  FloatInt src1;
+  FloatInt src2;
+  FloatInt src3;
+  for (int i = 0; i < vRegs; i++) {
+    src1.ul = xc->readFloatRegOperandBits(this, i * 3 + 0);
+    src2.ul = xc->readFloatRegOperandBits(this, i * 3 + 1);
+    src3.ul = xc->readFloatRegOperandBits(this, i * 3 + 2);
+    auto tmp = this->calcPackedBinaryOp(src1, src2, op1);
+    auto dest = this->calcPackedBinaryOp(tmp, src3, op2);
+    xc->setFloatRegOperandBits(this, i, dest.ul);
+  }
+}
+
+} // namespace X86ISA
diff --git a/src/arch/x86/insts/microavxop.hh b/src/arch/x86/insts/microavxop.hh
new file mode 100644
index 0000000000..ef3c5ba591
--- /dev/null
+++ b/src/arch/x86/insts/microavxop.hh
@@ -0,0 +1,119 @@
+#ifndef __ARCH_X86_INSTS_MICROAVXOP_HH__
+#define __ARCH_X86_INSTS_MICROAVXOP_HH__
+
+#include "arch/x86/insts/microop.hh"
+
+namespace X86ISA {
+
+class AVXOpBase : public X86MicroopBase {
+
+public:
+  enum SrcType {
+    Non = 0,
+    Reg,
+    RegReg,
+    RegImm,
+    RegRegImm,
+    RegRegReg, // Three opreands.
+  };
+
+protected:
+  const SrcType srcType;
+  const RegIndex dest;
+  const RegIndex src1;
+  const RegIndex src2;
+  const uint8_t destSize;
+  const uint8_t destVL;
+  const uint8_t srcSize;
+  const uint8_t srcVL;
+  const uint8_t imm8;
+  const uint8_t ext;
+
+  // Constructor
+  AVXOpBase(ExtMachInst _machInst, const char *_mnem, const char *_instMnem,
+            uint64_t _setFlags, OpClass _opClass, SrcType _srcType,
+            InstRegIndex _dest, InstRegIndex _src1, InstRegIndex _src2,
+            uint8_t _destSize, uint8_t _destVL, uint8_t _srcSize,
+            uint8_t _srcVL, uint8_t _imm8, uint8_t _ext)
+      : X86MicroopBase(_machInst, _mnem, _instMnem, _setFlags, _opClass),
+        srcType(_srcType), dest(_dest.index()), src1(_src1.index()),
+        src2(_src2.index()), destSize(_destSize), destVL(_destVL),
+        srcSize(_srcSize), srcVL(_srcVL), imm8(_imm8), ext(_ext) {
+    assert((destVL % sizeof(uint64_t) == 0) && "Invalid destVL.\n");
+    assert((srcVL % sizeof(uint64_t) == 0) && "Invalid srcVL.\n");
+  }
+
+  std::string generateDisassembly(Addr pc,
+                                  const ::Loader::SymbolTable *symtab) const;
+
+  union FloatInt {
+    struct __attribute__((packed)) {
+      float f1;
+      float f2;
+    } f;
+    double d;
+    struct __attribute__((packed)) {
+      uint32_t i1;
+      uint32_t i2;
+    } ui;
+    struct __attribute__((packed)) {
+      int32_t i1;
+      int32_t i2;
+    } si;
+    struct __attribute__((packed)) {
+      uint8_t i1;
+      uint8_t i2;
+      uint8_t i3;
+      uint8_t i4;
+      uint8_t i5;
+      uint8_t i6;
+      uint8_t i7;
+      uint8_t i8;
+    } uc;
+    struct __attribute__((packed)) {
+      int8_t i1;
+      int8_t i2;
+      int8_t i3;
+      int8_t i4;
+      int8_t i5;
+      int8_t i6;
+      int8_t i7;
+      int8_t i8;
+    } sc;
+    uint64_t ul;
+    int64_t sl;
+  };
+
+  enum BinaryOp {
+    FloatAdd,
+    FloatSub,
+    FloatMul,
+    FloatDiv,
+    // Add/Sub can ignore sign.
+    IntAdd,
+    IntSub,
+    IntAnd,
+    SIntMin,
+  };
+
+  FloatInt calcPackedBinaryOp(FloatInt src1, FloatInt src2, BinaryOp op) const;
+  // A helper function to perform packed src1 op src2
+  void doPackedBinaryOp(ExecContext *xc, BinaryOp op) const;
+  // A helper function to perform packed (src1 op1 src2) op2 src3
+  void doFusedPackedBinaryOp(ExecContext *xc, BinaryOp op1, BinaryOp op2) const;
+
+  // A helper function to add dest regs.
+  inline void addAVXDestRegs() {
+    auto vDestRegs = destVL / sizeof(uint64_t);
+    assert(vDestRegs <= NumXMMSubRegs && "DestVL overflow.");
+    _numDestRegs = _numFPDestRegs = vDestRegs;
+    assert(_numDestRegs <= MaxInstDestRegs && "DestRegs overflow.");
+    for (int i = 0; i < vDestRegs; i++) {
+      setDestRegIdx(i, RegId(FloatRegClass, dest + i));
+    }
+  }
+};
+
+} // namespace X86ISA
+
+#endif //__ARCH_X86_INSTS_MICROAVXOP_HH__
diff --git a/src/arch/x86/insts/microfpop.hh b/src/arch/x86/insts/microfpop.hh
index f1dc15b22d..d13af317b0 100644
--- a/src/arch/x86/insts/microfpop.hh
+++ b/src/arch/x86/insts/microfpop.hh
@@ -75,7 +75,7 @@ namespace X86ISA
         bool checkCondition(uint64_t flags) const;*/
 
         std::string generateDisassembly(
-                Addr pc, const Loader::SymbolTable *symtab) const override;
+                Addr pc, const Loader::SymbolTable *symtab) const;
     };
 }
 
diff --git a/src/arch/x86/insts/static_inst.cc b/src/arch/x86/insts/static_inst.cc
index 387ed903d6..c6af9a8277 100644
--- a/src/arch/x86/insts/static_inst.cc
+++ b/src/arch/x86/insts/static_inst.cc
@@ -120,7 +120,14 @@ namespace X86ISA
     void
     X86StaticInst::printReg(std::ostream &os, RegId reg, int size) const
     {
-        assert(size == 1 || size == 2 || size == 4 || size == 8);
+        if (reg.isFloatReg()) {
+            // We allow xmm registers to have 128, 256 and 512.
+            assert(size == 1 || size == 2 || size == 4 || size == 8 ||
+                    size == 16 || size == 32 || size == 48 || size == 52 ||
+                    size == 64);
+        } else {
+            assert(size == 1 || size == 2 || size == 4 || size == 8);
+        }
         static const char * abcdFormats[9] =
             {"", "%s",  "%sx",  "", "e%sx", "", "", "", "r%sx"};
         static const char * piFormats[9] =
@@ -202,12 +209,12 @@ namespace X86ISA
                 return;
             }
             reg_idx -= NumMMXRegs;
-            if (reg_idx < NumXMMRegs * 2) {
-                ccprintf(os, "%%xmm%d_%s", reg_idx / 2,
-                        (reg_idx % 2) ? "high": "low");
+            if (reg_idx < NumXMMRegs * NumXMMSubRegs) {
+                ccprintf(os, "%%xmm%d_%d(%d)", reg_idx / NumXMMSubRegs,
+                         reg_idx % NumXMMSubRegs, size);
                 return;
             }
-            reg_idx -= NumXMMRegs * 2;
+            reg_idx -= NumXMMRegs * NumXMMSubRegs;
             if (reg_idx < NumMicroFpRegs) {
                 ccprintf(os, "%%ufp%d", reg_idx);
                 return;
diff --git a/src/arch/x86/isa/bitfields.isa b/src/arch/x86/isa/bitfields.isa
index 9522a8d5bc..a841a96098 100644
--- a/src/arch/x86/isa/bitfields.isa
+++ b/src/arch/x86/isa/bitfields.isa
@@ -86,5 +86,10 @@ def bitfield MODE mode;
 def bitfield MODE_MODE mode.mode;
 def bitfield MODE_SUBMODE mode.submode;
 
-def bitfield VEX_V vex.v;
-def bitfield VEX_L vex.l;
+def bitfield VEX_PRESENT      evex.vex_present;
+def bitfield EVEX_PRESENT     evex.evex_present;
+def bitfield EVEX_PREFIX_TYPE evex.present;
+def bitfield EVEX_L           evex.l;
+def bitfield EVEX_L_PRIME     evex.l_prime;
+def bitfield EVEX_L_EXTEND    evex.l_extend;
+def bitfield EVEX_R_PRIME     evex.r_prime;
\ No newline at end of file
diff --git a/src/arch/x86/isa/decoder/decoder.isa b/src/arch/x86/isa/decoder/decoder.isa
index 69fb3d5a0d..b8de75991a 100644
--- a/src/arch/x86/isa/decoder/decoder.isa
+++ b/src/arch/x86/isa/decoder/decoder.isa
@@ -38,15 +38,28 @@
 // The actual decoder specification
 //
 
-decode LEGACY_LOCK default Unknown::unknown()
-{
+decode LEGACY_LOCK default Unknown::unknown() {
     //No lock prefix
-    0x0: decode OPCODE_TYPE default Unknown::unknown()
-    {
-        ##include "one_byte_opcodes.isa"
-        ##include "two_byte_opcodes.isa"
-        ##include "three_byte_0f38_opcodes.isa"
-        ##include "three_byte_0f3a_opcodes.isa"
+    0x0: decode EVEX_PREFIX_TYPE {
+        // VEX Prefix
+        0x1: decode OPCODE_TYPE {
+            ##include "two_byte_opcodes_vex.isa"
+            ##include "three_byte_0f38_opcodes_vex.isa"
+            ##include "three_byte_0f3a_opcodes_vex.isa"
+        }
+        // EVEX Prefix
+        0x2: decode OPCODE_TYPE {
+            ##include "two_byte_opcodes_evex.isa"
+            ##include "three_byte_0f38_opcodes_evex.isa"
+            ##include "three_byte_0f3a_opcodes_evex.isa"
+        }
+        // No VEX/EVEX Prefix
+        0x0: decode OPCODE_TYPE {
+            ##include "one_byte_opcodes.isa"
+            ##include "two_byte_opcodes.isa"
+            ##include "three_byte_0f38_opcodes.isa"
+            ##include "three_byte_0f3a_opcodes.isa"
+        }
     }
     //Lock prefix
     ##include "locked_opcodes.isa"
diff --git a/src/arch/x86/isa/decoder/three_byte_0f38_opcodes_evex.isa b/src/arch/x86/isa/decoder/three_byte_0f38_opcodes_evex.isa
new file mode 100644
index 0000000000..1eac16fec3
--- /dev/null
+++ b/src/arch/x86/isa/decoder/three_byte_0f38_opcodes_evex.isa
@@ -0,0 +1,98 @@
+// Copyright (c) 2008 The Regents of The University of Michigan
+// All rights reserved.
+//
+// Redistribution and use in source and binary forms, with or without
+// modification, are permitted provided that the following conditions are
+// met: redistributions of source code must retain the above copyright
+// notice, this list of conditions and the following disclaimer;
+// redistributions in binary form must reproduce the above copyright
+// notice, this list of conditions and the following disclaimer in the
+// documentation and/or other materials provided with the distribution;
+// neither the name of the copyright holders nor the names of its
+// contributors may be used to endorse or promote products derived from
+// this software without specific prior written permission.
+//
+// THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS
+// "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT
+// LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR
+// A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT
+// OWNER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,
+// SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT
+// LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,
+// DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY
+// THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
+// (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE
+// OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
+//
+// Authors: Gabe Black
+
+////////////////////////////////////////////////////////////////////
+//
+// Decode the three byte opcodes with the 0f38 prefix.
+//
+'X86ISA::ThreeByte0F38Opcode': decode LEGACY_OP {
+    format Inst {
+        1: decode LEGACY_DECODEVAL {
+            // 0x66
+            0x1: decode OPCODE_OP {
+                0x18: decode EVEX_L_EXTEND {
+                    0x2: VBROADCASTSS(VZqo, Wq);
+                }
+                0x19: decode REX_W {
+                    0x1: decode EVEX_L_EXTEND {
+                        0x2: VBROADCASTSD(VZqo, Wq);
+                        0x1: VBROADCASTSD(VYdo, Wq);
+                    }
+                }
+                0x39: decode REX_W {
+                    0x1: decode EVEX_L_EXTEND {
+                        0x2: VPMINSQ(VZqo, WZqo);
+                        0x1: VPMINSQ(VYdo, WYdo);
+                        0x0: VPMINSQ(Vo, Wo);
+                    }
+                    0x0: decode EVEX_L_EXTEND {
+                        0x2: VPMINSD(VZqo, WZqo);
+                        0x1: VPMINSD(VYdo, WYdo);
+                        0x0: VPMINSD(Vo, Wo);
+                    }
+                }
+                0x58: decode REX_W {
+                    0x0: decode EVEX_L_EXTEND {
+                        0x2: VPBROADCASTD(VZqo, Wd);
+                        0x1: VPBROADCASTD(VYdo, Wd);
+                        0x0: VPBROADCASTD(Vo, Wd);
+                    }
+                }
+                0x59: decode REX_W {
+                    0x1: decode EVEX_L_EXTEND {
+                        0x2: VPBROADCASTQ(VZqo, Wq);
+                    }
+                }
+                0x7C: decode REX_W {
+                    0x1: decode EVEX_L_EXTEND {
+                        0x2: VPBROADCASTQ(VZqo, Eqo);
+                    }
+                }
+                0xB8: decode REX_W {
+                    0x0: decode EVEX_L_EXTEND {
+                        0x2: VFMADD231PS(VZqo, WZqo);
+                        0x1: VFMADD231PS(VYdo, WYdo);
+                        0x0: VFMADD231PS(Vo, Wo);
+                    }
+                }
+            }
+        }
+        0: decode LEGACY_DECODEVAL {
+            // 0xF3
+            0x4: decode OPCODE_OP {
+                0x35: decode REX_W {
+                    0x0: decode EVEX_L_EXTEND {
+                        0x2: VPMOVDQ(WYdo, VZqo);
+                        0x1: VPMOVDQ(Wo, VYdo);
+                        0x0: VPMOVDQ(Wq, Vo);
+                    }
+                }
+            }
+        }
+    }
+}
diff --git a/src/arch/x86/isa/decoder/three_byte_0f38_opcodes_vex.isa b/src/arch/x86/isa/decoder/three_byte_0f38_opcodes_vex.isa
new file mode 100644
index 0000000000..708e269c89
--- /dev/null
+++ b/src/arch/x86/isa/decoder/three_byte_0f38_opcodes_vex.isa
@@ -0,0 +1,52 @@
+// Copyright (c) 2008 The Regents of The University of Michigan
+// All rights reserved.
+//
+// Redistribution and use in source and binary forms, with or without
+// modification, are permitted provided that the following conditions are
+// met: redistributions of source code must retain the above copyright
+// notice, this list of conditions and the following disclaimer;
+// redistributions in binary form must reproduce the above copyright
+// notice, this list of conditions and the following disclaimer in the
+// documentation and/or other materials provided with the distribution;
+// neither the name of the copyright holders nor the names of its
+// contributors may be used to endorse or promote products derived from
+// this software without specific prior written permission.
+//
+// THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS
+// "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT
+// LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR
+// A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT
+// OWNER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,
+// SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT
+// LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,
+// DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY
+// THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
+// (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE
+// OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
+//
+// Authors: Gabe Black
+
+////////////////////////////////////////////////////////////////////
+//
+// Decode the three byte opcodes with the 0f38 prefix.
+//
+'X86ISA::ThreeByte0F38Opcode': decode LEGACY_OP {
+    format Inst {
+        1: decode LEGACY_DECODEVAL {
+            // 0x66
+            0x1: decode OPCODE_OP {
+                0x18: decode EVEX_L {
+                    0x1: VBROADCASTSS(VYdo, Wq);
+                    0x0: VBROADCASTSS(Vo, Wq);
+                }
+                0x58: decode EVEX_L {
+                    0x1: VPBROADCASTD(VYdo, Wd);
+                    0x0: VPBROADCASTD(Vo, Wd);
+                }
+                0x78: decode EVEX_L {
+                    0x1: VPBROADCASTB(VYdo, Wb);
+                }
+            }
+        }
+    }
+}
diff --git a/src/arch/x86/isa/decoder/three_byte_0f3a_opcodes_evex.isa b/src/arch/x86/isa/decoder/three_byte_0f3a_opcodes_evex.isa
new file mode 100644
index 0000000000..98159a6a56
--- /dev/null
+++ b/src/arch/x86/isa/decoder/three_byte_0f3a_opcodes_evex.isa
@@ -0,0 +1,130 @@
+// Copyright (c) 2008 The Regents of The University of Michigan
+// All rights reserved.
+//
+// Redistribution and use in source and binary forms, with or without
+// modification, are permitted provided that the following conditions are
+// met: redistributions of source code must retain the above copyright
+// notice, this list of conditions and the following disclaimer;
+// redistributions in binary form must reproduce the above copyright
+// notice, this list of conditions and the following disclaimer in the
+// documentation and/or other materials provided with the distribution;
+// neither the name of the copyright holders nor the names of its
+// contributors may be used to endorse or promote products derived from
+// this software without specific prior written permission.
+//
+// THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS
+// "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT
+// LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR
+// A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT
+// OWNER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,
+// SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT
+// LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,
+// DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY
+// THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
+// (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE
+// OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
+//
+// Authors: Gabe Black
+
+////////////////////////////////////////////////////////////////////
+//
+// Decode the three byte opcodes with the 0f3a prefix.
+//
+'X86ISA::ThreeByte0F3AOpcode': decode LEGACY_OP {
+    1: decode LEGACY_DECODEVAL {
+        format Inst {
+            // 0x66
+            0x1: decode OPCODE_OP {
+                0x03: decode EVEX_L_EXTEND {
+                    0x2: decode REX_W {
+                        0x1: VALIGNQ(VZqo, WZqo, Ib);
+                        0x0: VALIGND(VZqo, WZqo, Ib);
+                    }
+                    0x1: decode REX_W {
+                        0x1: VALIGNQ(VYdo, WYdo, Ib);
+                        0x0: VALIGND(VYdo, WYdo, Ib);
+                    }
+                    0x0: decode REX_W {
+                        0x1: VALIGNQ(Vo, Wo, Ib);
+                        0x0: VALIGND(Vo, Wo, Ib);
+                    }
+                }
+                0x05: decode EVEX_L_EXTEND {
+                    0x2: VPERMILPD(VZqo, WZqo, Ib);
+                    0x1: VPERMILPD(VYdo, WYdo, Ib);
+                    0x0: VPERMILPD(Vo, Wo, Ib);
+                }
+                0x16: decode EVEX_L_EXTEND {
+                    0x0: decode REX_W {
+                        0x1: decode IMMEDIATE {
+                            0x0: VPEXTRQL(Eq, Vo, Ib);
+                            0x1: VPEXTRQH(Eq, Vo, Ib);
+                        }
+                    }
+                }
+                0x18: decode EVEX_L_EXTEND {
+                    0x1: decode IMMEDIATE {
+                        0x0: VINSERT128L(VYdo, Wo, Ib);
+                        0x1: VINSERT128H(VYdo, Wo, Ib);
+                    }
+                }
+                0x1A: decode EVEX_L_EXTEND {
+                    0x2: decode IMMEDIATE {
+                        0x0: VINSERT256L(VZqo, WYdo, Ib);
+                        0x1: VINSERT256H(VZqo, WYdo, Ib);
+                    }
+                }
+                0x1B: decode EVEX_L_EXTEND {
+                    0x2: decode REX_W {
+                        0x1: decode IMMEDIATE {
+                            0x0: VEXTRACT256L(WYdo, VZqo, Ib);
+                            0x1: VEXTRACT256H(WYdo, VZqo, Ib);
+                        }
+                    }
+                }
+                0x25: decode EVEX_L_EXTEND {
+                    0x2: decode REX_W {
+                        0x1: VPTERNLOGQ(VZqo, WZqo, Ib);
+                        0x0: VPTERNLOGD(VZqo, WZqo, Ib);
+                    }
+                    0x1: decode REX_W {
+                        0x1: VPTERNLOGQ(VYdo, WYdo, Ib);
+                        0x0: VPTERNLOGD(VYdo, WYdo, Ib);
+                    }
+                    0x0: decode REX_W {
+                        0x1: VPTERNLOGQ(Vo, Wo, Ib);
+                        0x0: VPTERNLOGD(Vo, Wo, Ib);
+                    }
+                }
+                0x39: decode EVEX_L_EXTEND {
+                    0x2: decode REX_W {
+                        0x1: decode IMMEDIATE {
+                            0x0: VEXTRACT128L(Wo, VYdo, Ib);
+                            0x1: VEXTRACT128H(Wo, VYdo, Ib);
+                            0x2: VEXTRACT128HL(Wo, VZqo, Ib);
+                            0x3: VEXTRACT128HH(Wo, VZqo, Ib);
+                        }
+                        0x0: decode IMMEDIATE {
+                            0x0: VEXTRACT128L(Wo, VYdo, Ib);
+                            0x1: VEXTRACT128H(Wo, VYdo, Ib);
+                            0x2: VEXTRACT128HL(Wo, VZqo, Ib);
+                            0x3: VEXTRACT128HH(Wo, VZqo, Ib);
+                        }
+                    }
+                }
+                0x3A: decode EVEX_L_EXTEND {
+                    0x2: decode IMMEDIATE {
+                        0x0: VINSERT256L(VZqo, WYdo, Ib);
+                        0x1: VINSERT256H(VZqo, WYdo, Ib);
+                    }
+                }
+                0x3B: decode EVEX_L_EXTEND {
+                    0x2: decode IMMEDIATE {
+                        0x0: VEXTRACT256L(WYdo, VZqo, Ib);
+                        0x1: VEXTRACT256H(WYdo, VZqo, Ib);
+                    }
+                }
+            }
+        }
+    }
+}
diff --git a/src/arch/x86/isa/decoder/three_byte_0f3a_opcodes_vex.isa b/src/arch/x86/isa/decoder/three_byte_0f3a_opcodes_vex.isa
new file mode 100644
index 0000000000..c12b057291
--- /dev/null
+++ b/src/arch/x86/isa/decoder/three_byte_0f3a_opcodes_vex.isa
@@ -0,0 +1,82 @@
+// Copyright (c) 2008 The Regents of The University of Michigan
+// All rights reserved.
+//
+// Redistribution and use in source and binary forms, with or without
+// modification, are permitted provided that the following conditions are
+// met: redistributions of source code must retain the above copyright
+// notice, this list of conditions and the following disclaimer;
+// redistributions in binary form must reproduce the above copyright
+// notice, this list of conditions and the following disclaimer in the
+// documentation and/or other materials provided with the distribution;
+// neither the name of the copyright holders nor the names of its
+// contributors may be used to endorse or promote products derived from
+// this software without specific prior written permission.
+//
+// THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS
+// "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT
+// LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR
+// A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT
+// OWNER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,
+// SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT
+// LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,
+// DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY
+// THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
+// (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE
+// OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
+//
+// Authors: Gabe Black
+
+////////////////////////////////////////////////////////////////////
+//
+// Decode the three byte opcodes with the 0f3a prefix.
+//
+'X86ISA::ThreeByte0F3AOpcode': decode LEGACY_OP {
+    1: decode LEGACY_DECODEVAL {
+        format Inst {
+            // 0x66
+            0x1: decode OPCODE_OP {
+                0x04: decode EVEX_L {
+                    0x1: VPERMILPS(VYdo, WYdo, Ib);
+                    0x0: VPERMILPS(Vo, Wo, Ib);
+                }
+                0x05: decode EVEX_L {
+                    0x1: VPERMILPD(VYdo, WYdo, Ib);
+                    0x0: VPERMILPD(Vo, Wo, Ib);
+                }
+                0x0C: decode EVEX_L {
+                    0x1: VBLENDPS(VYdo, WYdo, Ib);
+                    0x0: VBLENDPS(Vo, Wo, Ib);
+                }
+                0x16: decode EVEX_L {
+                    0x0: decode REX_W {
+                        0x1: decode IMMEDIATE {
+                            0x0: VPEXTRQL(Eq, Vo, Ib);
+                            0x1: VPEXTRQH(Eq, Vo, Ib);
+                        }
+                    }
+                }
+                0x18: decode EVEX_L {
+                    0x1: decode IMMEDIATE {
+                        0x0: VINSERT128L(VYdo, Wo, Ib);
+                        0x1: VINSERT128H(VYdo, Wo, Ib);
+                    }
+                }
+                0x19: decode EVEX_L {
+                    0x1: decode IMMEDIATE {
+                        0x0: VEXTRACT128L(Wo, VYdo, Ib);
+                        0x1: VEXTRACT128H(Wo, VYdo, Ib);
+                    }
+                }
+                0x21: decode EVEX_L {
+                    0x0: VINSERTPS(Vo, Wo, Ib);
+                }
+                0x39: decode EVEX_L {
+                    0x1: decode IMMEDIATE {
+                        0x0: VEXTRACT128L(Wo, VYdo, Ib);
+                        0x1: VEXTRACT128H(Wo, VYdo, Ib);
+                    }
+                }
+            }
+        }
+    }
+}
diff --git a/src/arch/x86/isa/decoder/two_byte_opcodes_evex.isa b/src/arch/x86/isa/decoder/two_byte_opcodes_evex.isa
new file mode 100644
index 0000000000..bdc8bdef69
--- /dev/null
+++ b/src/arch/x86/isa/decoder/two_byte_opcodes_evex.isa
@@ -0,0 +1,277 @@
+
+'X86ISA::TwoByteOpcode': decode OPCODE_OP_TOP5 {
+    format Inst{
+        0x02: decode LEGACY_DECODEVAL {
+            // no prefix, packed single.
+            0x0: decode OPCODE_OP_BOTTOM3 {
+                0x0: decode EVEX_L_EXTEND {
+                    0x2: VMOVUPS(VZqo, WZqo);
+                    0x1: VMOVUPS(VYdo, WYdo);
+                    0x0: VMOVUPS(Vo, Wo);
+                }
+                0x1: decode EVEX_L_EXTEND {
+                    0x2: VMOVUPS(WZqo, VZqo);
+                    0x1: VMOVUPS(WYdo, VYdo);
+                    0x0: VMOVUPS(Wo, Vo);
+                }
+            }
+            // 66, packed double.
+            0x1: decode OPCODE_OP_BOTTOM3 {
+                0x0: decode EVEX_L_EXTEND {
+                    0x2: VMOVUPD(VZqo, WZqo);
+                    0x1: VMOVUPD(VYdo, WYdo);
+                    0x0: VMOVUPD(Vo, Wo);
+                }
+                0x1: decode EVEX_L_EXTEND {
+                    0x2: VMOVUPD(WZqo, VZqo);
+                    0x1: VMOVUPD(WYdo, VYdo);
+                    0x0: VMOVUPD(Wo, Vo);
+                }
+                0x6: decode EVEX_L_EXTEND {
+                    0x0: VMOVHPD(Vo, Mq);
+                }
+            }
+            // 0xF3, scalar single.
+            0x4: decode OPCODE_OP_BOTTOM3 {
+                0x0: decode EVEX_L_EXTEND {
+                    0x0: VMOVSS(VZqo, WZqo);
+                }
+            }
+            // 0xF2, scalar double.
+            0x8: decode OPCODE_OP_BOTTOM3 {
+                0x0: decode EVEX_L_EXTEND {
+                    0x0: VMOVSD(Vq, Wq);
+                }
+                0x2: decode EVEX_L_EXTEND {
+                    0x2: VMOVDDUP(VZqo, WZqo);
+                    0x1: VMOVDDUP(VYdo, WYdo);
+                    0x0: VMOVDDUP(Vo, Wo);
+                }
+            }
+        }
+        0x05: decode LEGACY_DECODEVAL {
+            // no prefix
+            0x0: decode OPCODE_OP_BOTTOM3 {
+                0x0: decode EVEX_L_EXTEND {
+                    0x2: VMOVAPS(VZqo, WZqo);
+                    0x1: VMOVAPS(VYdo, WYdo);
+                    0x0: VMOVAPS(Vo, Wo);
+                }
+                0x1: decode EVEX_L_EXTEND {
+                    0x2: VMOVAPS(WZqo, VZqo);
+                    0x1: VMOVAPS(WYdo, VYdo);
+                    0x0: VMOVAPS(Wo, Vo);
+                }
+            }
+            // 66 packed double
+            0x1: decode OPCODE_OP_BOTTOM3 {
+                0x0: decode EVEX_L_EXTEND {
+                    0x2: VMOVAPD(VZqo, WZqo);
+                    0x1: VMOVAPD(VYdo, WYdo);
+                    0x0: VMOVAPD(Vo, Wo);
+                }
+                0x1: decode EVEX_L_EXTEND {
+                    0x2: VMOVAPD(WZqo, VZqo);
+                    0x1: VMOVAPD(WYdo, VYdo);
+                    0x0: VMOVAPD(Wo, Vo);
+                }
+            }
+            // 0xF3.
+            0x4: decode OPCODE_OP_BOTTOM3 {
+                0x2: decode EVEX_L_EXTEND {
+                    0x0: VCVTSI2SS(Vo, Ed);
+                }
+                0x4: decode EVEX_L_EXTEND {
+                    0x0: VCVTTSS2SI(Gd, Wd);
+                }
+            }
+            // 0xF2 scalar double.
+            0x8: decode OPCODE_OP_BOTTOM3 {
+                0x2: decode EVEX_L_EXTEND {
+                    0x0: VCVTSI2SD(Vo, Edp);
+                }
+            }
+        }
+        0x0B: decode LEGACY_DECODEVAL {
+            // packed single
+            0x0: decode OPCODE_OP_BOTTOM3 {
+                0x0: decode EVEX_L_EXTEND {
+                    0x2: VADDPS(VZqo, WZqo);
+                    0x1: VADDPS(VYdo, WYdo);
+                    0x0: VADDPS(Vo, Wo);
+                }
+                0x1: decode EVEX_L_EXTEND {
+                    0x2: VMULPS(VZqo, WZqo);
+                    0x1: VMULPS(VYdo, WYdo);
+                    0x0: VMULPS(Vo, Wo);
+                }
+                0x2: decode EVEX_L_EXTEND {
+                    0x2: VCVTPS2PD(VZqo, WYdo);
+                    0x1: VCVTPS2PD(VYdo, Wo);
+                    0x0: VCVTPS2PD(Vo, Wq);
+                }
+                0x3: decode EVEX_L_EXTEND {
+                    0x2: VCVTDQ2PS(VZqo, WZqo);
+                    0x1: VCVTDQ2PS(VYdo, WYdo);
+                    0x0: VCVTDQ2PS(Vo, Wo);
+                }
+                0x4: decode EVEX_L_EXTEND {
+                    0x2: VSUBPS(VZqo, WZqo);
+                    0x1: VSUBPS(VYdo, WYdo);
+                    0x0: VSUBPS(Vo, Wo);
+                }
+                0x6: decode EVEX_L_EXTEND {
+                    0x2: VDIVPS(VZqo, WZqo);
+                    0x1: VDIVPS(VYdo, WYdo);
+                    0x0: VDIVPS(Vo, Wo);
+                }
+            }
+            // 66, packed double
+            0x1: decode OPCODE_OP_BOTTOM3 {
+                0x0: decode EVEX_L_EXTEND {
+                    0x2: VADDPD(VZqo, WZqo);
+                    0x1: VADDPD(VYdo, WYdo);
+                    0x0: VADDPD(Vo, Wo);
+                }
+                0x1: decode EVEX_L_EXTEND {
+                    0x2: VMULPD(VZqo, WZqo);
+                    0x1: VMULPD(VYdo, WYdo);
+                    0x0: VMULPD(Vo, Wo);
+                }
+                0x2: decode EVEX_L_EXTEND {
+                    0x2: VCVTPD2PS512(VYdo, WZqo);
+                    0x1: VCVTPD2PS256(Vo, WYdo);
+                    0x0: VCVTPD2PS128(Vo, Wo);
+                }
+                0x4: decode EVEX_L_EXTEND {
+                    0x2: VSUBPD(VZqo, WZqo);
+                    0x1: VSUBPD(VYdo, WYdo);
+                    0x0: VSUBPD(Vo, Wo);
+                }
+                0x6: decode EVEX_L_EXTEND {
+                    0x2: VDIVPD(VZqo, WZqo);
+                    0x1: VDIVPD(VYdo, WYdo);
+                    0x0: VDIVPD(Vo, Wo);
+                }
+            }
+            // F3, scalar single
+            0x4: decode OPCODE_OP_BOTTOM3 {
+                0x0: decode EVEX_L_EXTEND {
+                    0x0: VADDSS(Vo, Wo);
+                }
+                0x1: decode EVEX_L_EXTEND {
+                    0x0: VMULSS(Vo, Wo);
+                }
+                0x2: decode EVEX_L_EXTEND {
+                    0x0: VCVTSS2SD(Vo, Wo);
+                }
+                0x4: decode EVEX_L_EXTEND {
+                    0x0: VSUBSS(Vo, Wo);
+                }
+                0x6: decode EVEX_L_EXTEND {
+                    0x0: VDIVSS(Vo, Wo);
+                }
+            }
+            // 0xF2 scalar double
+            0x8: decode OPCODE_OP_BOTTOM3 {
+                0x0: decode EVEX_L_EXTEND {
+                    0x0: VADDSD(Vo, Wo);
+                }
+                0x1: decode EVEX_L_EXTEND {
+                    0x0: VMULSD(Vo, Wo);
+                }
+                0x2: decode EVEX_L_EXTEND {
+                    0x0: VCVTSD2SS(Vo, Wo);
+                }
+                0x4: decode EVEX_L_EXTEND {
+                    0x0: VSUBSD(Vo, Wo);
+                }
+                0x6: decode EVEX_L_EXTEND {
+                    0x0: VDIVSD(Vo, Wo);
+                }
+            }
+        }
+        0x0D: decode LEGACY_DECODEVAL {
+            // no prefix
+            0x0: UD2();
+            // repe (0xF3)
+            0x4: decode OPCODE_OP_BOTTOM3 {
+                0x7: decode EVEX_L_EXTEND {
+                    0x2: VMOVDQU(VZqo, WZqo);
+                    0x1: VMOVDQU(VYdo, WYdo);
+                    0x0: VMOVDQU(Vq, Wq);
+                }
+            }
+            // operand size (0x66)
+            0x1: decode OPCODE_OP_BOTTOM3 {
+                0x7: decode EVEX_L_EXTEND {
+                    0x2: VMOVDQA(VZqo, WZqo);
+                    0x1: VMOVDQA(VYdo, WYdo);
+                    0x0: VMOVDQA(Vo, Wo);
+                }
+            }
+        }
+        0x0F: decode LEGACY_DECODEVAL {
+            0x0: UD2();
+            0x4: decode OPCODE_OP_BOTTOM3 {
+                0x3: decode EVEX_L_EXTEND {
+                    0x0: VCVTUSI2SS(Vo, Ed);
+                }
+                0x7: decode EVEX_L_EXTEND {
+                    0x2: VMOVDQU(WZqo, VZqo);
+                    0x1: VMOVDQU(WYdo, VYdo);
+                    0x0: VMOVDQU(Wo, Vo);
+                }
+            }
+            0x1: decode OPCODE_OP_BOTTOM3 {
+                0x7: decode EVEX_L_EXTEND {
+                    0x2: VMOVDQA(WZqo, VZqo);
+                    0x1: VMOVDQA(WYdo, VYdo);
+                    0x0: VMOVDQA(Wo, Vo);
+                }
+            }
+        }
+        0x1A: decode LEGACY_DECODEVAL {
+            // operand size (0x66)
+            0x1: decode OPCODE_OP_BOTTOM3 {
+                0x4: decode EVEX_L_EXTEND {
+                    0x2: VPADDQ(VZqo, WZqo);
+                }
+                0x6: decode EVEX_L_EXTEND {
+                    0x0: VMOVQ(Wq, Vq);
+                }
+            }
+        }
+        0x1B: decode LEGACY_DECODEVAL {
+            // operand size (0x66)
+            0x1: decode OPCODE_OP_BOTTOM3 {
+                0x3: decode EVEX_L_EXTEND {
+                    0x2: VPANDD(VZqo, WZqo);
+                    0x1: VPANDD(VYdo, WYdo);
+                    0x0: VPANDD(Vo, Wo);
+                }
+            }
+        }
+        0x1C: decode LEGACY_DECODEVAL {
+            // 0xF3
+            0x4: decode OPCODE_OP_BOTTOM3 {
+                0x6: decode EVEX_L_EXTEND {
+                    0x2: VCVTDQ2PD(VZqo, WYdo);
+                    0x1: VCVTDQ2PD(VYdo, Wo);
+                    0x0: VCVTDQ2PD(Vo, Wq);
+                }
+            }
+        }
+        0x1F: decode LEGACY_DECODEVAL {
+            // operand size (0x66)
+            0x1: decode OPCODE_OP_BOTTOM3 {
+                0x3: decode EVEX_L_EXTEND {
+                    0x2: VPSUBQ(VZqo, WZqo);
+                }
+                0x6: decode EVEX_L_EXTEND {
+                    0x2: VPADDD(VZqo, WZqo);
+                }
+            }
+        }
+    }
+}
\ No newline at end of file
diff --git a/src/arch/x86/isa/decoder/two_byte_opcodes_vex.isa b/src/arch/x86/isa/decoder/two_byte_opcodes_vex.isa
new file mode 100644
index 0000000000..fcafbae6da
--- /dev/null
+++ b/src/arch/x86/isa/decoder/two_byte_opcodes_vex.isa
@@ -0,0 +1,323 @@
+
+'X86ISA::TwoByteOpcode': decode OPCODE_OP_TOP5 {
+    format Inst{
+        0x02: decode LEGACY_DECODEVAL {
+            0x0: decode OPCODE_OP_BOTTOM3 {
+                0x0: decode EVEX_L {
+                    0x1: VMOVUPS(VYdo, WYdo);
+                    0x0: VMOVUPS(Vo, Wo);
+                }
+                0x1: decode EVEX_L {
+                    0x1: VMOVUPS(WYdo, VYdo);
+                    0x0: VMOVUPS(Wo, Vo);
+                }
+                0x4: decode EVEX_L {
+                    0x1: VUNPCKLPS(VYdo, WYdo);
+                    0x0: VUNPCKLPS(Vo, Wo);
+                }
+                0x5: decode EVEX_L {
+                    0x1: VUNPCKHPS(VYdo, WYdo);
+                    0x0: VUNPCKHPS(Vo, Wo);
+                }
+                0x6: decode MODRM_MOD {
+                    0x3: decode EVEX_L {
+                        0x0: VMOVLHPS(Vo,VRq);
+                    }
+                }
+            }
+            // 0x66, packed double
+            0x1: decode OPCODE_OP_BOTTOM3 {
+                0x0: decode EVEX_L {
+                    0x1: VMOVUPD(VYdo, WYdo);
+                    0x0: VMOVUPD(Vo, Wo);
+                }
+                0x1: decode EVEX_L {
+                    0x1: VMOVUPD(WYdo, VYdo);
+                    0x0: VMOVUPD(Wo, Vo);
+                }
+                0x6: decode EVEX_L {
+                    0x0: VMOVHPD(Vo, Mq);
+                }
+            }
+            // 0xF3
+            0x4: decode OPCODE_OP_BOTTOM3 {
+                0x0: decode EVEX_L {
+                    0x0: VMOVSS(Vo, Wo);
+                }
+                0x1: decode EVEX_L {
+                    0x0: VMOVSS(Wo, Vo);
+                }
+                0x2: decode EVEX_L {
+                    0x1: VMOVSLDUP(VYdo, WYdo);
+                    0x0: VMOVSLDUP(Vo, Wo);
+                }
+                0x6: decode EVEX_L {
+                    0x1: VMOVSHDUP(VYdo, WYdo);
+                    0x0: VMOVSHDUP(Vo, Wo);
+                }
+            }
+            // 0xF2 scalar double
+            0x8: decode OPCODE_OP_BOTTOM3 {
+                0x0: decode EVEX_L {
+                    0x0: VMOVSD(Vq, Wq);
+                }
+                0x1: decode EVEX_L {
+                    0x0: VMOVSD(Wd, Vd);
+                }
+                0x2: decode EVEX_L {
+                    0x1: VMOVDDUP(VYdo, WYdo);
+                    0x0: VMOVDDUP(Vo, Wo);
+                }
+            }
+        }
+        0x05: decode LEGACY_DECODEVAL {
+            0x0: decode OPCODE_OP_BOTTOM3 {
+                0x0: decode EVEX_L {
+                    0x1: VMOVAPS(VYdo, WYdo);
+                    0x0: VMOVAPS(Vq, Wq);
+                }
+                0x1: decode EVEX_L {
+                    0x1: VMOVAPS(WYdo, VYdo);
+                    0x0: VMOVAPS(Wq, Vq);
+                }
+                0x7: decode EVEX_L {
+                    0x0: VCOMISS(Vo, Wo);
+                }
+            }
+            // 0x66 packed double
+            0x1: decode OPCODE_OP_BOTTOM3 {
+                0x0: decode EVEX_L {
+                    0x1: VMOVAPD(VYdo, WYdo);
+                    0x0: VMOVAPD(Vq, Wq);
+                }
+                0x1: decode EVEX_L {
+                    0x1: VMOVAPD(WYdo, VYdo);
+                    0x0: VMOVAPD(Wq, Vq);
+                }
+            }
+            // 0xF3.
+            0x4: decode OPCODE_OP_BOTTOM3 {
+                0x2: decode EVEX_L {
+                    0x0: VCVTSI2SS(Vo, Ed);
+                }
+                0x4: decode EVEX_L {
+                    0x0: VCVTTSS2SI(Gd, Wd);
+                }
+            }
+            // 0xF2 scalar double.
+            0x8: decode OPCODE_OP_BOTTOM3 {
+                0x2: decode EVEX_L {
+                    0x0: VCVTSI2SD(Vo, Edp);
+                }
+            }
+        }
+        0x0A: decode LEGACY_DECODEVAL {
+            0x0: decode OPCODE_OP_BOTTOM3 {
+                0x4: decode EVEX_L {
+                    0x1: VANDPS(VYdo,WYdo);
+                    0x0: VANDPS(Vo,Wo);
+                }
+                0x7: decode EVEX_L {
+                    0x1: VXORPS(VYdo,WYdo);
+                    0x0: VXORPS(Vo,Wo);
+                }
+            }
+            0x1: decode OPCODE_OP_BOTTOM3 {
+                0x7: decode EVEX_L {
+                    0x1: VXORPD(VYdo,WYdo);
+                    0x0: VXORPD(Vo,Wo);
+                }
+            }
+        }
+        0x0B: decode LEGACY_DECODEVAL {
+            0x0: decode OPCODE_OP_BOTTOM3 {
+                0x0: decode EVEX_L {
+                    0x1: VADDPS(VYdo, WYdo);
+                    0x0: VADDPS(Vo, Wo);
+                }
+                0x2: decode EVEX_L {
+                    0x1: VCVTPS2PD(VYdo, Wo);
+                    0x0: VCVTPS2PD(Vo, Wq);
+                }
+                0x3: decode EVEX_L {
+                    0x1: VCVTDQ2PS(VYdo, WYdo);
+                    0x0: VCVTDQ2PS(Vo, Wo);
+                }
+                0x4: decode EVEX_L {
+                    0x1: VSUBPS(VYdo, WYdo);
+                    0x0: VSUBPS(Vo, Wo);
+                }
+                0x6: decode EVEX_L {
+                    0x1: VDIVPS(VYdo, WYdo);
+                    0x0: VDIVPS(Vo, Wo);
+                }
+            }
+            // 0x66 packed double
+            0x1: decode OPCODE_OP_BOTTOM3 {
+                0x0: decode EVEX_L {
+                    0x1: VADDPD(VYdo, WYdo);
+                    0x0: VADDPD(Vo, Wo);
+                }
+                0x1: decode EVEX_L {
+                    0x1: VMULPD(VYdo, WYdo);
+                    0x0: VMULPD(Vo, Wo);
+                }
+                0x2: decode EVEX_L {
+                    0x1: VCVTPD2PS256(Vo, WYdo);
+                    0x0: VCVTPD2PS128(Vq, Wo);
+                }
+                0x4: decode EVEX_L {
+                    0x1: VSUBPD(VYdo, WYdo);
+                    0x0: VSUBPD(Vo, Wo);
+                }
+                0x6: decode EVEX_L {
+                    0x1: VDIVPD(VYdo, WYdo);
+                    0x0: VDIVPD(Vo, Wo);
+                }
+            }
+            // 0xF3 scalar single
+            0x4: decode OPCODE_OP_BOTTOM3 {
+                0x0: decode EVEX_L {
+                    0x0: VADDSS(Vo, Wo);
+                }
+                0x1: decode EVEX_L {
+                    0x0: VMULSS(Vo, Wo);
+                }
+                0x2: decode EVEX_L {
+                    0x0: VCVTSS2SD(Vo, Wo);
+                }
+                0x4: decode EVEX_L {
+                    0x0: VSUBSS(Vo, Wo);
+                }
+                0x6: decode EVEX_L {
+                    0x0: VDIVSS(Vo, Wo);
+                }
+            }
+            // 0xF2 scalar double
+            0x8: decode OPCODE_OP_BOTTOM3 {
+                0x0: decode EVEX_L {
+                    0x0: VADDSD(Vo, Wo);
+                }
+                0x1: decode EVEX_L {
+                    0x0: VMULSD(Vo, Wo);
+                }
+                0x2: decode EVEX_L {
+                    0x0: VCVTSD2SS(Vo, Wo);
+                }
+                0x4: decode EVEX_L {
+                    0x0: VSUBSD(Vo, Wo);
+                }
+                0x6: decode EVEX_L {
+                    0x0: VDIVSD(Vo, Wo);
+                }
+            }
+        }
+        0x0D: decode LEGACY_DECODEVAL {
+            0x1: decode OPCODE_OP_BOTTOM3 {
+                0x6: decode EVEX_L {
+                    0x0: VMOVD(Vo, Edp);
+                }
+                0x7: decode EVEX_L {
+                    0x1: VMOVDQA(VYdo, WYdo);
+                    0x0: MOVDQA(Vo, Wo);
+                }
+            }
+            0x4: decode OPCODE_OP_BOTTOM3 {
+                0x7: decode EVEX_L {
+                    0x1: VMOVDQU(VYdo, WYdo);
+                    0x0: MOVDQU(Vq, Wq);
+                }
+            }
+        }
+        0x0E: decode LEGACY_DECODEVAL {
+            0x0: decode OPCODE_OP_BOTTOM3 {
+                0x7: VZEROUPPER();
+            }
+            0x1: decode OPCODE_OP_BOTTOM3 {
+                0x0: decode EVEX_L {
+                    0x1: VPSHUFD(VYdo, WYdo, Ib);
+                    0x0: VPSHUFD(Vo, Wo, Ib);
+                }
+            }
+        }
+        0x0F: decode LEGACY_DECODEVAL {
+            0x1: decode OPCODE_OP_BOTTOM3 {
+                0x6: decode EVEX_L {
+                    0x0: MOVD(Edp, Vd);
+                }
+                0x7: decode EVEX_L {
+                    0x1: VMOVDQA(WYdo, VYdo);
+                    0x0: MOVDQA(Wo, Vo);
+                }
+                default: UD2();
+            }
+            0x4: decode OPCODE_OP_BOTTOM3 {
+                0x6: decode EVEX_L {
+                    0x0: MOVQ(Vq, Wq);
+                }
+                0x7: decode EVEX_L {
+                    0x1: VMOVDQU(WYdo, VYdo);
+                    0x0: MOVDQU(Wo, Vo);
+                }
+            }
+        }
+        0x15: decode OPCODE_OP_BOTTOM3 {
+            0x6: decode MODRM_MOD {
+                0x3: UD2();
+                default: decode MODRM_REG {
+                    0x3: decode EVEX_L {
+                        0x0: STMXCSR(Md);
+                    }
+                }
+            }
+        }
+        0x18: decode OPCODE_OP_BOTTOM3 {
+            0x6: decode EVEX_L {
+                0x1: VSHUFPS(VYdo, WYdo, Ib);
+                0x0: VSHUFPS(Vo, Wo, Ib);
+            }
+        }
+        0x1A: decode LEGACY_DECODEVAL {
+            0x0: decode OPCODE_OP_BOTTOM3 {
+                default: UD2();
+            }
+            0x4: decode OPCODE_OP_BOTTOM3 {
+                default: UD2();
+            }
+            0x1: decode OPCODE_OP_BOTTOM3 {
+                0x4: decode EVEX_L {
+                    0x1: VPADDQ(VYdo, WYdo);
+                    0x0: VPADDQ(Vo,Wo);
+                }
+                0x6: decode EVEX_L {
+                    0x0: VMOVQ(Wq, Vq);
+                }
+            }
+        }
+        0x1C: decode LEGACY_DECODEVAL {
+            // 0xF3
+            0x4: decode OPCODE_OP_BOTTOM3 {
+                0x6: decode EVEX_L {
+                    0x1: VCVTDQ2PD(VYdo, Wo);
+                    0x0: VCVTDQ2PD(Vo, Wq);
+                }
+            }
+        }
+        0x1D: decode LEGACY_DECODEVAL {
+            0x1: decode OPCODE_OP_BOTTOM3 {
+                0x7: decode EVEX_L {
+                    0x1: VPXOR(VYdo, WYdo);
+                    0x0: VPXOR(Vo, Wo);
+                }
+            }
+        }
+        0x1F: decode LEGACY_DECODEVAL {
+            0x1: decode OPCODE_OP_BOTTOM3 {
+                0x6: decode EVEX_L {
+                    0x1: VPADDD(VYdo, WYdo);
+                    0x0: VPADDD(Vo, Wo);
+                }
+            }
+        }
+    }
+}
diff --git a/src/arch/x86/isa/includes.isa b/src/arch/x86/isa/includes.isa
index d2098c3e92..c373ab3890 100644
--- a/src/arch/x86/isa/includes.isa
+++ b/src/arch/x86/isa/includes.isa
@@ -57,6 +57,7 @@ output header {{
 #include "arch/x86/insts/microfpop.hh"
 #include "arch/x86/insts/microldstop.hh"
 #include "arch/x86/insts/micromediaop.hh"
+#include "arch/x86/insts/microavxop.hh"
 #include "arch/x86/insts/microregop.hh"
 #include "arch/x86/insts/static_inst.hh"
 #include "arch/x86/emulenv.hh"
@@ -119,6 +120,7 @@ output exec {{
 #include "cpu/base.hh"
 #include "cpu/exetrace.hh"
 #include "debug/X86.hh"
+#include "debug/X86MediaMicroop.hh"
 #include "mem/packet.hh"
 #include "mem/packet_access.hh"
 #include "mem/request.hh"
diff --git a/src/arch/x86/isa/insts/__init__.py b/src/arch/x86/isa/insts/__init__.py
index 918951c95e..3aef534f66 100644
--- a/src/arch/x86/isa/insts/__init__.py
+++ b/src/arch/x86/isa/insts/__init__.py
@@ -35,6 +35,7 @@
 
 categories = ["romutil",
               "general_purpose",
+              "simd512",
               "simd128",
               "simd64",
               "system",
diff --git a/src/arch/x86/isa/insts/simd128/integer/logical/exclusive_or.py b/src/arch/x86/isa/insts/simd128/integer/logical/exclusive_or.py
index f5279497ad..3d3141896d 100644
--- a/src/arch/x86/isa/insts/simd128/integer/logical/exclusive_or.py
+++ b/src/arch/x86/isa/insts/simd128/integer/logical/exclusive_or.py
@@ -37,6 +37,12 @@ microcode = '''
 def macroop PXOR_XMM_XMM {
     mxor xmml, xmml, xmmlm
     mxor xmmh, xmmh, xmmhm
+    mxor xmm2, xmm2, xmm2
+    mxor xmm3, xmm3, xmm3
+    mxor xmm4, xmm4, xmm4
+    mxor xmm5, xmm5, xmm5
+    mxor xmm6, xmm6, xmm6
+    mxor xmm7, xmm7, xmm7
 };
 
 def macroop PXOR_XMM_M {
@@ -45,6 +51,12 @@ def macroop PXOR_XMM_M {
     ldfp ufp2, seg, [1, t0, t1], 8, dataSize=8
     mxor xmml, xmml, ufp1
     mxor xmmh, xmmh, ufp2
+    mxor xmm2, xmm2, xmm2
+    mxor xmm3, xmm3, xmm3
+    mxor xmm4, xmm4, xmm4
+    mxor xmm5, xmm5, xmm5
+    mxor xmm6, xmm6, xmm6
+    mxor xmm7, xmm7, xmm7
 };
 
 def macroop PXOR_XMM_P {
@@ -54,5 +66,11 @@ def macroop PXOR_XMM_P {
     ldfp ufp2, seg, [1, t0, t1], 8, dataSize=8
     mxor xmml, xmml, ufp1
     mxor xmmh, xmmh, ufp2
+    mxor xmm2, xmm2, xmm2
+    mxor xmm3, xmm3, xmm3
+    mxor xmm4, xmm4, xmm4
+    mxor xmm5, xmm5, xmm5
+    mxor xmm6, xmm6, xmm6
+    mxor xmm7, xmm7, xmm7
 };
 '''
diff --git a/src/arch/x86/isa/insts/simd512/__init__.py b/src/arch/x86/isa/insts/simd512/__init__.py
new file mode 100644
index 0000000000..e0fa32a4ff
--- /dev/null
+++ b/src/arch/x86/isa/insts/simd512/__init__.py
@@ -0,0 +1,12 @@
+
+categories = [
+    "floating_point",
+    "integer",
+]
+
+microcode = '''
+# AVX512 instructions
+'''
+for category in categories:
+    exec("from . import {s} as cat".format(s=category))
+    microcode += cat.microcode
diff --git a/src/arch/x86/isa/insts/simd512/floating_point/__init__.py b/src/arch/x86/isa/insts/simd512/floating_point/__init__.py
new file mode 100644
index 0000000000..05556becb1
--- /dev/null
+++ b/src/arch/x86/isa/insts/simd512/floating_point/__init__.py
@@ -0,0 +1,13 @@
+
+categories = [
+    "arithmetic",
+    "data_conversion",
+    "data_transfer",
+]
+
+microcode = '''
+# AVX512 instructions
+'''
+for category in categories:
+    exec("from . import {s} as cat".format(s=category))
+    microcode += cat.microcode
diff --git a/src/arch/x86/isa/insts/simd512/floating_point/arithmetic/__init__.py b/src/arch/x86/isa/insts/simd512/floating_point/arithmetic/__init__.py
new file mode 100644
index 0000000000..d08c33cd24
--- /dev/null
+++ b/src/arch/x86/isa/insts/simd512/floating_point/arithmetic/__init__.py
@@ -0,0 +1,30 @@
+categories = [
+    "vaddss",
+    "vaddsd",
+    "vaddps",
+    "vaddpd",
+    "vandps",
+    "vfmadd231ps",
+    "vsubss",
+    "vsubsd",
+    "vsubps",
+    "vsubpd",
+    "vmulps",
+    "vmulpd",
+    "vmulss",
+    "vmulsd",
+    "vdivss",
+    "vdivsd",
+    "vdivps",
+    "vdivpd",
+    "vxorps",
+    "vxorpd",
+    "vpxor",
+]
+
+microcode = '''
+# AVX512 instructions
+'''
+for category in categories:
+    exec("from . import {s} as cat".format(s=category))
+    microcode += cat.microcode
diff --git a/src/arch/x86/isa/insts/simd512/floating_point/arithmetic/vaddpd.py b/src/arch/x86/isa/insts/simd512/floating_point/arithmetic/vaddpd.py
new file mode 100644
index 0000000000..451c39f592
--- /dev/null
+++ b/src/arch/x86/isa/insts/simd512/floating_point/arithmetic/vaddpd.py
@@ -0,0 +1,54 @@
+
+microcode = '''
+def macroop VADDPD_XMM_XMM {
+    vaddf dest=xmm0, src1=xmm0v, src2=xmm0m, size=8, VL=16
+    vclear dest=xmm2, destVL=16
+};
+
+def macroop VADDPD_XMM_M {
+    ldfp128 ufp1, seg, sib, "DISPLACEMENT + 0", dataSize=16
+    vaddf dest=xmm0, src1=xmm0v, src2=ufp1, size=8, VL=16
+    vclear dest=xmm2, destVL=16
+};
+
+def macroop VADDPD_XMM_P {
+    rdip t7
+    ldfp128 ufp1, seg, riprel, "DISPLACEMENT + 0", dataSize=16
+    vaddf dest=xmm0, src1=xmm0v, src2=ufp1, size=8, VL=16
+    vclear dest=xmm2, destVL=16
+};
+
+def macroop VADDPD_YMM_YMM {
+    vaddf dest=xmm0, src1=xmm0v, src2=xmm0m, size=8, VL=32
+    vclear dest=xmm4, destVL=32
+};
+
+def macroop VADDPD_YMM_M {
+    ldfp256 ufp1, seg, sib, "DISPLACEMENT + 0", dataSize=32
+    vaddf dest=xmm0, src1=xmm0v, src2=ufp1, size=8, VL=32
+    vclear dest=xmm4, destVL=32
+};
+
+def macroop VADDPD_YMM_P {
+    rdip t7
+    ldfp256 ufp1, seg, riprel, "DISPLACEMENT + 0", dataSize=32
+    vaddf dest=xmm0, src1=xmm0v, src2=ufp1, size=8, VL=32
+    vclear dest=xmm4, destVL=32
+};
+
+def macroop VADDPD_ZMM_ZMM {
+    vaddf dest=xmm0, src1=xmm0v, src2=xmm0m, size=8, VL=64
+};
+
+def macroop VADDPD_ZMM_M {
+    ldfp512 ufp1, seg, sib, "DISPLACEMENT + 0", dataSize=64
+    vaddf dest=xmm0, src1=xmm0v, src2=ufp1, size=8, VL=64
+};
+
+def macroop VADDPD_ZMM_P {
+    rdip t7
+    ldfp512 ufp1, seg, riprel, "DISPLACEMENT + 0", dataSize=64
+    vaddf dest=xmm0, src1=xmm0v, src2=ufp1, size=8, VL=64
+};
+
+'''
diff --git a/src/arch/x86/isa/insts/simd512/floating_point/arithmetic/vaddps.py b/src/arch/x86/isa/insts/simd512/floating_point/arithmetic/vaddps.py
new file mode 100644
index 0000000000..5ad03ac438
--- /dev/null
+++ b/src/arch/x86/isa/insts/simd512/floating_point/arithmetic/vaddps.py
@@ -0,0 +1,54 @@
+
+microcode = '''
+def macroop VADDPS_XMM_XMM {
+    vaddf dest=xmm0, src1=xmm0v, src2=xmm0m, size=4, VL=16
+    vclear dest=xmm2, destVL=16
+};
+
+def macroop VADDPS_XMM_M {
+    ldfp128 ufp1, seg, sib, "DISPLACEMENT + 0", dataSize=16
+    vaddf dest=xmm0, src1=xmm0v, src2=ufp1, size=4, VL=16
+    vclear dest=xmm2, destVL=16
+};
+
+def macroop VADDPS_XMM_P {
+    rdip t7
+    ldfp128 ufp1, seg, riprel, "DISPLACEMENT + 0", dataSize=16
+    vaddf dest=xmm0, src1=xmm0v, src2=ufp1, size=4, VL=16
+    vclear dest=xmm2, destVL=16
+};
+
+def macroop VADDPS_YMM_YMM {
+    vaddf dest=xmm0, src1=xmm0v, src2=xmm0m, size=4, VL=32
+    vclear dest=xmm4, destVL=32
+};
+
+def macroop VADDPS_YMM_M {
+    ldfp256 ufp1, seg, sib, "DISPLACEMENT + 0", dataSize=32
+    vaddf dest=xmm0, src1=xmm0v, src2=ufp1, size=4, VL=32
+    vclear dest=xmm4, destVL=32
+};
+
+def macroop VADDPS_YMM_P {
+    rdip t7
+    ldfp256 ufp1, seg, riprel, "DISPLACEMENT + 0", dataSize=32
+    vaddf dest=xmm0, src1=xmm0v, src2=ufp1, size=4, VL=32
+    vclear dest=xmm4, destVL=32
+};
+
+def macroop VADDPS_ZMM_ZMM {
+    vaddf dest=xmm0, src1=xmm0v, src2=xmm0m, size=4, VL=64
+};
+
+def macroop VADDPS_ZMM_M {
+    ldfp512 ufp1, seg, sib, "DISPLACEMENT + 0", dataSize=64
+    vaddf dest=xmm0, src1=xmm0v, src2=ufp1, size=4, VL=64
+};
+
+def macroop VADDPS_ZMM_P {
+    rdip t7
+    ldfp512 ufp1, seg, riprel, "DISPLACEMENT + 0", dataSize=64
+    vaddf dest=xmm0, src1=xmm0v, src2=ufp1, size=4, VL=64
+};
+
+'''
diff --git a/src/arch/x86/isa/insts/simd512/floating_point/arithmetic/vaddsd.py b/src/arch/x86/isa/insts/simd512/floating_point/arithmetic/vaddsd.py
new file mode 100644
index 0000000000..1a3c0fc07e
--- /dev/null
+++ b/src/arch/x86/isa/insts/simd512/floating_point/arithmetic/vaddsd.py
@@ -0,0 +1,24 @@
+
+microcode = '''
+def macroop VADDSD_XMM_XMM {
+    maddf xmm0, xmm0v, xmm0m, size=8, ext=Scalar
+    movfp dest=xmm1, src1=xmm1v, dataSize=8
+    vclear dest=xmm2, destVL=16
+};
+
+def macroop VADDSD_XMM_M {
+    ldfp ufp1, seg, sib, disp, dataSize=8
+    maddf xmm0, xmm0v, ufp1, size=8, ext=Scalar
+    movfp dest=xmm1, src1=xmm1v, dataSize=8
+    vclear dest=xmm2, destVL=16
+};
+
+def macroop VADDSD_XMM_P {
+    rdip t7
+    ldfp ufp1, seg, riprel, disp, dataSize=8
+    maddf xmm0, xmm0v, ufp1, size=8, ext=Scalar
+    movfp dest=xmm1, src1=xmm1v, dataSize=8
+    vclear dest=xmm2, destVL=16
+};
+
+'''
diff --git a/src/arch/x86/isa/insts/simd512/floating_point/arithmetic/vaddss.py b/src/arch/x86/isa/insts/simd512/floating_point/arithmetic/vaddss.py
new file mode 100644
index 0000000000..3772afbbe6
--- /dev/null
+++ b/src/arch/x86/isa/insts/simd512/floating_point/arithmetic/vaddss.py
@@ -0,0 +1,27 @@
+
+microcode = '''
+def macroop VADDSS_XMM_XMM {
+    maddf xmm0, xmm0v, xmm0m, size=4, ext=Scalar
+    movfph2h dest=xmm0, src1=xmm0v, dataSize=4
+    movfp dest=xmm1, src1=xmm1v, dataSize=8
+    vclear dest=xmm2, destVL=16
+};
+
+def macroop VADDSS_XMM_M {
+    movfp dest=xmm0, src1=xmm0v, dataSize=8
+    movfp dest=xmm1, src1=xmm1v, dataSize=8
+    ldfp ufp1, seg, sib, disp, dataSize=4
+    maddf xmm0, xmm0v, ufp1, size=4, ext=Scalar
+    vclear dest=xmm2, destVL=16
+};
+
+def macroop VADDSS_XMM_P {
+    movfp dest=xmm0, src1=xmm0v, dataSize=8
+    movfp dest=xmm1, src1=xmm1v, dataSize=8
+    rdip t7
+    ldfp ufp1, seg, riprel, disp, dataSize=4
+    maddf xmm0, xmm0v, ufp1, size=4, ext=Scalar
+    vclear dest=xmm2, destVL=16
+};
+
+'''
diff --git a/src/arch/x86/isa/insts/simd512/floating_point/arithmetic/vandps.py b/src/arch/x86/isa/insts/simd512/floating_point/arithmetic/vandps.py
new file mode 100644
index 0000000000..b4b1494beb
--- /dev/null
+++ b/src/arch/x86/isa/insts/simd512/floating_point/arithmetic/vandps.py
@@ -0,0 +1,54 @@
+
+microcode = '''
+def macroop VANDPS_XMM_XMM {
+    vandf dest=xmm0, src1=xmm0v, src2=xmm0m, size=4, VL=16
+    vclear dest=xmm2, destVL=16
+};
+
+def macroop VANDPS_XMM_M {
+    ldfp128 ufp1, seg, sib, "DISPLACEMENT + 0", dataSize=16
+    vandf dest=xmm0, src1=xmm0v, src2=ufp1, size=4, VL=16
+    vclear dest=xmm2, destVL=16
+};
+
+def macroop VANDPS_XMM_P {
+    rdip t7
+    ldfp128 ufp1, seg, riprel, "DISPLACEMENT + 0", dataSize=16
+    vandf dest=xmm0, src1=xmm0v, src2=ufp1, size=4, VL=16
+    vclear dest=xmm2, destVL=16
+};
+
+def macroop VANDPS_YMM_YMM {
+    vandf dest=xmm0, src1=xmm0v, src2=xmm0m, size=4, VL=32
+    vclear dest=xmm4, destVL=32
+};
+
+def macroop VANDPS_YMM_M {
+    ldfp256 ufp1, seg, sib, "DISPLACEMENT + 0", dataSize=32
+    vandf dest=xmm0, src1=xmm0v, src2=ufp1, size=4, VL=32
+    vclear dest=xmm4, destVL=32
+};
+
+def macroop VANDPS_YMM_P {
+    rdip t7
+    ldfp256 ufp1, seg, riprel, "DISPLACEMENT + 0", dataSize=32
+    vandf dest=xmm0, src1=xmm0v, src2=ufp1, size=4, VL=32
+    vclear dest=xmm4, destVL=32
+};
+
+def macroop VANDPS_ZMM_ZMM {
+    vandf dest=xmm0, src1=xmm0v, src2=xmm0m, size=4, VL=64
+};
+
+def macroop VANDPS_ZMM_M {
+    ldfp512 ufp1, seg, sib, "DISPLACEMENT + 0", dataSize=64
+    vandf dest=xmm0, src1=xmm0v, src2=ufp1, size=4, VL=64
+};
+
+def macroop VANDPS_ZMM_P {
+    rdip t7
+    ldfp512 ufp1, seg, riprel, "DISPLACEMENT + 0", dataSize=64
+    vandf dest=xmm0, src1=xmm0v, src2=ufp1, size=4, VL=64
+};
+
+'''
diff --git a/src/arch/x86/isa/insts/simd512/floating_point/arithmetic/vdivpd.py b/src/arch/x86/isa/insts/simd512/floating_point/arithmetic/vdivpd.py
new file mode 100644
index 0000000000..65abdb038c
--- /dev/null
+++ b/src/arch/x86/isa/insts/simd512/floating_point/arithmetic/vdivpd.py
@@ -0,0 +1,54 @@
+
+microcode = '''
+def macroop VDIVPD_XMM_XMM {
+    vdivf dest=xmm0, src1=xmm0v, src2=xmm0m, size=8, VL=16
+    vclear dest=xmm2, destVL=16
+};
+
+def macroop VDIVPD_XMM_M {
+    ldfp128 ufp1, seg, sib, "DISPLACEMENT + 0", dataSize=16
+    vdivf dest=xmm0, src1=xmm0v, src2=ufp1, size=8, VL=16
+    vclear dest=xmm2, destVL=16
+};
+
+def macroop VDIVPD_XMM_P {
+    rdip t7
+    ldfp128 ufp1, seg, riprel, "DISPLACEMENT + 0", dataSize=16
+    vdivf dest=xmm0, src1=xmm0v, src2=ufp1, size=8, VL=16
+    vclear dest=xmm2, destVL=16
+};
+
+def macroop VDIVPD_YMM_YMM {
+    vdivf dest=xmm0, src1=xmm0v, src2=xmm0m, size=8, VL=32
+    vclear dest=xmm4, destVL=32
+};
+
+def macroop VDIVPD_YMM_M {
+    ldfp256 ufp1, seg, sib, "DISPLACEMENT + 0", dataSize=32
+    vdivf dest=xmm0, src1=xmm0v, src2=ufp1, size=8, VL=32
+    vclear dest=xmm4, destVL=32
+};
+
+def macroop VDIVPD_YMM_P {
+    rdip t7
+    ldfp256 ufp1, seg, riprel, "DISPLACEMENT + 0", dataSize=32
+    vdivf dest=xmm0, src1=xmm0v, src2=ufp1, size=8, VL=32
+    vclear dest=xmm4, destVL=32
+};
+
+def macroop VDIVPD_ZMM_ZMM {
+    vdivf dest=xmm0, src1=xmm0v, src2=xmm0m, size=8, VL=64
+};
+
+def macroop VDIVPD_ZMM_M {
+    ldfp512 ufp1, seg, sib, "DISPLACEMENT + 0", dataSize=64
+    vdivf dest=xmm0, src1=xmm0v, src2=ufp1, size=8, VL=64
+};
+
+def macroop VDIVPD_ZMM_P {
+    rdip t7
+    ldfp512 ufp1, seg, riprel, "DISPLACEMENT + 0", dataSize=64
+    vdivf dest=xmm0, src1=xmm0v, src2=ufp1, size=8, VL=64
+};
+
+'''
diff --git a/src/arch/x86/isa/insts/simd512/floating_point/arithmetic/vdivps.py b/src/arch/x86/isa/insts/simd512/floating_point/arithmetic/vdivps.py
new file mode 100644
index 0000000000..70900e421a
--- /dev/null
+++ b/src/arch/x86/isa/insts/simd512/floating_point/arithmetic/vdivps.py
@@ -0,0 +1,54 @@
+
+microcode = '''
+def macroop VDIVPS_XMM_XMM {
+    vdivf dest=xmm0, src1=xmm0v, src2=xmm0m, size=4, VL=16
+    vclear dest=xmm2, destVL=16
+};
+
+def macroop VDIVPS_XMM_M {
+    ldfp128 ufp1, seg, sib, "DISPLACEMENT + 0", dataSize=16
+    vdivf dest=xmm0, src1=xmm0v, src2=ufp1, size=4, VL=16
+    vclear dest=xmm2, destVL=16
+};
+
+def macroop VDIVPS_XMM_P {
+    rdip t7
+    ldfp128 ufp1, seg, riprel, "DISPLACEMENT + 0", dataSize=16
+    vdivf dest=xmm0, src1=xmm0v, src2=ufp1, size=4, VL=16
+    vclear dest=xmm2, destVL=16
+};
+
+def macroop VDIVPS_YMM_YMM {
+    vdivf dest=xmm0, src1=xmm0v, src2=xmm0m, size=4, VL=32
+    vclear dest=xmm4, destVL=32
+};
+
+def macroop VDIVPS_YMM_M {
+    ldfp256 ufp1, seg, sib, "DISPLACEMENT + 0", dataSize=32
+    vdivf dest=xmm0, src1=xmm0v, src2=ufp1, size=4, VL=32
+    vclear dest=xmm4, destVL=32
+};
+
+def macroop VDIVPS_YMM_P {
+    rdip t7
+    ldfp256 ufp1, seg, riprel, "DISPLACEMENT + 0", dataSize=32
+    vdivf dest=xmm0, src1=xmm0v, src2=ufp1, size=4, VL=32
+    vclear dest=xmm4, destVL=32
+};
+
+def macroop VDIVPS_ZMM_ZMM {
+    vdivf dest=xmm0, src1=xmm0v, src2=xmm0m, size=4, VL=64
+};
+
+def macroop VDIVPS_ZMM_M {
+    ldfp512 ufp1, seg, sib, "DISPLACEMENT + 0", dataSize=64
+    vdivf dest=xmm0, src1=xmm0v, src2=ufp1, size=4, VL=64
+};
+
+def macroop VDIVPS_ZMM_P {
+    rdip t7
+    ldfp512 ufp1, seg, riprel, "DISPLACEMENT + 0", dataSize=64
+    vdivf dest=xmm0, src1=xmm0v, src2=ufp1, size=4, VL=64
+};
+
+'''
diff --git a/src/arch/x86/isa/insts/simd512/floating_point/arithmetic/vdivsd.py b/src/arch/x86/isa/insts/simd512/floating_point/arithmetic/vdivsd.py
new file mode 100644
index 0000000000..0c125f183c
--- /dev/null
+++ b/src/arch/x86/isa/insts/simd512/floating_point/arithmetic/vdivsd.py
@@ -0,0 +1,24 @@
+
+microcode = '''
+def macroop VDIVSD_XMM_XMM {
+    mdivf xmm0, xmm0v, xmm0m, size=8, ext=Scalar
+    movfp dest=xmm1, src1=xmm1v, dataSize=8
+    vclear dest=xmm2, destVL=16
+};
+
+def macroop VDIVSD_XMM_M {
+    ldfp ufp1, seg, sib, disp, dataSize=8
+    mdivf xmm0, xmm0v, ufp1, size=8, ext=Scalar
+    movfp dest=xmm1, src1=xmm1v, dataSize=8
+    vclear dest=xmm2, destVL=16
+};
+
+def macroop VDIVSD_XMM_P {
+    rdip t7
+    ldfp ufp1, seg, riprel, disp, dataSize=8
+    mdivf xmm0, xmm0v, ufp1, size=8, ext=Scalar
+    movfp dest=xmm1, src1=xmm1v, dataSize=8
+    vclear dest=xmm2, destVL=16
+};
+
+'''
diff --git a/src/arch/x86/isa/insts/simd512/floating_point/arithmetic/vdivss.py b/src/arch/x86/isa/insts/simd512/floating_point/arithmetic/vdivss.py
new file mode 100644
index 0000000000..3e093ced61
--- /dev/null
+++ b/src/arch/x86/isa/insts/simd512/floating_point/arithmetic/vdivss.py
@@ -0,0 +1,27 @@
+
+microcode = '''
+def macroop VDIVSS_XMM_XMM {
+    mdivf xmm0, xmm0v, xmm0m, size=4, ext=Scalar
+    movfph2h dest=xmm0, src1=xmm0v, dataSize=4
+    movfp dest=xmm1, src1=xmm1v, dataSize=8
+    vclear dest=xmm2, destVL=16
+};
+
+def macroop VDIVSS_XMM_M {
+    movfp dest=xmm0, src1=xmm0v, dataSize=8
+    movfp dest=xmm1, src1=xmm1v, dataSize=8
+    ldfp ufp1, seg, sib, disp, dataSize=4
+    mdivf xmm0, xmm0v, ufp1, size=4, ext=Scalar
+    vclear dest=xmm2, destVL=16
+};
+
+def macroop VDIVSS_XMM_P {
+    movfp dest=xmm0, src1=xmm0v, dataSize=8
+    movfp dest=xmm1, src1=xmm1v, dataSize=8
+    rdip t7
+    ldfp ufp1, seg, riprel, disp, dataSize=4
+    mdivf xmm0, xmm0v, ufp1, size=4, ext=Scalar
+    vclear dest=xmm2, destVL=16
+};
+
+'''
diff --git a/src/arch/x86/isa/insts/simd512/floating_point/arithmetic/vfmadd231ps.py b/src/arch/x86/isa/insts/simd512/floating_point/arithmetic/vfmadd231ps.py
new file mode 100644
index 0000000000..21ec6388c3
--- /dev/null
+++ b/src/arch/x86/isa/insts/simd512/floating_point/arithmetic/vfmadd231ps.py
@@ -0,0 +1,54 @@
+
+microcode = '''
+def macroop VFMADD231PS_XMM_XMM {
+    vfmadd231f dest=xmm0, src1=xmm0v, src2=xmm0m, size=4, VL=16
+    vclear dest=xmm2, destVL=16
+};
+
+def macroop VFMADD231PS_XMM_M {
+    ldfp128 ufp1, seg, sib, "DISPLACEMENT + 0", dataSize=16
+    vfmadd231f dest=xmm0, src1=xmm0v, src2=ufp1, size=4, VL=16
+    vclear dest=xmm2, destVL=16
+};
+
+def macroop VFMADD231PS_XMM_P {
+    rdip t7
+    ldfp128 ufp1, seg, riprel, "DISPLACEMENT + 0", dataSize=16
+    vfmadd231f dest=xmm0, src1=xmm0v, src2=ufp1, size=4, VL=16
+    vclear dest=xmm2, destVL=16
+};
+
+def macroop VFMADD231PS_YMM_YMM {
+    vfmadd231f dest=xmm0, src1=xmm0v, src2=xmm0m, size=4, VL=32
+    vclear dest=xmm4, destVL=32
+};
+
+def macroop VFMADD231PS_YMM_M {
+    ldfp256 ufp1, seg, sib, "DISPLACEMENT + 0", dataSize=32
+    vfmadd231f dest=xmm0, src1=xmm0v, src2=ufp1, size=4, VL=32
+    vclear dest=xmm4, destVL=32
+};
+
+def macroop VFMADD231PS_YMM_P {
+    rdip t7
+    ldfp256 ufp1, seg, riprel, "DISPLACEMENT + 0", dataSize=32
+    vfmadd231f dest=xmm0, src1=xmm0v, src2=ufp1, size=4, VL=32
+    vclear dest=xmm4, destVL=32
+};
+
+def macroop VFMADD231PS_ZMM_ZMM {
+    vfmadd231f dest=xmm0, src1=xmm0v, src2=xmm0m, size=4, VL=64
+};
+
+def macroop VFMADD231PS_ZMM_M {
+    ldfp512 ufp1, seg, sib, "DISPLACEMENT + 0", dataSize=64
+    vfmadd231f dest=xmm0, src1=xmm0v, src2=ufp1, size=4, VL=64
+};
+
+def macroop VFMADD231PS_ZMM_P {
+    rdip t7
+    ldfp512 ufp1, seg, riprel, "DISPLACEMENT + 0", dataSize=64
+    vfmadd231f dest=xmm0, src1=xmm0v, src2=ufp1, size=4, VL=64
+};
+
+'''
diff --git a/src/arch/x86/isa/insts/simd512/floating_point/arithmetic/vmulpd.py b/src/arch/x86/isa/insts/simd512/floating_point/arithmetic/vmulpd.py
new file mode 100644
index 0000000000..68455ed368
--- /dev/null
+++ b/src/arch/x86/isa/insts/simd512/floating_point/arithmetic/vmulpd.py
@@ -0,0 +1,54 @@
+
+microcode = '''
+def macroop VMULPD_XMM_XMM {
+    vmulf dest=xmm0, src1=xmm0v, src2=xmm0m, size=8, VL=16
+    vclear dest=xmm2, destVL=16
+};
+
+def macroop VMULPD_XMM_M {
+    ldfp128 ufp1, seg, sib, "DISPLACEMENT + 0", dataSize=16
+    vmulf dest=xmm0, src1=xmm0v, src2=ufp1, size=8, VL=16
+    vclear dest=xmm2, destVL=16
+};
+
+def macroop VMULPD_XMM_P {
+    rdip t7
+    ldfp128 ufp1, seg, riprel, "DISPLACEMENT + 0", dataSize=16
+    vmulf dest=xmm0, src1=xmm0v, src2=ufp1, size=8, VL=16
+    vclear dest=xmm2, destVL=16
+};
+
+def macroop VMULPD_YMM_YMM {
+    vmulf dest=xmm0, src1=xmm0v, src2=xmm0m, size=8, VL=32
+    vclear dest=xmm4, destVL=32
+};
+
+def macroop VMULPD_YMM_M {
+    ldfp256 ufp1, seg, sib, "DISPLACEMENT + 0", dataSize=32
+    vmulf dest=xmm0, src1=xmm0v, src2=ufp1, size=8, VL=32
+    vclear dest=xmm4, destVL=32
+};
+
+def macroop VMULPD_YMM_P {
+    rdip t7
+    ldfp256 ufp1, seg, riprel, "DISPLACEMENT + 0", dataSize=32
+    vmulf dest=xmm0, src1=xmm0v, src2=ufp1, size=8, VL=32
+    vclear dest=xmm4, destVL=32
+};
+
+def macroop VMULPD_ZMM_ZMM {
+    vmulf dest=xmm0, src1=xmm0v, src2=xmm0m, size=8, VL=64
+};
+
+def macroop VMULPD_ZMM_M {
+    ldfp512 ufp1, seg, sib, "DISPLACEMENT + 0", dataSize=64
+    vmulf dest=xmm0, src1=xmm0v, src2=ufp1, size=8, VL=64
+};
+
+def macroop VMULPD_ZMM_P {
+    rdip t7
+    ldfp512 ufp1, seg, riprel, "DISPLACEMENT + 0", dataSize=64
+    vmulf dest=xmm0, src1=xmm0v, src2=ufp1, size=8, VL=64
+};
+
+'''
diff --git a/src/arch/x86/isa/insts/simd512/floating_point/arithmetic/vmulps.py b/src/arch/x86/isa/insts/simd512/floating_point/arithmetic/vmulps.py
new file mode 100644
index 0000000000..63978351c1
--- /dev/null
+++ b/src/arch/x86/isa/insts/simd512/floating_point/arithmetic/vmulps.py
@@ -0,0 +1,54 @@
+
+microcode = '''
+def macroop VMULPS_XMM_XMM {
+    vmulf dest=xmm0, src1=xmm0v, src2=xmm0m, size=4, VL=16
+    vclear dest=xmm2, destVL=16
+};
+
+def macroop VMULPS_XMM_M {
+    ldfp128 ufp1, seg, sib, "DISPLACEMENT + 0", dataSize=16
+    vmulf dest=xmm0, src1=xmm0v, src2=ufp1, size=4, VL=16
+    vclear dest=xmm2, destVL=16
+};
+
+def macroop VMULPS_XMM_P {
+    rdip t7
+    ldfp128 ufp1, seg, riprel, "DISPLACEMENT + 0", dataSize=16
+    vmulf dest=xmm0, src1=xmm0v, src2=ufp1, size=4, VL=16
+    vclear dest=xmm2, destVL=16
+};
+
+def macroop VMULPS_YMM_YMM {
+    vmulf dest=xmm0, src1=xmm0v, src2=xmm0m, size=4, VL=32
+    vclear dest=xmm4, destVL=32
+};
+
+def macroop VMULPS_YMM_M {
+    ldfp256 ufp1, seg, sib, "DISPLACEMENT + 0", dataSize=32
+    vmulf dest=xmm0, src1=xmm0v, src2=ufp1, size=4, VL=32
+    vclear dest=xmm4, destVL=32
+};
+
+def macroop VMULPS_YMM_P {
+    rdip t7
+    ldfp256 ufp1, seg, riprel, "DISPLACEMENT + 0", dataSize=32
+    vmulf dest=xmm0, src1=xmm0v, src2=ufp1, size=4, VL=32
+    vclear dest=xmm4, destVL=32
+};
+
+def macroop VMULPS_ZMM_ZMM {
+    vmulf dest=xmm0, src1=xmm0v, src2=xmm0m, size=4, VL=64
+};
+
+def macroop VMULPS_ZMM_M {
+    ldfp512 ufp1, seg, sib, "DISPLACEMENT + 0", dataSize=64
+    vmulf dest=xmm0, src1=xmm0v, src2=ufp1, size=4, VL=64
+};
+
+def macroop VMULPS_ZMM_P {
+    rdip t7
+    ldfp512 ufp1, seg, riprel, "DISPLACEMENT + 0", dataSize=64
+    vmulf dest=xmm0, src1=xmm0v, src2=ufp1, size=4, VL=64
+};
+
+'''
diff --git a/src/arch/x86/isa/insts/simd512/floating_point/arithmetic/vmulsd.py b/src/arch/x86/isa/insts/simd512/floating_point/arithmetic/vmulsd.py
new file mode 100644
index 0000000000..8bb1663b4b
--- /dev/null
+++ b/src/arch/x86/isa/insts/simd512/floating_point/arithmetic/vmulsd.py
@@ -0,0 +1,24 @@
+
+microcode = '''
+def macroop VMULSD_XMM_XMM {
+    mmulf xmm0, xmm0v, xmm0m, size=8, ext=Scalar
+    movfp dest=xmm1, src1=xmm1v, dataSize=8
+    vclear dest=xmm2, destVL=16
+};
+
+def macroop VMULSD_XMM_M {
+    ldfp ufp1, seg, sib, disp, dataSize=8
+    mmulf xmm0, xmm0v, ufp1, size=8, ext=Scalar
+    movfp dest=xmm1, src1=xmm1v, dataSize=8
+    vclear dest=xmm2, destVL=16
+};
+
+def macroop VMULSD_XMM_P {
+    rdip t7
+    ldfp ufp1, seg, riprel, disp, dataSize=8
+    mmulf xmm0, xmm0v, ufp1, size=8, ext=Scalar
+    movfp dest=xmm1, src1=xmm1v, dataSize=8
+    vclear dest=xmm2, destVL=16
+};
+
+'''
diff --git a/src/arch/x86/isa/insts/simd512/floating_point/arithmetic/vmulss.py b/src/arch/x86/isa/insts/simd512/floating_point/arithmetic/vmulss.py
new file mode 100644
index 0000000000..30dd9e9d26
--- /dev/null
+++ b/src/arch/x86/isa/insts/simd512/floating_point/arithmetic/vmulss.py
@@ -0,0 +1,27 @@
+
+microcode = '''
+def macroop VMULSS_XMM_XMM {
+    mmulf xmm0, xmm0v, xmm0m, size=4, ext=Scalar
+    movfph2h dest=xmm0, src1=xmm0v, dataSize=4
+    movfp dest=xmm1, src1=xmm1v, dataSize=8
+    vclear dest=xmm2, destVL=16
+};
+
+def macroop VMULSS_XMM_M {
+    movfp dest=xmm0, src1=xmm0v, dataSize=8
+    movfp dest=xmm1, src1=xmm1v, dataSize=8
+    ldfp ufp1, seg, sib, disp, dataSize=4
+    mmulf xmm0, xmm0v, ufp1, size=4, ext=Scalar
+    vclear dest=xmm2, destVL=16
+};
+
+def macroop VMULSS_XMM_P {
+    movfp dest=xmm0, src1=xmm0v, dataSize=8
+    movfp dest=xmm1, src1=xmm1v, dataSize=8
+    rdip t7
+    ldfp ufp1, seg, riprel, disp, dataSize=4
+    mmulf xmm0, xmm0v, ufp1, size=4, ext=Scalar
+    vclear dest=xmm2, destVL=16
+};
+
+'''
diff --git a/src/arch/x86/isa/insts/simd512/floating_point/arithmetic/vpxor.py b/src/arch/x86/isa/insts/simd512/floating_point/arithmetic/vpxor.py
new file mode 100644
index 0000000000..3b6119beb0
--- /dev/null
+++ b/src/arch/x86/isa/insts/simd512/floating_point/arithmetic/vpxor.py
@@ -0,0 +1,59 @@
+
+microcode = '''
+def macroop VPXOR_XMM_XMM {
+    mxor xmm0, xmm0v, xmm0m
+    mxor xmm1, xmm1v, xmm1m
+    vclear dest=xmm2, destVL=16
+};
+
+def macroop VPXOR_XMM_M {
+    ldfp ufp1, seg, sib, disp, dataSize=8
+    ldfp ufp2, seg, sib, "DISPLACEMENT + 8", dataSize=8
+    mxor xmm0, xmm0v, ufp1
+    mxor xmm1, xmm1v, ufp2
+    vclear dest=xmm2, destVL=16
+};
+
+def macroop VPXOR_XMM_P {
+    rdip t7
+    ldfp ufp1, seg, riprel, disp, dataSize=8
+    ldfp ufp2, seg, riprel, "DISPLACEMENT + 8", dataSize=8
+    mxor xmm0, xmm0v, ufp1
+    mxor xmm1, xmm1v, ufp2
+    vclear dest=xmm2, destVL=16
+};
+
+def macroop VPXOR_YMM_YMM {
+    mxor xmm0, xmm0v, xmm0m
+    mxor xmm1, xmm1v, xmm1m
+    mxor xmm2, xmm2v, xmm2m
+    mxor xmm3, xmm3v, xmm3m
+    vclear dest=xmm4, destVL=32
+};
+
+def macroop VPXOR_YMM_M {
+    ldfp ufp1, seg, sib, disp, dataSize=8
+    ldfp ufp2, seg, sib, "DISPLACEMENT + 8", dataSize=8
+    ldfp ufp3, seg, sib, "DISPLACEMENT + 16", dataSize=8
+    ldfp ufp4, seg, sib, "DISPLACEMENT + 24", dataSize=8
+    mxor xmm0, xmm0v, ufp1
+    mxor xmm1, xmm1v, ufp2
+    mxor xmm2, xmm2v, ufp3
+    mxor xmm3, xmm3v, ufp4
+    vclear dest=xmm4, destVL=32
+};
+
+def macroop VPXOR_YMM_P {
+    rdip t7
+    ldfp ufp1, seg, riprel, disp, dataSize=8
+    ldfp ufp2, seg, riprel, "DISPLACEMENT + 8", dataSize=8
+    ldfp ufp3, seg, riprel, "DISPLACEMENT + 16", dataSize=8
+    ldfp ufp4, seg, riprel, "DISPLACEMENT + 24", dataSize=8
+    mxor xmm0, xmm0v, ufp1
+    mxor xmm1, xmm1v, ufp2
+    mxor xmm2, xmm2v, ufp3
+    mxor xmm3, xmm3v, ufp4
+    vclear dest=xmm4, destVL=32
+};
+
+'''
diff --git a/src/arch/x86/isa/insts/simd512/floating_point/arithmetic/vsubpd.py b/src/arch/x86/isa/insts/simd512/floating_point/arithmetic/vsubpd.py
new file mode 100644
index 0000000000..d68c0a227f
--- /dev/null
+++ b/src/arch/x86/isa/insts/simd512/floating_point/arithmetic/vsubpd.py
@@ -0,0 +1,48 @@
+
+microcode = '''
+def macroop VSUBPD_XMM_XMM {
+    vsubf dest=xmm0, src1=xmm0v, src2=xmm0m, size=8, VL=16
+};
+
+def macroop VSUBPD_XMM_M {
+    ldfp128 ufp1, seg, sib, "DISPLACEMENT + 0", dataSize=16
+    vsubf dest=xmm0, src1=xmm0v, src2=ufp1, size=8, VL=16
+};
+
+def macroop VSUBPD_XMM_P {
+    rdip t7
+    ldfp128 ufp1, seg, riprel, "DISPLACEMENT + 0", dataSize=16
+    vsubf dest=xmm0, src1=xmm0v, src2=ufp1, size=8, VL=16
+};
+
+def macroop VSUBPD_YMM_YMM {
+    vsubf dest=xmm0, src1=xmm0v, src2=xmm0m, size=8, VL=32
+};
+
+def macroop VSUBPD_YMM_M {
+    ldfp256 ufp1, seg, sib, "DISPLACEMENT + 0", dataSize=32
+    vsubf dest=xmm0, src1=xmm0v, src2=ufp1, size=8, VL=32
+};
+
+def macroop VSUBPD_YMM_P {
+    rdip t7
+    ldfp256 ufp1, seg, riprel, "DISPLACEMENT + 0", dataSize=32
+    vsubf dest=xmm0, src1=xmm0v, src2=ufp1, size=8, VL=32
+};
+
+def macroop VSUBPD_ZMM_ZMM {
+    vsubf dest=xmm0, src1=xmm0v, src2=xmm0m, size=8, VL=64
+};
+
+def macroop VSUBPD_ZMM_M {
+    ldfp512 ufp1, seg, sib, "DISPLACEMENT + 0", dataSize=64
+    vsubf dest=xmm0, src1=xmm0v, src2=ufp1, size=8, VL=64
+};
+
+def macroop VSUBPD_ZMM_P {
+    rdip t7
+    ldfp512 ufp1, seg, riprel, "DISPLACEMENT + 0", dataSize=64
+    vsubf dest=xmm0, src1=xmm0v, src2=ufp1, size=8, VL=64
+};
+
+'''
diff --git a/src/arch/x86/isa/insts/simd512/floating_point/arithmetic/vsubps.py b/src/arch/x86/isa/insts/simd512/floating_point/arithmetic/vsubps.py
new file mode 100644
index 0000000000..52ff484719
--- /dev/null
+++ b/src/arch/x86/isa/insts/simd512/floating_point/arithmetic/vsubps.py
@@ -0,0 +1,54 @@
+
+microcode = '''
+def macroop VSUBPS_XMM_XMM {
+    vsubf dest=xmm0, src1=xmm0v, src2=xmm0m, size=4, VL=16
+    vclear dest=xmm2, destVL=16
+};
+
+def macroop VSUBPS_XMM_M {
+    ldfp128 ufp1, seg, sib, "DISPLACEMENT + 0", dataSize=16
+    vsubf dest=xmm0, src1=xmm0v, src2=ufp1, size=4, VL=16
+    vclear dest=xmm2, destVL=16
+};
+
+def macroop VSUBPS_XMM_P {
+    rdip t7
+    ldfp128 ufp1, seg, riprel, "DISPLACEMENT + 0", dataSize=16
+    vsubf dest=xmm0, src1=xmm0v, src2=ufp1, size=4, VL=16
+    vclear dest=xmm2, destVL=16
+};
+
+def macroop VSUBPS_YMM_YMM {
+    vsubf dest=xmm0, src1=xmm0v, src2=xmm0m, size=4, VL=32
+    vclear dest=xmm4, destVL=32
+};
+
+def macroop VSUBPS_YMM_M {
+    ldfp256 ufp1, seg, sib, "DISPLACEMENT + 0", dataSize=32
+    vsubf dest=xmm0, src1=xmm0v, src2=ufp1, size=4, VL=32
+    vclear dest=xmm4, destVL=32
+};
+
+def macroop VSUBPS_YMM_P {
+    rdip t7
+    ldfp256 ufp1, seg, riprel, "DISPLACEMENT + 0", dataSize=32
+    vsubf dest=xmm0, src1=xmm0v, src2=ufp1, size=4, VL=32
+    vclear dest=xmm4, destVL=32
+};
+
+def macroop VSUBPS_ZMM_ZMM {
+    vsubf dest=xmm0, src1=xmm0v, src2=xmm0m, size=4, VL=64
+};
+
+def macroop VSUBPS_ZMM_M {
+    ldfp512 ufp1, seg, sib, "DISPLACEMENT + 0", dataSize=64
+    vsubf dest=xmm0, src1=xmm0v, src2=ufp1, size=4, VL=64
+};
+
+def macroop VSUBPS_ZMM_P {
+    rdip t7
+    ldfp512 ufp1, seg, riprel, "DISPLACEMENT + 0", dataSize=64
+    vsubf dest=xmm0, src1=xmm0v, src2=ufp1, size=4, VL=64
+};
+
+'''
diff --git a/src/arch/x86/isa/insts/simd512/floating_point/arithmetic/vsubsd.py b/src/arch/x86/isa/insts/simd512/floating_point/arithmetic/vsubsd.py
new file mode 100644
index 0000000000..695b3dc1ca
--- /dev/null
+++ b/src/arch/x86/isa/insts/simd512/floating_point/arithmetic/vsubsd.py
@@ -0,0 +1,24 @@
+
+microcode = '''
+def macroop VSUBSD_XMM_XMM {
+    msubf xmm0, xmm0v, xmm0m, size=8, ext=Scalar
+    movfp dest=xmm1, src1=xmm1v, dataSize=8
+    vclear dest=xmm2, destVL=16
+};
+
+def macroop VSUBSD_XMM_M {
+    ldfp ufp1, seg, sib, disp, dataSize=8
+    msubf xmm0, xmm0v, ufp1, size=8, ext=Scalar
+    movfp dest=xmm1, src1=xmm1v, dataSize=8
+    vclear dest=xmm2, destVL=16
+};
+
+def macroop VSUBSD_XMM_P {
+    rdip t7
+    ldfp ufp1, seg, riprel, disp, dataSize=8
+    msubf xmm0, xmm0v, ufp1, size=8, ext=Scalar
+    movfp dest=xmm1, src1=xmm1v, dataSize=8
+    vclear dest=xmm2, destVL=16
+};
+
+'''
diff --git a/src/arch/x86/isa/insts/simd512/floating_point/arithmetic/vsubss.py b/src/arch/x86/isa/insts/simd512/floating_point/arithmetic/vsubss.py
new file mode 100644
index 0000000000..5808c9d491
--- /dev/null
+++ b/src/arch/x86/isa/insts/simd512/floating_point/arithmetic/vsubss.py
@@ -0,0 +1,27 @@
+
+microcode = '''
+def macroop VSUBSS_XMM_XMM {
+    msubf xmm0, xmm0v, xmm0m, size=4, ext=Scalar
+    movfph2h dest=xmm0, src1=xmm0v, dataSize=4
+    movfp dest=xmm1, src1=xmm1v, dataSize=8
+    vclear dest=xmm2, destVL=16
+};
+
+def macroop VSUBSS_XMM_M {
+    movfp dest=xmm0, src1=xmm0v, dataSize=8
+    movfp dest=xmm1, src1=xmm1v, dataSize=8
+    ldfp ufp1, seg, sib, disp, dataSize=4
+    msubf xmm0, xmm0v, ufp1, size=4, ext=Scalar
+    vclear dest=xmm2, destVL=16
+};
+
+def macroop VSUBSS_XMM_P {
+    movfp dest=xmm0, src1=xmm0v, dataSize=8
+    movfp dest=xmm1, src1=xmm1v, dataSize=8
+    rdip t7
+    ldfp ufp1, seg, riprel, disp, dataSize=4
+    msubf xmm0, xmm0v, ufp1, size=4, ext=Scalar
+    vclear dest=xmm2, destVL=16
+};
+
+'''
diff --git a/src/arch/x86/isa/insts/simd512/floating_point/arithmetic/vxorpd.py b/src/arch/x86/isa/insts/simd512/floating_point/arithmetic/vxorpd.py
new file mode 100644
index 0000000000..74906b04d2
--- /dev/null
+++ b/src/arch/x86/isa/insts/simd512/floating_point/arithmetic/vxorpd.py
@@ -0,0 +1,59 @@
+
+microcode = '''
+def macroop VXORPD_XMM_XMM {
+    mxor xmm0, xmm0v, xmm0m
+    mxor xmm1, xmm1v, xmm1m
+    vclear dest=xmm2, destVL=16
+};
+
+def macroop VXORPD_XMM_M {
+    ldfp ufp1, seg, sib, disp, dataSize=8
+    ldfp ufp2, seg, sib, "DISPLACEMENT + 8", dataSize=8
+    mxor xmm0, xmm0v, ufp1
+    mxor xmm1, xmm1v, ufp2
+    vclear dest=xmm2, destVL=16
+};
+
+def macroop VXORPD_XMM_P {
+    rdip t7
+    ldfp ufp1, seg, riprel, disp, dataSize=8
+    ldfp ufp2, seg, riprel, "DISPLACEMENT + 8", dataSize=8
+    mxor xmm0, xmm0v, ufp1
+    mxor xmm1, xmm1v, ufp2
+    vclear dest=xmm2, destVL=16
+};
+
+def macroop VXORPD_YMM_YMM {
+    mxor xmm0, xmm0v, xmm0m
+    mxor xmm1, xmm1v, xmm1m
+    mxor xmm2, xmm2v, xmm2m
+    mxor xmm3, xmm3v, xmm3m
+    vclear dest=xmm4, destVL=32
+};
+
+def macroop VXORPD_YMM_M {
+    ldfp ufp1, seg, sib, disp, dataSize=8
+    ldfp ufp2, seg, sib, "DISPLACEMENT + 8", dataSize=8
+    ldfp ufp3, seg, sib, "DISPLACEMENT + 16", dataSize=8
+    ldfp ufp4, seg, sib, "DISPLACEMENT + 24", dataSize=8
+    mxor xmm0, xmm0v, ufp1
+    mxor xmm1, xmm1v, ufp2
+    mxor xmm2, xmm2v, ufp3
+    mxor xmm3, xmm3v, ufp4
+    vclear dest=xmm4, destVL=32
+};
+
+def macroop VXORPD_YMM_P {
+    rdip t7
+    ldfp ufp1, seg, riprel, disp, dataSize=8
+    ldfp ufp2, seg, riprel, "DISPLACEMENT + 8", dataSize=8
+    ldfp ufp3, seg, riprel, "DISPLACEMENT + 16", dataSize=8
+    ldfp ufp4, seg, riprel, "DISPLACEMENT + 24", dataSize=8
+    mxor xmm0, xmm0v, ufp1
+    mxor xmm1, xmm1v, ufp2
+    mxor xmm2, xmm2v, ufp3
+    mxor xmm3, xmm3v, ufp4
+    vclear dest=xmm4, destVL=32
+};
+
+'''
diff --git a/src/arch/x86/isa/insts/simd512/floating_point/arithmetic/vxorps.py b/src/arch/x86/isa/insts/simd512/floating_point/arithmetic/vxorps.py
new file mode 100644
index 0000000000..6d9db65d4f
--- /dev/null
+++ b/src/arch/x86/isa/insts/simd512/floating_point/arithmetic/vxorps.py
@@ -0,0 +1,59 @@
+
+microcode = '''
+def macroop VXORPS_XMM_XMM {
+    mxor xmm0, xmm0v, xmm0m
+    mxor xmm1, xmm1v, xmm1m
+    vclear dest=xmm2, destVL=16
+};
+
+def macroop VXORPS_XMM_M {
+    ldfp ufp1, seg, sib, disp, dataSize=8
+    ldfp ufp2, seg, sib, "DISPLACEMENT + 8", dataSize=8
+    mxor xmm0, xmm0v, ufp1
+    mxor xmm1, xmm1v, ufp2
+    vclear dest=xmm2, destVL=16
+};
+
+def macroop VXORPS_XMM_P {
+    rdip t7
+    ldfp ufp1, seg, riprel, disp, dataSize=8
+    ldfp ufp2, seg, riprel, "DISPLACEMENT + 8", dataSize=8
+    mxor xmm0, xmm0v, ufp1
+    mxor xmm1, xmm1v, ufp2
+    vclear dest=xmm2, destVL=16
+};
+
+def macroop VXORPS_YMM_YMM {
+    mxor xmm0, xmm0v, xmm0m
+    mxor xmm1, xmm1v, xmm1m
+    mxor xmm2, xmm2v, xmm2m
+    mxor xmm3, xmm3v, xmm3m
+    vclear dest=xmm4, destVL=32
+};
+
+def macroop VXORPS_YMM_M {
+    ldfp ufp1, seg, sib, disp, dataSize=8
+    ldfp ufp2, seg, sib, "DISPLACEMENT + 8", dataSize=8
+    ldfp ufp3, seg, sib, "DISPLACEMENT + 16", dataSize=8
+    ldfp ufp4, seg, sib, "DISPLACEMENT + 24", dataSize=8
+    mxor xmm0, xmm0v, ufp1
+    mxor xmm1, xmm1v, ufp2
+    mxor xmm2, xmm2v, ufp3
+    mxor xmm3, xmm3v, ufp4
+    vclear dest=xmm4, destVL=32
+};
+
+def macroop VXORPS_YMM_P {
+    rdip t7
+    ldfp ufp1, seg, riprel, disp, dataSize=8
+    ldfp ufp2, seg, riprel, "DISPLACEMENT + 8", dataSize=8
+    ldfp ufp3, seg, riprel, "DISPLACEMENT + 16", dataSize=8
+    ldfp ufp4, seg, riprel, "DISPLACEMENT + 24", dataSize=8
+    mxor xmm0, xmm0v, ufp1
+    mxor xmm1, xmm1v, ufp2
+    mxor xmm2, xmm2v, ufp3
+    mxor xmm3, xmm3v, ufp4
+    vclear dest=xmm4, destVL=32
+};
+
+'''
diff --git a/src/arch/x86/isa/insts/simd512/floating_point/data_conversion/__init__.py b/src/arch/x86/isa/insts/simd512/floating_point/data_conversion/__init__.py
new file mode 100644
index 0000000000..65581e764b
--- /dev/null
+++ b/src/arch/x86/isa/insts/simd512/floating_point/data_conversion/__init__.py
@@ -0,0 +1,56 @@
+# Copyright (c) 2007 The Hewlett-Packard Development Company
+# All rights reserved.
+#
+# The license below extends only to copyright in the software and shall
+# not be construed as granting a license to any other intellectual
+# property including but not limited to intellectual property relating
+# to a hardware implementation of the functionality of the software
+# licensed hereunder.  You may use the software subject to the license
+# terms below provided that you ensure that this notice is replicated
+# unmodified and in its entirety in all distributions of the software,
+# modified or unmodified, in source code or in binary form.
+#
+# Redistribution and use in source and binary forms, with or without
+# modification, are permitted provided that the following conditions are
+# met: redistributions of source code must retain the above copyright
+# notice, this list of conditions and the following disclaimer;
+# redistributions in binary form must reproduce the above copyright
+# notice, this list of conditions and the following disclaimer in the
+# documentation and/or other materials provided with the distribution;
+# neither the name of the copyright holders nor the names of its
+# contributors may be used to endorse or promote products derived from
+# this software without specific prior written permission.
+#
+# THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS
+# "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT
+# LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR
+# A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT
+# OWNER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,
+# SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT
+# LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,
+# DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY
+# THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
+# (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE
+# OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
+#
+# Authors: Gabe Black
+
+categories = [
+    "vcvtss2sd",
+    "vcvtps2pd",
+    "vcvtpd2ps",
+    "vcvtdq2ps",
+    "vcvtdq2pd",
+    "vcvtsd2ss",
+    "vcvtsi2ss",
+    "vcvtsi2sd",
+    "vcvtusi2ss",
+    "vcvttss2si",
+]
+
+microcode = '''
+# AVX instructions
+'''
+for category in categories:
+    exec("from . import {s} as cat".format(s=category))
+    microcode += cat.microcode
diff --git a/src/arch/x86/isa/insts/simd512/floating_point/data_conversion/vcvtdq2pd.py b/src/arch/x86/isa/insts/simd512/floating_point/data_conversion/vcvtdq2pd.py
new file mode 100644
index 0000000000..979c04049c
--- /dev/null
+++ b/src/arch/x86/isa/insts/simd512/floating_point/data_conversion/vcvtdq2pd.py
@@ -0,0 +1,86 @@
+microcode = '''
+
+def macroop VCVTDQ2PD_XMM_XMM {
+    cvti2f xmm0, xmm0m, destSize=8, srcSize=4, ext=0
+    cvti2f xmm1, xmm0m, destSize=8, srcSize=4, ext=2
+    vclear dest=xmm2, destVL=16
+};
+
+def macroop VCVTDQ2PD_XMM_M {
+    ldfp ufp1, seg, sib, "DISPLACEMENT + 0", dataSize=8
+    cvti2f xmm0, ufp1, destSize=8, srcSize=4, ext=0
+    cvti2f xmm1, ufp1, destSize=8, srcSize=4, ext=2
+    vclear dest=xmm2, destVL=16
+};
+
+def macroop VCVTDQ2PD_XMM_P {
+    rdip t7
+    ldfp ufp1, seg, riprel, "DISPLACEMENT + 0", dataSize=8
+    cvti2f xmm0, ufp1, destSize=8, srcSize=4, ext=0
+    cvti2f xmm1, ufp1, destSize=8, srcSize=4, ext=2
+    vclear dest=xmm2, destVL=16
+};
+
+def macroop VCVTDQ2PD_YMM_XMM {
+    cvti2f xmm0, xmm0m, destSize=8, srcSize=4, ext=0
+    cvti2f xmm1, xmm0m, destSize=8, srcSize=4, ext=2
+    cvti2f xmm2, xmm1m, destSize=8, srcSize=4, ext=0
+    cvti2f xmm3, xmm1m, destSize=8, srcSize=4, ext=2
+    vclear dest=xmm4, destVL=32
+};
+
+def macroop VCVTDQ2PD_YMM_M {
+    ldfp128 ufp1, seg, sib, "DISPLACEMENT + 0", dataSize=16
+    cvti2f xmm0, ufp1, destSize=8, srcSize=4, ext=0
+    cvti2f xmm1, ufp1, destSize=8, srcSize=4, ext=2
+    cvti2f xmm2, ufp2, destSize=8, srcSize=4, ext=0
+    cvti2f xmm3, ufp2, destSize=8, srcSize=4, ext=2
+    vclear dest=xmm4, destVL=32
+};
+
+def macroop VCVTDQ2PD_YMM_P {
+    rdip t7
+    ldfp128 ufp1, seg, riprel, "DISPLACEMENT + 0", dataSize=16
+    cvti2f xmm0, ufp1, destSize=8, srcSize=4, ext=0
+    cvti2f xmm1, ufp1, destSize=8, srcSize=4, ext=2
+    cvti2f xmm2, ufp2, destSize=8, srcSize=4, ext=0
+    cvti2f xmm3, ufp2, destSize=8, srcSize=4, ext=2
+    vclear dest=xmm4, destVL=32
+};
+
+def macroop VCVTDQ2PD_ZMM_YMM {
+    cvti2f xmm0, xmm0m, destSize=8, srcSize=4, ext=0
+    cvti2f xmm1, xmm0m, destSize=8, srcSize=4, ext=2
+    cvti2f xmm2, xmm1m, destSize=8, srcSize=4, ext=0
+    cvti2f xmm3, xmm1m, destSize=8, srcSize=4, ext=2
+    cvti2f xmm4, xmm2m, destSize=8, srcSize=4, ext=0
+    cvti2f xmm5, xmm2m, destSize=8, srcSize=4, ext=2
+    cvti2f xmm6, xmm3m, destSize=8, srcSize=4, ext=0
+    cvti2f xmm7, xmm3m, destSize=8, srcSize=4, ext=2
+};
+
+def macroop VCVTDQ2PD_ZMM_M {
+    ldfp256 ufp1, seg, sib, "DISPLACEMENT + 0", dataSize=32
+    cvti2f xmm0, ufp1, destSize=8, srcSize=4, ext=0
+    cvti2f xmm1, ufp1, destSize=8, srcSize=4, ext=2
+    cvti2f xmm2, ufp2, destSize=8, srcSize=4, ext=0
+    cvti2f xmm3, ufp2, destSize=8, srcSize=4, ext=2
+    cvti2f xmm4, ufp3, destSize=8, srcSize=4, ext=0
+    cvti2f xmm5, ufp3, destSize=8, srcSize=4, ext=2
+    cvti2f xmm6, ufp4, destSize=8, srcSize=4, ext=0
+    cvti2f xmm7, ufp4, destSize=8, srcSize=4, ext=2
+};
+
+def macroop VCVTDQ2PD_ZMM_P {
+    rdip t7
+    ldfp256 ufp1, seg, riprel, "DISPLACEMENT + 0", dataSize=32
+    cvti2f xmm0, ufp1, destSize=8, srcSize=4, ext=0
+    cvti2f xmm1, ufp1, destSize=8, srcSize=4, ext=2
+    cvti2f xmm2, ufp2, destSize=8, srcSize=4, ext=0
+    cvti2f xmm3, ufp2, destSize=8, srcSize=4, ext=2
+    cvti2f xmm4, ufp3, destSize=8, srcSize=4, ext=0
+    cvti2f xmm5, ufp3, destSize=8, srcSize=4, ext=2
+    cvti2f xmm6, ufp4, destSize=8, srcSize=4, ext=0
+    cvti2f xmm7, ufp4, destSize=8, srcSize=4, ext=2
+};
+'''
\ No newline at end of file
diff --git a/src/arch/x86/isa/insts/simd512/floating_point/data_conversion/vcvtdq2ps.py b/src/arch/x86/isa/insts/simd512/floating_point/data_conversion/vcvtdq2ps.py
new file mode 100644
index 0000000000..f042c26e01
--- /dev/null
+++ b/src/arch/x86/isa/insts/simd512/floating_point/data_conversion/vcvtdq2ps.py
@@ -0,0 +1,86 @@
+microcode = '''
+
+def macroop VCVTDQ2PS_XMM_XMM {
+    cvti2f xmm0, xmm0m, size=4, ext=0
+    cvti2f xmm1, xmm1m, size=4, ext=0
+    vclear dest=xmm2, destVL=16
+};
+
+def macroop VCVTDQ2PS_XMM_M {
+    ldfp128 ufp1, seg, sib, "DISPLACEMENT + 0", dataSize=16
+    cvti2f xmm0, ufp1, size=4, ext=0
+    cvti2f xmm1, ufp2, size=4, ext=0
+    vclear dest=xmm2, destVL=16
+};
+
+def macroop VCVTDQ2PS_XMM_P {
+    rdip t7
+    ldfp128 ufp1, seg, riprel, "DISPLACEMENT + 0", dataSize=16
+    cvti2f xmm0, ufp1, size=4, ext=0
+    cvti2f xmm1, ufp2, size=4, ext=0
+    vclear dest=xmm2, destVL=16
+};
+
+def macroop VCVTDQ2PS_YMM_YMM {
+    cvti2f xmm0, xmm0m, size=4, ext=0
+    cvti2f xmm1, xmm1m, size=4, ext=0
+    cvti2f xmm2, xmm2m, size=4, ext=0
+    cvti2f xmm3, xmm3m, size=4, ext=0
+    vclear dest=xmm4, destVL=32
+};
+
+def macroop VCVTDQ2PS_YMM_M {
+    ldfp256 ufp1, seg, sib, "DISPLACEMENT + 0", dataSize=32
+    cvti2f xmm0, ufp1, size=4, ext=0
+    cvti2f xmm1, ufp2, size=4, ext=0
+    cvti2f xmm2, ufp3, size=4, ext=0
+    cvti2f xmm3, ufp4, size=4, ext=0
+    vclear dest=xmm4, destVL=32
+};
+
+def macroop VCVTDQ2PS_YMM_P {
+    rdip t7
+    ldfp256 ufp1, seg, riprel, "DISPLACEMENT + 0", dataSize=32
+    cvti2f xmm0, ufp1, size=4, ext=0
+    cvti2f xmm1, ufp2, size=4, ext=0
+    cvti2f xmm2, ufp3, size=4, ext=0
+    cvti2f xmm3, ufp4, size=4, ext=0
+    vclear dest=xmm4, destVL=32
+};
+
+def macroop VCVTDQ2PS_ZMM_ZMM {
+    cvti2f xmm0, xmm0m, size=4, ext=0
+    cvti2f xmm1, xmm1m, size=4, ext=0
+    cvti2f xmm2, xmm2m, size=4, ext=0
+    cvti2f xmm3, xmm3m, size=4, ext=0
+    cvti2f xmm4, xmm4m, size=4, ext=0
+    cvti2f xmm5, xmm5m, size=4, ext=0
+    cvti2f xmm6, xmm6m, size=4, ext=0
+    cvti2f xmm7, xmm7m, size=4, ext=0
+};
+
+def macroop VCVTDQ2PS_ZMM_M {
+    ldfp512 ufp1, seg, sib, "DISPLACEMENT + 0", dataSize=64
+    cvti2f xmm0, ufp1, size=4, ext=0
+    cvti2f xmm1, ufp2, size=4, ext=0
+    cvti2f xmm2, ufp3, size=4, ext=0
+    cvti2f xmm3, ufp4, size=4, ext=0
+    cvti2f xmm4, ufp5, size=4, ext=0
+    cvti2f xmm5, ufp6, size=4, ext=0
+    cvti2f xmm6, ufp7, size=4, ext=0
+    cvti2f xmm7, ufp8, size=4, ext=0
+};
+
+def macroop VCVTDQ2PS_ZMM_P {
+    rdip t7
+    ldfp512 ufp1, seg, riprel, "DISPLACEMENT + 0", dataSize=64
+    cvti2f xmm0, ufp1, size=4, ext=0
+    cvti2f xmm1, ufp2, size=4, ext=0
+    cvti2f xmm2, ufp3, size=4, ext=0
+    cvti2f xmm3, ufp4, size=4, ext=0
+    cvti2f xmm4, ufp5, size=4, ext=0
+    cvti2f xmm5, ufp6, size=4, ext=0
+    cvti2f xmm6, ufp7, size=4, ext=0
+    cvti2f xmm7, ufp8, size=4, ext=0
+};
+'''
\ No newline at end of file
diff --git a/src/arch/x86/isa/insts/simd512/floating_point/data_conversion/vcvtpd2ps.py b/src/arch/x86/isa/insts/simd512/floating_point/data_conversion/vcvtpd2ps.py
new file mode 100644
index 0000000000..e70cf89b53
--- /dev/null
+++ b/src/arch/x86/isa/insts/simd512/floating_point/data_conversion/vcvtpd2ps.py
@@ -0,0 +1,93 @@
+microcode = '''
+
+def macroop VCVTPD2PS128_XMM_XMM {
+    cvtf2f xmm0, xmm0m, destSize=4, srcSize=8, ext=0
+    cvtf2f xmm0, xmm1m, destSize=4, srcSize=8, ext=2
+    lfpimm xmm1, 0
+    vclear dest=xmm2, destVL=16
+};
+
+def macroop VCVTPD2PS128_XMM_M {
+    ldfp128 ufp1, seg, sib, "DISPLACEMENT + 0", dataSize=16
+    cvtf2f xmm0, ufp1, destSize=4, srcSize=8, ext=0
+    cvtf2f xmm0, ufp2, destSize=4, srcSize=8, ext=2
+    lfpimm xmm1, 0
+    vclear dest=xmm2, destVL=16
+};
+
+def macroop VCVTPD2PS128_XMM_P {
+    rdip t7
+    ldfp128 ufp1, seg, riprel, "DISPLACEMENT + 0", dataSize=16
+    cvtf2f xmm0, ufp1, destSize=4, srcSize=8, ext=0
+    cvtf2f xmm0, ufp2, destSize=4, srcSize=8, ext=2
+    lfpimm xmm1, 0
+    vclear dest=xmm2, destVL=16
+};
+
+def macroop VCVTPD2PS256_XMM_YMM {
+    cvtf2f xmm0, xmm0m, destSize=4, srcSize=8, ext=0
+    cvtf2f xmm0, xmm1m, destSize=4, srcSize=8, ext=2
+    cvtf2f xmm1, xmm2m, destSize=4, srcSize=8, ext=0
+    cvtf2f xmm1, xmm3m, destSize=4, srcSize=8, ext=2
+    vclear dest=xmm2, destVL=16
+};
+
+def macroop VCVTPD2PS256_XMM_M {
+    ldfp256 ufp1, seg, sib, "DISPLACEMENT + 0", dataSize=32
+    cvtf2f xmm0, ufp1, destSize=4, srcSize=8, ext=0
+    cvtf2f xmm0, ufp2, destSize=4, srcSize=8, ext=2
+    cvtf2f xmm1, ufp3, destSize=4, srcSize=8, ext=0
+    cvtf2f xmm1, ufp4, destSize=4, srcSize=8, ext=2
+    vclear dest=xmm2, destVL=16
+};
+
+def macroop VCVTPD2PS256_XMM_P {
+    rdip t7
+    ldfp256 ufp1, seg, riprel, "DISPLACEMENT + 0", dataSize=32
+    cvtf2f xmm0, ufp1, destSize=4, srcSize=8, ext=0
+    cvtf2f xmm0, ufp2, destSize=4, srcSize=8, ext=2
+    cvtf2f xmm1, ufp3, destSize=4, srcSize=8, ext=0
+    cvtf2f xmm1, ufp4, destSize=4, srcSize=8, ext=2
+    vclear dest=xmm2, destVL=16
+};
+
+def macroop VCVTPD2PS512_YMM_ZMM {
+    cvtf2f xmm0, xmm0m, destSize=4, srcSize=8, ext=0
+    cvtf2f xmm0, xmm1m, destSize=4, srcSize=8, ext=2
+    cvtf2f xmm1, xmm2m, destSize=4, srcSize=8, ext=0
+    cvtf2f xmm1, xmm3m, destSize=4, srcSize=8, ext=2
+    cvtf2f xmm2, xmm4m, destSize=4, srcSize=8, ext=0
+    cvtf2f xmm2, xmm5m, destSize=4, srcSize=8, ext=0
+    cvtf2f xmm3, xmm6m, destSize=4, srcSize=8, ext=2
+    cvtf2f xmm3, xmm7m, destSize=4, srcSize=8, ext=2
+    vclear dest=xmm4, destVL=32
+};
+
+def macroop VCVTPD2PS512_YMM_M {
+    ldfp512 ufp1, seg, sib, "DISPLACEMENT + 0", dataSize=64
+    cvtf2f xmm0, ufp1, destSize=4, srcSize=8, ext=0
+    cvtf2f xmm0, ufp2, destSize=4, srcSize=8, ext=2
+    cvtf2f xmm1, ufp3, destSize=4, srcSize=8, ext=0
+    cvtf2f xmm1, ufp4, destSize=4, srcSize=8, ext=2
+    cvtf2f xmm2, ufp5, destSize=4, srcSize=8, ext=0
+    cvtf2f xmm2, ufp6, destSize=4, srcSize=8, ext=0
+    cvtf2f xmm3, ufp7, destSize=4, srcSize=8, ext=2
+    cvtf2f xmm3, ufp8, destSize=4, srcSize=8, ext=2
+    vclear dest=xmm4, destVL=32
+};
+
+def macroop VCVTPD2PS512_YMM_P {
+    rdip t7
+    ldfp512 ufp1, seg, riprel, "DISPLACEMENT + 0", dataSize=64
+    cvtf2f xmm0, ufp1, destSize=4, srcSize=8, ext=0
+    cvtf2f xmm0, ufp2, destSize=4, srcSize=8, ext=2
+    cvtf2f xmm1, ufp3, destSize=4, srcSize=8, ext=0
+    cvtf2f xmm1, ufp4, destSize=4, srcSize=8, ext=2
+    cvtf2f xmm2, ufp5, destSize=4, srcSize=8, ext=0
+    cvtf2f xmm2, ufp6, destSize=4, srcSize=8, ext=0
+    cvtf2f xmm3, ufp7, destSize=4, srcSize=8, ext=2
+    cvtf2f xmm3, ufp8, destSize=4, srcSize=8, ext=2
+    vclear dest=xmm4, destVL=32
+};
+
+'''
\ No newline at end of file
diff --git a/src/arch/x86/isa/insts/simd512/floating_point/data_conversion/vcvtps2pd.py b/src/arch/x86/isa/insts/simd512/floating_point/data_conversion/vcvtps2pd.py
new file mode 100644
index 0000000000..9946bc7912
--- /dev/null
+++ b/src/arch/x86/isa/insts/simd512/floating_point/data_conversion/vcvtps2pd.py
@@ -0,0 +1,86 @@
+microcode = '''
+
+def macroop VCVTPS2PD_XMM_XMM {
+    cvtf2f xmm0, xmm0m, destSize=8, srcSize=4, ext=0
+    cvtf2f xmm1, xmm0m, destSize=8, srcSize=4, ext=2
+    vclear dest=xmm2, destVL=16
+};
+
+def macroop VCVTPS2PD_XMM_M {
+    ldfp ufp1, seg, sib, "DISPLACEMENT + 0", dataSize=8
+    cvtf2f xmm0, ufp1, destSize=8, srcSize=4, ext=0
+    cvtf2f xmm1, ufp1, destSize=8, srcSize=4, ext=2
+    vclear dest=xmm2, destVL=16
+};
+
+def macroop VCVTPS2PD_XMM_P {
+    rdip t7
+    ldfp ufp1, seg, riprel, "DISPLACEMENT + 0", dataSize=8
+    cvtf2f xmm0, ufp1, destSize=8, srcSize=4, ext=0
+    cvtf2f xmm1, ufp1, destSize=8, srcSize=4, ext=2
+    vclear dest=xmm2, destVL=16
+};
+
+def macroop VCVTPS2PD_YMM_XMM {
+    cvtf2f xmm0, xmm0m, destSize=8, srcSize=4, ext=0
+    cvtf2f xmm1, xmm0m, destSize=8, srcSize=4, ext=2
+    cvtf2f xmm2, xmm1m, destSize=8, srcSize=4, ext=0
+    cvtf2f xmm3, xmm1m, destSize=8, srcSize=4, ext=2
+    vclear dest=xmm4, destVL=32
+};
+
+def macroop VCVTPS2PD_YMM_M {
+    ldfp128 ufp1, seg, sib, "DISPLACEMENT + 0", dataSize=16
+    cvtf2f xmm0, ufp1, destSize=8, srcSize=4, ext=0
+    cvtf2f xmm1, ufp1, destSize=8, srcSize=4, ext=2
+    cvtf2f xmm2, ufp2, destSize=8, srcSize=4, ext=0
+    cvtf2f xmm3, ufp2, destSize=8, srcSize=4, ext=2
+    vclear dest=xmm4, destVL=32
+};
+
+def macroop VCVTPS2PD_YMM_P {
+    rdip t7
+    ldfp128 ufp1, seg, riprel, "DISPLACEMENT + 0", dataSize=16
+    cvtf2f xmm0, ufp1, destSize=8, srcSize=4, ext=0
+    cvtf2f xmm1, ufp1, destSize=8, srcSize=4, ext=2
+    cvtf2f xmm2, ufp2, destSize=8, srcSize=4, ext=0
+    cvtf2f xmm3, ufp2, destSize=8, srcSize=4, ext=2
+    vclear dest=xmm4, destVL=32
+};
+
+def macroop VCVTPS2PD_ZMM_YMM {
+    cvtf2f xmm0, xmm0m, destSize=8, srcSize=4, ext=0
+    cvtf2f xmm1, xmm0m, destSize=8, srcSize=4, ext=2
+    cvtf2f xmm2, xmm1m, destSize=8, srcSize=4, ext=0
+    cvtf2f xmm3, xmm1m, destSize=8, srcSize=4, ext=2
+    cvtf2f xmm4, xmm2m, destSize=8, srcSize=4, ext=0
+    cvtf2f xmm5, xmm2m, destSize=8, srcSize=4, ext=2
+    cvtf2f xmm6, xmm3m, destSize=8, srcSize=4, ext=0
+    cvtf2f xmm7, xmm3m, destSize=8, srcSize=4, ext=2
+};
+
+def macroop VCVTPS2PD_ZMM_M {
+    ldfp256 ufp1, seg, sib, "DISPLACEMENT + 0", dataSize=32
+    cvtf2f xmm0, ufp1, destSize=8, srcSize=4, ext=0
+    cvtf2f xmm1, ufp1, destSize=8, srcSize=4, ext=2
+    cvtf2f xmm2, ufp2, destSize=8, srcSize=4, ext=0
+    cvtf2f xmm3, ufp2, destSize=8, srcSize=4, ext=2
+    cvtf2f xmm4, ufp3, destSize=8, srcSize=4, ext=0
+    cvtf2f xmm5, ufp3, destSize=8, srcSize=4, ext=2
+    cvtf2f xmm6, ufp4, destSize=8, srcSize=4, ext=0
+    cvtf2f xmm7, ufp4, destSize=8, srcSize=4, ext=2
+};
+
+def macroop VCVTPS2PD_ZMM_P {
+    rdip t7
+    ldfp256 ufp1, seg, riprel, "DISPLACEMENT + 0", dataSize=32
+    cvtf2f xmm0, ufp1, destSize=8, srcSize=4, ext=0
+    cvtf2f xmm1, ufp1, destSize=8, srcSize=4, ext=2
+    cvtf2f xmm2, ufp2, destSize=8, srcSize=4, ext=0
+    cvtf2f xmm3, ufp2, destSize=8, srcSize=4, ext=2
+    cvtf2f xmm4, ufp3, destSize=8, srcSize=4, ext=0
+    cvtf2f xmm5, ufp3, destSize=8, srcSize=4, ext=2
+    cvtf2f xmm6, ufp4, destSize=8, srcSize=4, ext=0
+    cvtf2f xmm7, ufp4, destSize=8, srcSize=4, ext=2
+};
+'''
\ No newline at end of file
diff --git a/src/arch/x86/isa/insts/simd512/floating_point/data_conversion/vcvtsd2ss.py b/src/arch/x86/isa/insts/simd512/floating_point/data_conversion/vcvtsd2ss.py
new file mode 100644
index 0000000000..8e7d0347df
--- /dev/null
+++ b/src/arch/x86/isa/insts/simd512/floating_point/data_conversion/vcvtsd2ss.py
@@ -0,0 +1,27 @@
+microcode = '''
+
+def macroop VCVTSD2SS_XMM_XMM {
+    cvtf2f xmm0, xmm0m, destSize=4, srcSize=8, ext=Scalar
+    movfph2h xmm0, xmm0v, dataSize=4
+    movfp  xmm1, xmm1v, dataSize=8
+    vclear dest=xmm2, destVL=16
+};
+
+def macroop VCVTSD2SS_XMM_M {
+    ldfp ufp1, seg, sib, disp, dataSize=8
+    cvtf2f xmm0, ufp1, destSize=4, srcSize=8, ext=Scalar
+    movfph2h xmm0, xmm0v, dataSize=4
+    movfp  xmm1, xmm1v, dataSize=8
+    vclear dest=xmm2, destVL=16
+};
+
+def macroop VCVTSD2SS_XMM_P {
+    rdip t7
+    ldfp ufp1, seg, riprel, disp, dataSize=8
+    cvtf2f xmm0, ufp1, destSize=4, srcSize=8, ext=Scalar
+    movfph2h xmm0, xmm0v, dataSize=4
+    movfp  xmm1, xmm1v, dataSize=8
+    vclear dest=xmm2, destVL=16
+};
+
+'''
\ No newline at end of file
diff --git a/src/arch/x86/isa/insts/simd512/floating_point/data_conversion/vcvtsi2sd.py b/src/arch/x86/isa/insts/simd512/floating_point/data_conversion/vcvtsi2sd.py
new file mode 100644
index 0000000000..909396fbb6
--- /dev/null
+++ b/src/arch/x86/isa/insts/simd512/floating_point/data_conversion/vcvtsi2sd.py
@@ -0,0 +1,25 @@
+microcode = '''
+
+def macroop VCVTSI2SD_XMM_R {
+    mov2fp ufp1, regm, destSize=dsz, srcSize=dsz
+    cvti2f xmm0, ufp1, destSize=8, srcSize=dsz, ext=Scalar
+    movfp  xmm1, xmm1v, dataSize=8
+    vclear dest=xmm2, destVL=16
+};
+
+def macroop VCVTSI2SD_XMM_M {
+    ldfp ufp1, seg, sib, disp, dataSize=dsz
+    cvti2f xmm0, ufp1, destSize=8, srcSize=dsz, ext=Scalar
+    movfp  xmm1, xmm1v, dataSize=8
+    vclear dest=xmm2, destVL=16
+};
+
+def macroop VCVTSI2SD_XMM_P {
+    rdip t7
+    ldfp ufp1, seg, riprel, disp, dataSize=dsz
+    cvti2f xmm0, ufp1, destSize=8, srcSize=dsz, ext=Scalar
+    movfp  xmm1, xmm1v, dataSize=8
+    vclear dest=xmm2, destVL=16
+};
+
+'''
\ No newline at end of file
diff --git a/src/arch/x86/isa/insts/simd512/floating_point/data_conversion/vcvtsi2ss.py b/src/arch/x86/isa/insts/simd512/floating_point/data_conversion/vcvtsi2ss.py
new file mode 100644
index 0000000000..7e5bfe553e
--- /dev/null
+++ b/src/arch/x86/isa/insts/simd512/floating_point/data_conversion/vcvtsi2ss.py
@@ -0,0 +1,28 @@
+microcode = '''
+
+def macroop VCVTSI2SS_XMM_R {
+    mov2fp ufp1, regm, destSize=dsz, srcSize=dsz
+    cvti2f xmm0, ufp1, destSize=4, srcSize=dsz, ext=Scalar
+    movfph2h xmm0, xmm0v, dataSize=4
+    movfp  xmm1, xmm1v, dataSize=8
+    vclear dest=xmm2, destVL=16
+};
+
+def macroop VCVTSI2SS_XMM_M {
+    ldfp ufp1, seg, sib, disp, dataSize=dsz
+    cvti2f xmm0, ufp1, destSize=4, srcSize=dsz, ext=Scalar
+    movfph2h xmm0, xmm0v, dataSize=4
+    movfp  xmm1, xmm1v, dataSize=8
+    vclear dest=xmm2, destVL=16
+};
+
+def macroop VCVTSI2SS_XMM_P {
+    rdip t7
+    ldfp ufp1, seg, riprel, disp, dataSize=dsz
+    cvti2f xmm0, ufp1, destSize=4, srcSize=dsz, ext=Scalar
+    movfph2h xmm0, xmm0v, dataSize=4
+    movfp  xmm1, xmm1v, dataSize=8
+    vclear dest=xmm2, destVL=16
+};
+
+'''
\ No newline at end of file
diff --git a/src/arch/x86/isa/insts/simd512/floating_point/data_conversion/vcvtss2sd.py b/src/arch/x86/isa/insts/simd512/floating_point/data_conversion/vcvtss2sd.py
new file mode 100644
index 0000000000..6a8bf42c20
--- /dev/null
+++ b/src/arch/x86/isa/insts/simd512/floating_point/data_conversion/vcvtss2sd.py
@@ -0,0 +1,24 @@
+microcode = '''
+
+def macroop VCVTSS2SD_XMM_XMM {
+    cvtf2f xmm0, xmm0m, destSize=8, srcSize=4, ext=Scalar
+    movfp  xmm1, xmm1v, dataSize=8
+    vclear dest=xmm2, destVL=16
+};
+
+def macroop VCVTSS2SD_XMM_M {
+    ldfp ufp1, seg, sib, "DISPLACEMENT + 0", dataSize=4
+    cvtf2f xmm0, ufp1, destSize=8, srcSize=4, ext=Scalar
+    movfp  xmm1, xmm1v, dataSize=8
+    vclear dest=xmm2, destVL=16
+};
+
+def macroop VCVTSS2SD_XMM_P {
+    rdip t7
+    ldfp ufp1, seg, riprel, "DISPLACEMENT + 0", dataSize=4
+    cvtf2f xmm0, ufp1, destSize=8, srcSize=4, ext=Scalar
+    movfp  xmm1, xmm1v, dataSize=8
+    vclear dest=xmm2, destVL=16
+};
+
+'''
\ No newline at end of file
diff --git a/src/arch/x86/isa/insts/simd512/floating_point/data_conversion/vcvttss2si.py b/src/arch/x86/isa/insts/simd512/floating_point/data_conversion/vcvttss2si.py
new file mode 100644
index 0000000000..8538899b5a
--- /dev/null
+++ b/src/arch/x86/isa/insts/simd512/floating_point/data_conversion/vcvttss2si.py
@@ -0,0 +1,21 @@
+microcode = '''
+
+def macroop VCVTTSS2SI_R_XMM {
+    cvtf2i ufp1, xmm0m, srcSize=4, destSize=dsz, ext=Scalar
+    mov2int reg, ufp1, size=dsz
+};
+
+def macroop VCVTTSS2SI_R_M {
+    ldfp ufp1, seg, sib, disp, dataSize=4
+    cvtf2i ufp1, ufp1, srcSize=4, destSize=dsz, ext=Scalar
+    mov2int reg, ufp1, size=dsz
+};
+
+def macroop VCVTTSS2SI_R_P {
+    rdip t7
+    ldfp ufp1, seg, riprel, disp, dataSize=4
+    cvtf2i ufp1, ufp1, srcSize=4, destSize=dsz, ext=Scalar
+    mov2int reg, ufp1, size=dsz
+};
+
+'''
\ No newline at end of file
diff --git a/src/arch/x86/isa/insts/simd512/floating_point/data_conversion/vcvtusi2ss.py b/src/arch/x86/isa/insts/simd512/floating_point/data_conversion/vcvtusi2ss.py
new file mode 100644
index 0000000000..1a6776fdab
--- /dev/null
+++ b/src/arch/x86/isa/insts/simd512/floating_point/data_conversion/vcvtusi2ss.py
@@ -0,0 +1,28 @@
+microcode = '''
+
+def macroop VCVTUSI2SS_XMM_R {
+    mov2fp ufp1, regm, destSize=dsz, srcSize=dsz
+    cvtui2f xmm0, ufp1, destSize=4, srcSize=dsz, ext=Scalar
+    movfph2h xmm0, xmm0v, dataSize=4
+    movfp  xmm1, xmm1v, dataSize=8
+    vclear dest=xmm2, destVL=16
+};
+
+def macroop VCVTUSI2SS_XMM_M {
+    ldfp ufp1, seg, sib, disp, dataSize=dsz
+    cvtui2f xmm0, ufp1, destSize=4, srcSize=dsz, ext=Scalar
+    movfph2h xmm0, xmm0v, dataSize=4
+    movfp  xmm1, xmm1v, dataSize=8
+    vclear dest=xmm2, destVL=16
+};
+
+def macroop VCVTUSI2SS_XMM_P {
+    rdip t7
+    ldfp ufp1, seg, riprel, disp, dataSize=dsz
+    cvtui2f xmm0, ufp1, destSize=4, srcSize=dsz, ext=Scalar
+    movfph2h xmm0, xmm0v, dataSize=4
+    movfp  xmm1, xmm1v, dataSize=8
+    vclear dest=xmm2, destVL=16
+};
+
+'''
\ No newline at end of file
diff --git a/src/arch/x86/isa/insts/simd512/floating_point/data_transfer/__init__.py b/src/arch/x86/isa/insts/simd512/floating_point/data_transfer/__init__.py
new file mode 100644
index 0000000000..18c4129c88
--- /dev/null
+++ b/src/arch/x86/isa/insts/simd512/floating_point/data_transfer/__init__.py
@@ -0,0 +1,80 @@
+# Copyright (c) 2007 The Hewlett-Packard Development Company
+# All rights reserved.
+#
+# The license below extends only to copyright in the software and shall
+# not be construed as granting a license to any other intellectual
+# property including but not limited to intellectual property relating
+# to a hardware implementation of the functionality of the software
+# licensed hereunder.  You may use the software subject to the license
+# terms below provided that you ensure that this notice is replicated
+# unmodified and in its entirety in all distributions of the software,
+# modified or unmodified, in source code or in binary form.
+#
+# Redistribution and use in source and binary forms, with or without
+# modification, are permitted provided that the following conditions are
+# met: redistributions of source code must retain the above copyright
+# notice, this list of conditions and the following disclaimer;
+# redistributions in binary form must reproduce the above copyright
+# notice, this list of conditions and the following disclaimer in the
+# documentation and/or other materials provided with the distribution;
+# neither the name of the copyright holders nor the names of its
+# contributors may be used to endorse or promote products derived from
+# this software without specific prior written permission.
+#
+# THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS
+# "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT
+# LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR
+# A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT
+# OWNER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,
+# SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT
+# LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,
+# DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY
+# THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
+# (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE
+# OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
+#
+# Authors: Gabe Black
+
+categories = [
+    "valign",
+    "vcomiss",
+    "vpbroadcast",
+    "vbroadcastsd",
+    "vbroadcastss",
+    "vblendps",
+    "vextract",
+    "vinsertps",
+    "vinsert",
+    "vmovd",
+    "vmovlhps",
+    "vmovq",
+    "vmovhpd",
+    "vmovdqa",
+    "vmovddup",
+    "vmovdqu",
+    "vmovaps",
+    "vmovapd",
+    "vmovups",
+    "vmovupd",
+    "vmovss",
+    "vmovsd",
+    "vmovsldup",
+    "vmovshdup",
+    "vpmovdq",
+    "vblendps",
+    "vpermilps",
+    "vpermilpd",
+    "vpternlog",
+    "vpshufd",
+    "vpextrq",
+    "vshufps",
+    "vunpcks",
+    "vzeroupper",
+]
+
+microcode = '''
+# SSE instructions
+'''
+for category in categories:
+    exec("from . import {s} as cat".format(s=category))
+    microcode += cat.microcode
diff --git a/src/arch/x86/isa/insts/simd512/floating_point/data_transfer/valign.py b/src/arch/x86/isa/insts/simd512/floating_point/data_transfer/valign.py
new file mode 100644
index 0000000000..a0550813ae
--- /dev/null
+++ b/src/arch/x86/isa/insts/simd512/floating_point/data_transfer/valign.py
@@ -0,0 +1,106 @@
+microcode = '''
+
+def macroop VALIGND_XMM_XMM_I {
+    valign dest=xmm0, src1=xmm0v, src2=xmm0m, imm8="(IMMEDIATE) & 0x1", VL=16, size=4
+    vclear dest=xmm2, destVL=16
+};
+
+def macroop VALIGND_XMM_M_I {
+    ldfp512 ufp1, seg, sib, "DISPLACEMENT + 0", dataSize=16
+    valign dest=xmm0, src1=xmm0v, src2=ufp1, imm8="(IMMEDIATE) & 0x1", VL=16, size=4
+    vclear dest=xmm2, destVL=16
+};
+
+def macroop VALIGND_XMM_P_I {
+    rdip t7
+    ldfp512 ufp1, seg, riprel, "DISPLACEMENT + 0", dataSize=16
+    valign dest=xmm0, src1=xmm0v, src2=ufp1, imm8="(IMMEDIATE) & 0x1", VL=16, size=4
+    vclear dest=xmm2, destVL=16
+};
+
+def macroop VALIGND_YMM_YMM_I {
+    valign dest=xmm0, src1=xmm0v, src2=xmm0m, imm8="(IMMEDIATE) & 0x3", VL=32, size=4
+    vclear dest=xmm4, destVL=32
+};
+
+def macroop VALIGND_YMM_M_I {
+    ldfp512 ufp1, seg, sib, "DISPLACEMENT + 0", dataSize=32
+    valign dest=xmm0, src1=xmm0v, src2=ufp1, imm8="(IMMEDIATE) & 0x3", VL=32, size=4
+    vclear dest=xmm4, destVL=32
+};
+
+def macroop VALIGND_YMM_P_I {
+    rdip t7
+    ldfp512 ufp1, seg, riprel, "DISPLACEMENT + 0", dataSize=32
+    valign dest=xmm0, src1=xmm0v, src2=ufp1, imm8="(IMMEDIATE) & 0x3", VL=32, size=4
+    vclear dest=xmm4, destVL=32
+};
+
+def macroop VALIGND_ZMM_ZMM_I {
+    valign dest=xmm0, src1=xmm0v, src2=xmm0m, imm8="(IMMEDIATE) & 0x7", VL=64, size=4
+};
+
+def macroop VALIGND_ZMM_M_I {
+    ldfp512 ufp1, seg, sib, "DISPLACEMENT + 0", dataSize=64
+    valign dest=xmm0, src1=xmm0v, src2=ufp1, imm8="(IMMEDIATE) & 0x7", VL=64, size=4
+};
+
+def macroop VALIGND_ZMM_P_I {
+    rdip t7
+    ldfp512 ufp1, seg, riprel, "DISPLACEMENT + 0", dataSize=64
+    valign dest=xmm0, src1=xmm0v, src2=ufp1, imm8="(IMMEDIATE) & 0x7", VL=64, size=4
+};
+
+def macroop VALIGNQ_XMM_XMM_I {
+    valign dest=xmm0, src1=xmm0v, src2=xmm0m, imm8="(IMMEDIATE) & 0x1", VL=16, size=8
+    vclear dest=xmm2, destVL=16
+};
+
+def macroop VALIGNQ_XMM_M_I {
+    ldfp512 ufp1, seg, sib, "DISPLACEMENT + 0", dataSize=16
+    valign dest=xmm0, src1=xmm0v, src2=ufp1, imm8="(IMMEDIATE) & 0x1", VL=16, size=8
+    vclear dest=xmm2, destVL=16
+};
+
+def macroop VALIGNQ_XMM_P_I {
+    rdip t7
+    ldfp512 ufp1, seg, riprel, "DISPLACEMENT + 0", dataSize=16
+    valign dest=xmm0, src1=xmm0v, src2=ufp1, imm8="(IMMEDIATE) & 0x1", VL=16, size=8
+    vclear dest=xmm2, destVL=16
+};
+
+def macroop VALIGNQ_YMM_YMM_I {
+    valign dest=xmm0, src1=xmm0v, src2=xmm0m, imm8="(IMMEDIATE) & 0x3", VL=32, size=8
+    vclear dest=xmm4, destVL=32
+};
+
+def macroop VALIGNQ_YMM_M_I {
+    ldfp512 ufp1, seg, sib, "DISPLACEMENT + 0", dataSize=32
+    valign dest=xmm0, src1=xmm0v, src2=ufp1, imm8="(IMMEDIATE) & 0x3", VL=32, size=8
+    vclear dest=xmm4, destVL=32
+};
+
+def macroop VALIGNQ_YMM_P_I {
+    rdip t7
+    ldfp512 ufp1, seg, riprel, "DISPLACEMENT + 0", dataSize=32
+    valign dest=xmm0, src1=xmm0v, src2=ufp1, imm8="(IMMEDIATE) & 0x3", VL=32, size=8
+    vclear dest=xmm4, destVL=32
+};
+
+def macroop VALIGNQ_ZMM_ZMM_I {
+    valign dest=xmm0, src1=xmm0v, src2=xmm0m, imm8="(IMMEDIATE) & 0x7", VL=64, size=8
+};
+
+def macroop VALIGNQ_ZMM_M_I {
+    ldfp512 ufp1, seg, sib, "DISPLACEMENT + 0", dataSize=64
+    valign dest=xmm0, src1=xmm0v, src2=ufp1, imm8="(IMMEDIATE) & 0x7", VL=64, size=8
+};
+
+def macroop VALIGNQ_ZMM_P_I {
+    rdip t7
+    ldfp512 ufp1, seg, riprel, "DISPLACEMENT + 0", dataSize=64
+    valign dest=xmm0, src1=xmm0v, src2=ufp1, imm8="(IMMEDIATE) & 0x7", VL=64, size=8
+};
+
+
+'''
\ No newline at end of file
diff --git a/src/arch/x86/isa/insts/simd512/floating_point/data_transfer/vblendps.py b/src/arch/x86/isa/insts/simd512/floating_point/data_transfer/vblendps.py
new file mode 100644
index 0000000000..1cfc35ef80
--- /dev/null
+++ b/src/arch/x86/isa/insts/simd512/floating_point/data_transfer/vblendps.py
@@ -0,0 +1,51 @@
+microcode = '''
+
+def macroop VBLENDPS_XMM_XMM_I {
+    mblend dest=xmm0, src1=xmm0v, op2=xmm0m, size=4, ext="(IMMEDIATE >> 0) & 0x3"
+    mblend dest=xmm1, src1=xmm1v, op2=xmm1m, size=4, ext="(IMMEDIATE >> 2) & 0x3"
+    vclear dest=xmm2, destVL=16
+};
+
+def macroop VBLENDPS_XMM_M_I {
+    ldfp128 ufp1, seg, sib, "DISPLACEMENT + 0", dataSize=16
+    mblend dest=xmm0, src1=xmm0v, op2=ufp1, size=4, ext="(IMMEDIATE >> 0) & 0x3"
+    mblend dest=xmm1, src1=xmm1v, op2=ufp2, size=4, ext="(IMMEDIATE >> 2) & 0x3"
+    vclear dest=xmm2, destVL=16
+};
+
+def macroop VBLENDPS_XMM_P_I {
+    rdip t7
+    ldfp128 ufp1, seg, riprel, "DISPLACEMENT + 0", dataSize=16
+    mblend dest=xmm0, src1=xmm0v, op2=ufp1, size=4, ext="(IMMEDIATE >> 0) & 0x3"
+    mblend dest=xmm1, src1=xmm1v, op2=ufp2, size=4, ext="(IMMEDIATE >> 2) & 0x3"
+    vclear dest=xmm2, destVL=16
+};
+
+def macroop VBLENDPS_YMM_YMM_I {
+    mblend dest=xmm0, src1=xmm0v, op2=xmm0m, size=4, ext="(IMMEDIATE >> 0) & 0x3"
+    mblend dest=xmm1, src1=xmm1v, op2=xmm1m, size=4, ext="(IMMEDIATE >> 2) & 0x3"
+    mblend dest=xmm2, src1=xmm2v, op2=xmm2m, size=4, ext="(IMMEDIATE >> 4) & 0x3"
+    mblend dest=xmm3, src1=xmm3v, op2=xmm3m, size=4, ext="(IMMEDIATE >> 6) & 0x3"
+    vclear dest=xmm4, destVL=32
+};
+
+def macroop VBLENDPS_YMM_M_I {
+    ldfp256 ufp1, seg, sib, "DISPLACEMENT + 0", dataSize=32
+    mblend dest=xmm0, src1=xmm0v, op2=ufp1, size=4, ext="(IMMEDIATE >> 0) & 0x3"
+    mblend dest=xmm1, src1=xmm1v, op2=ufp2, size=4, ext="(IMMEDIATE >> 2) & 0x3"
+    mblend dest=xmm2, src1=xmm2v, op2=ufp3, size=4, ext="(IMMEDIATE >> 4) & 0x3"
+    mblend dest=xmm3, src1=xmm3v, op2=ufp4, size=4, ext="(IMMEDIATE >> 6) & 0x3"
+    vclear dest=xmm4, destVL=32
+};
+
+def macroop VBLENDPS_YMM_P_I {
+    rdip t7
+    ldfp256 ufp1, seg, riprel, "DISPLACEMENT + 0", dataSize=32
+    mblend dest=xmm0, src1=xmm0v, op2=ufp1, size=4, ext="(IMMEDIATE >> 0) & 0x3"
+    mblend dest=xmm1, src1=xmm1v, op2=ufp2, size=4, ext="(IMMEDIATE >> 2) & 0x3"
+    mblend dest=xmm2, src1=xmm2v, op2=ufp3, size=4, ext="(IMMEDIATE >> 4) & 0x3"
+    mblend dest=xmm3, src1=xmm3v, op2=ufp4, size=4, ext="(IMMEDIATE >> 6) & 0x3"
+    vclear dest=xmm4, destVL=32
+};
+
+'''
\ No newline at end of file
diff --git a/src/arch/x86/isa/insts/simd512/floating_point/data_transfer/vbroadcastsd.py b/src/arch/x86/isa/insts/simd512/floating_point/data_transfer/vbroadcastsd.py
new file mode 100644
index 0000000000..dd4f557c2a
--- /dev/null
+++ b/src/arch/x86/isa/insts/simd512/floating_point/data_transfer/vbroadcastsd.py
@@ -0,0 +1,66 @@
+microcode = '''
+
+def macroop VBROADCASTSD_YMM_XMM {
+    movfp dest=xmm0, src1=xmm0m, dataSize=8
+    movfp dest=xmm1, src1=xmm0m, dataSize=8
+    movfp dest=xmm2, src1=xmm0m, dataSize=8
+    movfp dest=xmm3, src1=xmm0m, dataSize=8
+    vclear dest=xmm4, destVL=32
+};
+
+def macroop VBROADCASTSD_YMM_M {
+    ldfp ufp1, seg, sib, disp, dataSize=8
+    movfp dest=xmm0, src1=ufp1, dataSize=8
+    movfp dest=xmm1, src1=ufp1, dataSize=8
+    movfp dest=xmm2, src1=ufp1, dataSize=8
+    movfp dest=xmm3, src1=ufp1, dataSize=8
+    vclear dest=xmm4, destVL=32
+};
+
+def macroop VBROADCASTSD_YMM_P {
+    rdip t7
+    ldfp ufp1, seg, riprel, disp, dataSize=8
+    movfp dest=xmm0, src1=ufp1, dataSize=8
+    movfp dest=xmm1, src1=ufp1, dataSize=8
+    movfp dest=xmm2, src1=ufp1, dataSize=8
+    movfp dest=xmm3, src1=ufp1, dataSize=8
+    vclear dest=xmm4, destVL=32
+};
+
+def macroop VBROADCASTSD_ZMM_XMM {
+    movfp dest=xmm0, src1=xmm0m, dataSize=8
+    movfp dest=xmm1, src1=xmm0m, dataSize=8
+    movfp dest=xmm2, src1=xmm0m, dataSize=8
+    movfp dest=xmm3, src1=xmm0m, dataSize=8
+    movfp dest=xmm4, src1=xmm0m, dataSize=8
+    movfp dest=xmm5, src1=xmm0m, dataSize=8
+    movfp dest=xmm6, src1=xmm0m, dataSize=8
+    movfp dest=xmm7, src1=xmm0m, dataSize=8
+};
+
+def macroop VBROADCASTSD_ZMM_M {
+    ldfp ufp1, seg, sib, disp, dataSize=8
+    movfp dest=xmm0, src1=ufp1, dataSize=8
+    movfp dest=xmm1, src1=ufp1, dataSize=8
+    movfp dest=xmm2, src1=ufp1, dataSize=8
+    movfp dest=xmm3, src1=ufp1, dataSize=8
+    movfp dest=xmm4, src1=ufp1, dataSize=8
+    movfp dest=xmm5, src1=ufp1, dataSize=8
+    movfp dest=xmm6, src1=ufp1, dataSize=8
+    movfp dest=xmm7, src1=ufp1, dataSize=8
+};
+
+def macroop VBROADCASTSD_ZMM_P {
+    rdip t7
+    ldfp ufp1, seg, riprel, disp, dataSize=8
+    movfp dest=xmm0, src1=ufp1, dataSize=8
+    movfp dest=xmm1, src1=ufp1, dataSize=8
+    movfp dest=xmm2, src1=ufp1, dataSize=8
+    movfp dest=xmm3, src1=ufp1, dataSize=8
+    movfp dest=xmm4, src1=ufp1, dataSize=8
+    movfp dest=xmm5, src1=ufp1, dataSize=8
+    movfp dest=xmm6, src1=ufp1, dataSize=8
+    movfp dest=xmm7, src1=ufp1, dataSize=8
+};
+
+'''
\ No newline at end of file
diff --git a/src/arch/x86/isa/insts/simd512/floating_point/data_transfer/vbroadcastss.py b/src/arch/x86/isa/insts/simd512/floating_point/data_transfer/vbroadcastss.py
new file mode 100644
index 0000000000..f20a96d8dd
--- /dev/null
+++ b/src/arch/x86/isa/insts/simd512/floating_point/data_transfer/vbroadcastss.py
@@ -0,0 +1,87 @@
+microcode = '''
+
+def macroop VBROADCASTSS_XMM_XMM {
+    mmovsdup dest=xmm0, src1=xmm0m, size=4, ext=0
+    mmovsdup dest=xmm1, src1=xmm0m, size=4, ext=0
+    vclear dest=xmm2, destVL=16
+};
+
+def macroop VBROADCASTSS_XMM_M {
+    ldfp ufp1, seg, sib, disp, dataSize=4
+    mmovsdup dest=xmm0, src1=ufp1, size=4, ext=0
+    mmovsdup dest=xmm1, src1=ufp1, size=4, ext=0
+    vclear dest=xmm2, destVL=16
+};
+
+def macroop VBROADCASTSS_XMM_P {
+    rdip t7
+    ldfp ufp1, seg, riprel, disp, dataSize=4
+    mmovsdup dest=xmm0, src1=ufp1, size=4, ext=0
+    mmovsdup dest=xmm1, src1=ufp1, size=4, ext=0
+    vclear dest=xmm2, destVL=16
+};
+
+def macroop VBROADCASTSS_YMM_XMM {
+    mmovsdup dest=xmm0, src1=xmm0m, size=4, ext=0
+    mmovsdup dest=xmm1, src1=xmm0m, size=4, ext=0
+    mmovsdup dest=xmm2, src1=xmm0m, size=4, ext=0
+    mmovsdup dest=xmm3, src1=xmm0m, size=4, ext=0
+    vclear dest=xmm4, destVL=32
+};
+
+def macroop VBROADCASTSS_YMM_M {
+    ldfp ufp1, seg, sib, disp, dataSize=4
+    mmovsdup dest=xmm0, src1=ufp1, size=4, ext=0
+    mmovsdup dest=xmm1, src1=ufp1, size=4, ext=0
+    mmovsdup dest=xmm2, src1=ufp1, size=4, ext=0
+    mmovsdup dest=xmm3, src1=ufp1, size=4, ext=0
+    vclear dest=xmm4, destVL=32
+};
+
+def macroop VBROADCASTSS_YMM_P {
+    rdip t7
+    ldfp ufp1, seg, riprel, disp, dataSize=4
+    mmovsdup dest=xmm0, src1=ufp1, size=4, ext=0
+    mmovsdup dest=xmm1, src1=ufp1, size=4, ext=0
+    mmovsdup dest=xmm2, src1=ufp1, size=4, ext=0
+    mmovsdup dest=xmm3, src1=ufp1, size=4, ext=0
+    vclear dest=xmm4, destVL=32
+};
+
+def macroop VBROADCASTSS_ZMM_XMM {
+    mmovsdup dest=xmm0, src1=xmm0m, size=4, ext=0
+    mmovsdup dest=xmm1, src1=xmm0m, size=4, ext=0
+    mmovsdup dest=xmm2, src1=xmm0m, size=4, ext=0
+    mmovsdup dest=xmm3, src1=xmm0m, size=4, ext=0
+    mmovsdup dest=xmm4, src1=xmm0m, size=4, ext=0
+    mmovsdup dest=xmm5, src1=xmm0m, size=4, ext=0
+    mmovsdup dest=xmm6, src1=xmm0m, size=4, ext=0
+    mmovsdup dest=xmm7, src1=xmm0m, size=4, ext=0
+};
+
+def macroop VBROADCASTSS_ZMM_M {
+    ldfp ufp1, seg, sib, disp, dataSize=4
+    mmovsdup dest=xmm0, src1=ufp1, size=4, ext=0
+    mmovsdup dest=xmm1, src1=ufp1, size=4, ext=0
+    mmovsdup dest=xmm2, src1=ufp1, size=4, ext=0
+    mmovsdup dest=xmm3, src1=ufp1, size=4, ext=0
+    mmovsdup dest=xmm4, src1=ufp1, size=4, ext=0
+    mmovsdup dest=xmm5, src1=ufp1, size=4, ext=0
+    mmovsdup dest=xmm6, src1=ufp1, size=4, ext=0
+    mmovsdup dest=xmm7, src1=ufp1, size=4, ext=0
+};
+
+def macroop VBROADCASTSS_ZMM_P {
+    rdip t7
+    ldfp ufp1, seg, riprel, disp, dataSize=4
+    mmovsdup dest=xmm0, src1=ufp1, size=4, ext=0
+    mmovsdup dest=xmm1, src1=ufp1, size=4, ext=0
+    mmovsdup dest=xmm2, src1=ufp1, size=4, ext=0
+    mmovsdup dest=xmm3, src1=ufp1, size=4, ext=0
+    mmovsdup dest=xmm4, src1=ufp1, size=4, ext=0
+    mmovsdup dest=xmm5, src1=ufp1, size=4, ext=0
+    mmovsdup dest=xmm6, src1=ufp1, size=4, ext=0
+    mmovsdup dest=xmm7, src1=ufp1, size=4, ext=0
+};
+
+'''
\ No newline at end of file
diff --git a/src/arch/x86/isa/insts/simd512/floating_point/data_transfer/vcomiss.py b/src/arch/x86/isa/insts/simd512/floating_point/data_transfer/vcomiss.py
new file mode 100644
index 0000000000..4efcc965d7
--- /dev/null
+++ b/src/arch/x86/isa/insts/simd512/floating_point/data_transfer/vcomiss.py
@@ -0,0 +1,19 @@
+microcode = '''
+
+def macroop VCOMISS_XMM_XMM {
+    mcmpf2rf xmm0, xmm0m, size=4
+};
+
+def macroop VCOMISS_XMM_M {
+    ldfp ufp1, seg, sib, disp, dataSize=8
+    mcmpf2rf xmm0, ufp1, size=4
+};
+
+def macroop VCOMISS_XMM_P {
+    rdip t7
+    ldfp ufp1, seg, riprel, disp, dataSize=8
+    mcmpf2rf xmm0, ufp1, size=4
+};
+
+
+'''
\ No newline at end of file
diff --git a/src/arch/x86/isa/insts/simd512/floating_point/data_transfer/vextract.py b/src/arch/x86/isa/insts/simd512/floating_point/data_transfer/vextract.py
new file mode 100644
index 0000000000..d7b1cab622
--- /dev/null
+++ b/src/arch/x86/isa/insts/simd512/floating_point/data_transfer/vextract.py
@@ -0,0 +1,109 @@
+microcode = '''
+
+def macroop VEXTRACT256L_YMM_ZMM_I {
+    movfp xmm0, xmm0m, dataSize=8
+    movfp xmm1, xmm1m, dataSize=8
+    movfp xmm2, xmm2m, dataSize=8
+    movfp xmm3, xmm3m, dataSize=8
+    vclear dest=xmm4, destVL=32
+};
+
+def macroop VEXTRACT256L_M_ZMM_I {
+    stfp256 xmm0, seg, sib, "DISPLACEMENT + 0", dataSize=32
+};
+
+def macroop VEXTRACT256L_P_ZMM_I {
+    rdip t7
+    stfp256 xmm0, seg, riprel, "DISPLACEMENT + 0", dataSize=32
+};
+
+def macroop VEXTRACT256H_YMM_ZMM_I {
+    movfp xmm0, xmm4m, dataSize=8
+    movfp xmm1, xmm5m, dataSize=8
+    movfp xmm2, xmm6m, dataSize=8
+    movfp xmm3, xmm7m, dataSize=8
+    vclear dest=xmm4, destVL=32
+};
+
+def macroop VEXTRACT256H_M_ZMM_I {
+    stfp xmm4, seg, sib, "DISPLACEMENT + 0", dataSize=8
+    stfp xmm5, seg, sib, "DISPLACEMENT + 8", dataSize=8
+    stfp xmm6, seg, sib, "DISPLACEMENT + 16", dataSize=8
+    stfp xmm7, seg, sib, "DISPLACEMENT + 24", dataSize=8
+};
+
+def macroop VEXTRACT256H_P_ZMM_I {
+    rdip t7
+    stfp xmm4, seg, riprel, "DISPLACEMENT + 0", dataSize=8
+    stfp xmm5, seg, riprel, "DISPLACEMENT + 8", dataSize=8
+    stfp xmm6, seg, riprel, "DISPLACEMENT + 16", dataSize=8
+    stfp xmm7, seg, riprel, "DISPLACEMENT + 24", dataSize=8
+};
+
+def macroop VEXTRACT128L_XMM_YMM_I {
+    movfp xmm0, xmm0m, dataSize=8
+    movfp xmm1, xmm1m, dataSize=8
+    vclear dest=xmm2, destVL=16
+};
+
+def macroop VEXTRACT128L_M_YMM_I {
+    stfp128 xmm0, seg, sib, "DISPLACEMENT + 0", dataSize=16
+};
+
+def macroop VEXTRACT128L_P_YMM_I {
+    rdip t7
+    stfp128 xmm0, seg, riprel, "DISPLACEMENT + 0", dataSize=16
+};
+
+def macroop VEXTRACT128H_XMM_YMM_I {
+    movfp dest=xmm0, src1=xmm2m, dataSize=8
+    movfp dest=xmm1, src1=xmm3m, dataSize=8
+    vclear dest=xmm2, destVL=16
+};
+
+def macroop VEXTRACT128H_M_YMM_I {
+    stfp xmm2, seg, sib, "DISPLACEMENT + 0", dataSize=8
+    stfp xmm3, seg, sib, "DISPLACEMENT + 8", dataSize=8
+};
+
+def macroop VEXTRACT128H_P_YMM_I {
+    rdip t7
+    stfp xmm2, seg, riprel, "DISPLACEMENT + 0", dataSize=8
+    stfp xmm3, seg, riprel, "DISPLACEMENT + 8", dataSize=8
+};
+
+def macroop VEXTRACT128HL_XMM_ZMM_I {
+    movfp xmm0, xmm4m, dataSize=8
+    movfp xmm1, xmm5m, dataSize=8
+    vclear dest=xmm2, destVL=16
+};
+
+def macroop VEXTRACT128HL_M_ZMM_I {
+    stfp xmm4, seg, sib, "DISPLACEMENT + 0", dataSize=8
+    stfp xmm5, seg, sib, "DISPLACEMENT + 8", dataSize=8
+};
+
+def macroop VEXTRACT128HL_P_ZMM_I {
+    rdip t7
+    stfp xmm4, seg, riprel, "DISPLACEMENT + 0", dataSize=8
+    stfp xmm5, seg, riprel, "DISPLACEMENT + 8", dataSize=8
+};
+
+def macroop VEXTRACT128HH_XMM_ZMM_I {
+    movfp xmm0, xmm6m, dataSize=8
+    movfp xmm1, xmm7m, dataSize=8
+    vclear dest=xmm2, destVL=16
+};
+
+def macroop VEXTRACT128HH_M_ZMM_I {
+    stfp xmm6, seg, sib, "DISPLACEMENT + 0", dataSize=8
+    stfp xmm7, seg, sib, "DISPLACEMENT + 8", dataSize=8
+};
+
+def macroop VEXTRACT128HH_P_ZMM_I {
+    rdip t7
+    stfp xmm6, seg, riprel, "DISPLACEMENT + 0", dataSize=8
+    stfp xmm7, seg, riprel, "DISPLACEMENT + 8", dataSize=8
+};
+
+'''
\ No newline at end of file
diff --git a/src/arch/x86/isa/insts/simd512/floating_point/data_transfer/vinsert.py b/src/arch/x86/isa/insts/simd512/floating_point/data_transfer/vinsert.py
new file mode 100644
index 0000000000..60177aa6c2
--- /dev/null
+++ b/src/arch/x86/isa/insts/simd512/floating_point/data_transfer/vinsert.py
@@ -0,0 +1,113 @@
+microcode = '''
+
+def macroop VINSERT128L_YMM_XMM_I {
+    movfp xmm0, xmm0m, dataSize=8
+    movfp xmm1, xmm1m, dataSize=8
+    movfp xmm2, xmm2v, dataSize=8
+    movfp xmm3, xmm3v, dataSize=8
+    vclear dest=xmm4, destVL=32
+};
+
+def macroop VINSERT128L_YMM_M_I {
+    ldfp128 xmm0, seg, sib, "DISPLACEMENT + 0", dataSize=16
+    movfp xmm2, xmm2v, dataSize=8
+    movfp xmm3, xmm3v, dataSize=8
+    vclear dest=xmm4, destVL=32
+};
+
+def macroop VINSERT128L_YMM_P_I {
+    rdip t7
+    ldfp128 xmm0, seg, riprel, "DISPLACEMENT + 0", dataSize=16
+    movfp xmm2, xmm2v, dataSize=8
+    movfp xmm3, xmm3v, dataSize=8
+    vclear dest=xmm4, destVL=32
+};
+
+def macroop VINSERT128H_YMM_XMM_I {
+    movfp xmm2, xmm0m, dataSize=8
+    movfp xmm3, xmm1m, dataSize=8
+    movfp xmm0, xmm0v, dataSize=8
+    movfp xmm1, xmm1v, dataSize=8
+    vclear dest=xmm4, destVL=32
+};
+
+def macroop VINSERT128H_YMM_M_I {
+    movfp xmm0, xmm0v, dataSize=8
+    movfp xmm1, xmm1v, dataSize=8
+    ldfp xmm2, seg, sib, "DISPLACEMENT + 0", dataSize=8
+    ldfp xmm3, seg, sib, "DISPLACEMENT + 8", dataSize=8
+    vclear dest=xmm4, destVL=32
+};
+
+def macroop VINSERT128H_YMM_P_I {
+    movfp xmm0, xmm0v, dataSize=8
+    movfp xmm1, xmm1v, dataSize=8
+    rdip t7
+    ldfp xmm2, seg, riprel, "DISPLACEMENT + 0", dataSize=8
+    ldfp xmm3, seg, riprel, "DISPLACEMENT + 8", dataSize=8
+    vclear dest=xmm4, destVL=32
+};
+
+def macroop VINSERT256L_ZMM_YMM_I {
+    movfp xmm0, xmm0m, dataSize=8
+    movfp xmm1, xmm1m, dataSize=8
+    movfp xmm2, xmm2m, dataSize=8
+    movfp xmm3, xmm3m, dataSize=8
+    movfp xmm4, xmm4v, dataSize=8
+    movfp xmm5, xmm5v, dataSize=8
+    movfp xmm6, xmm6v, dataSize=8
+    movfp xmm7, xmm7v, dataSize=8
+};
+
+def macroop VINSERT256L_ZMM_M_I {
+    ldfp256 xmm0, seg, sib, "DISPLACEMENT + 0", dataSize=32
+    movfp xmm4, xmm4v, dataSize=8
+    movfp xmm5, xmm5v, dataSize=8
+    movfp xmm6, xmm6v, dataSize=8
+    movfp xmm7, xmm7v, dataSize=8
+};
+
+def macroop VINSERT256L_ZMM_P_I {
+    rdip t7
+    ldfp256 xmm0, seg, riprel, "DISPLACEMENT + 0", dataSize=32
+    movfp xmm4, xmm4v, dataSize=8
+    movfp xmm5, xmm5v, dataSize=8
+    movfp xmm6, xmm6v, dataSize=8
+    movfp xmm7, xmm7v, dataSize=8
+};
+
+def macroop VINSERT256H_ZMM_YMM_I {
+    movfp xmm4, xmm0m, dataSize=8
+    movfp xmm5, xmm1m, dataSize=8
+    movfp xmm6, xmm2m, dataSize=8
+    movfp xmm7, xmm3m, dataSize=8
+    movfp xmm0, xmm0v, dataSize=8
+    movfp xmm1, xmm1v, dataSize=8
+    movfp xmm2, xmm2v, dataSize=8
+    movfp xmm3, xmm3v, dataSize=8
+};
+
+def macroop VINSERT256H_ZMM_M_I {
+    movfp xmm0, xmm0v, dataSize=8
+    movfp xmm1, xmm1v, dataSize=8
+    movfp xmm2, xmm2v, dataSize=8
+    movfp xmm3, xmm3v, dataSize=8
+    ldfp xmm4, seg, sib, "DISPLACEMENT + 0", dataSize=8
+    ldfp xmm5, seg, sib, "DISPLACEMENT + 8", dataSize=8
+    ldfp xmm6, seg, sib, "DISPLACEMENT + 16", dataSize=8
+    ldfp xmm7, seg, sib, "DISPLACEMENT + 24", dataSize=8
+};
+
+def macroop VINSERT256H_ZMM_P_I {
+    movfp xmm0, xmm0v, dataSize=8
+    movfp xmm1, xmm1v, dataSize=8
+    movfp xmm2, xmm2v, dataSize=8
+    movfp xmm3, xmm3v, dataSize=8
+    rdip t7
+    ldfp xmm4, seg, riprel, "DISPLACEMENT + 0", dataSize=8
+    ldfp xmm5, seg, riprel, "DISPLACEMENT + 8", dataSize=8
+    ldfp xmm6, seg, riprel, "DISPLACEMENT + 16", dataSize=8
+    ldfp xmm7, seg, riprel, "DISPLACEMENT + 24", dataSize=8
+};
+
+'''
\ No newline at end of file
diff --git a/src/arch/x86/isa/insts/simd512/floating_point/data_transfer/vinsertps.py b/src/arch/x86/isa/insts/simd512/floating_point/data_transfer/vinsertps.py
new file mode 100644
index 0000000000..16a7de5bc4
--- /dev/null
+++ b/src/arch/x86/isa/insts/simd512/floating_point/data_transfer/vinsertps.py
@@ -0,0 +1,32 @@
+microcode = '''
+
+def macroop VINSERTPS_XMM_XMM_I {
+    movfp ufp1, xmm0m, dataSize=8
+    movfp ufp2, xmm1m, dataSize=8
+    movfp xmm0, xmm0v, dataSize=8
+    movfp xmm1, xmm1v, dataSize=8
+    minsertpsl dest=xmm0, src1=ufp1, op2=ufp2, size=4, ext="(IMMEDIATE & 0xFF)"
+    minsertpsh dest=xmm1, src1=ufp1, op2=ufp2, size=4, ext="(IMMEDIATE & 0xFF)"
+    vclear dest=xmm2, destVL=16
+};
+
+def macroop VINSERTPS_XMM_M_I {
+    movfp xmm0, xmm0v, dataSize=8
+    movfp xmm1, xmm1v, dataSize=8
+    ldfp ufp1, seg, sib, "DISPLACEMENT + 0", dataSize=4
+    minsertpsl dest=xmm0, src1=ufp1, op2=ufp1, size=4, ext="(IMMEDIATE & 0x3F)"
+    minsertpsh dest=xmm1, src1=ufp1, op2=ufp1, size=4, ext="(IMMEDIATE & 0x3F)"
+    vclear dest=xmm2, destVL=16
+};
+
+def macroop VINSERTPS_XMM_P_I {
+    movfp xmm0, xmm0v, dataSize=8
+    movfp xmm1, xmm1v, dataSize=8
+    rdip t7
+    ldfp ufp1, seg, riprel, "DISPLACEMENT + 0", dataSize=4
+    minsertpsl dest=xmm0, src1=ufp1, op2=ufp1, size=4, ext="(IMMEDIATE & 0x3F)"
+    minsertpsh dest=xmm1, src1=ufp1, op2=ufp1, size=4, ext="(IMMEDIATE & 0x3F)"
+    vclear dest=xmm2, destVL=16
+};
+
+'''
\ No newline at end of file
diff --git a/src/arch/x86/isa/insts/simd512/floating_point/data_transfer/vmovapd.py b/src/arch/x86/isa/insts/simd512/floating_point/data_transfer/vmovapd.py
new file mode 100644
index 0000000000..6f178e649f
--- /dev/null
+++ b/src/arch/x86/isa/insts/simd512/floating_point/data_transfer/vmovapd.py
@@ -0,0 +1,74 @@
+microcode = '''
+def macroop VMOVAPD_XMM_XMM {
+    movfp128 dest=xmm0, src1=xmm0m, dataSize=16
+    vclear dest=xmm2, destVL=16
+};
+
+def macroop VMOVAPD_XMM_M {
+    ldfp128 xmm0, seg, sib, "DISPLACEMENT + 0", dataSize=16
+    vclear dest=xmm2, destVL=16
+};
+
+def macroop VMOVAPD_XMM_P {
+    rdip t7
+    ldfp128 xmm0, seg, riprel, "DISPLACEMENT + 0", dataSize=16
+    vclear dest=xmm2, destVL=16
+};
+
+def macroop VMOVAPD_M_XMM {
+    stfp128 xmm0, seg, sib, "DISPLACEMENT + 0", dataSize=16
+};
+
+def macroop VMOVAPD_P_XMM {
+    rdip t7
+    stfp128 xmm0, seg, riprel, "DISPLACEMENT + 0", dataSize=16
+};
+
+def macroop VMOVAPD_YMM_YMM {
+    movfp256 dest=xmm0, src1=xmm0m, dataSize=32
+    vclear dest=xmm4, destVL=32
+};
+
+def macroop VMOVAPD_YMM_M {
+    ldfp256 xmm0, seg, sib, "DISPLACEMENT + 0", dataSize=32
+    vclear dest=xmm4, destVL=32
+};
+
+def macroop VMOVAPD_YMM_P {
+    rdip t7
+    ldfp256 xmm0, seg, riprel, "DISPLACEMENT + 0", dataSize=32
+    vclear dest=xmm4, destVL=32
+};
+
+def macroop VMOVAPD_M_YMM {
+    stfp256 xmm0, seg, sib, "DISPLACEMENT + 0", dataSize=32
+};
+
+def macroop VMOVAPD_P_YMM {
+    rdip t7
+    stfp256 xmm0, seg, riprel, "DISPLACEMENT + 0", dataSize=32
+};
+
+def macroop VMOVAPD_ZMM_ZMM {
+    movfp512 dest=xmm0, src1=xmm0m, dataSize=64
+};
+
+def macroop VMOVAPD_ZMM_M {
+    ldfp512 xmm0, seg, sib, "DISPLACEMENT + 0", dataSize=64
+};
+
+def macroop VMOVAPD_ZMM_P {
+    rdip t7
+    ldfp512 xmm0, seg, riprel, "DISPLACEMENT + 0", dataSize=64
+};
+
+def macroop VMOVAPD_M_ZMM {
+    stfp512 xmm0, seg, sib, "DISPLACEMENT + 0", dataSize=64
+};
+
+def macroop VMOVAPD_P_ZMM {
+    rdip t7
+    stfp512 xmm0, seg, riprel, "DISPLACEMENT + 0", dataSize=64
+};
+
+'''
\ No newline at end of file
diff --git a/src/arch/x86/isa/insts/simd512/floating_point/data_transfer/vmovaps.py b/src/arch/x86/isa/insts/simd512/floating_point/data_transfer/vmovaps.py
new file mode 100644
index 0000000000..96a3006304
--- /dev/null
+++ b/src/arch/x86/isa/insts/simd512/floating_point/data_transfer/vmovaps.py
@@ -0,0 +1,75 @@
+microcode = '''
+
+def macroop VMOVAPS_XMM_XMM {
+    movfp128 dest=xmm0, src1=xmm0m, dataSize=16
+    vclear dest=xmm2, destVL=16
+};
+
+def macroop VMOVAPS_XMM_M {
+    ldfp128 xmm0, seg, sib, "DISPLACEMENT + 0", dataSize=16
+    vclear dest=xmm2, destVL=16
+};
+
+def macroop VMOVAPS_XMM_P {
+    rdip t7
+    ldfp128 xmm0, seg, riprel, "DISPLACEMENT + 0", dataSize=16
+    vclear dest=xmm2, destVL=16
+};
+
+def macroop VMOVAPS_M_XMM {
+    stfp128 xmm0, seg, sib, "DISPLACEMENT + 0", dataSize=16
+};
+
+def macroop VMOVAPS_P_XMM {
+    rdip t7
+    stfp128 xmm0, seg, riprel, "DISPLACEMENT + 0", dataSize=16
+};
+
+def macroop VMOVAPS_YMM_YMM {
+    movfp256 dest=xmm0, src1=xmm0m, dataSize=32
+    vclear dest=xmm4, destVL=32
+};
+
+def macroop VMOVAPS_YMM_M {
+    ldfp256 xmm0, seg, sib, "DISPLACEMENT + 0", dataSize=32
+    vclear dest=xmm4, destVL=32
+};
+
+def macroop VMOVAPS_YMM_P {
+    rdip t7
+    ldfp256 xmm0, seg, riprel, "DISPLACEMENT + 0", dataSize=32
+    vclear dest=xmm4, destVL=32
+};
+
+def macroop VMOVAPS_M_YMM {
+    stfp256 xmm0, seg, sib, "DISPLACEMENT + 0", dataSize=32
+};
+
+def macroop VMOVAPS_P_YMM {
+    rdip t7
+    stfp256 xmm0, seg, riprel, "DISPLACEMENT + 0", dataSize=32
+};
+
+def macroop VMOVAPS_ZMM_ZMM {
+    movfp512 dest=xmm0, src1=xmm0m, dataSize=64
+};
+
+def macroop VMOVAPS_ZMM_M {
+    ldfp512 xmm0, seg, sib, "DISPLACEMENT + 0", dataSize=64
+};
+
+def macroop VMOVAPS_ZMM_P {
+    rdip t7
+    ldfp512 xmm0, seg, riprel, "DISPLACEMENT + 0", dataSize=64
+};
+
+def macroop VMOVAPS_M_ZMM {
+    stfp512 xmm0, seg, sib, "DISPLACEMENT + 0", dataSize=64
+};
+
+def macroop VMOVAPS_P_ZMM {
+    rdip t7
+    stfp512 xmm0, seg, riprel, "DISPLACEMENT + 0", dataSize=64
+};
+
+'''
\ No newline at end of file
diff --git a/src/arch/x86/isa/insts/simd512/floating_point/data_transfer/vmovd.py b/src/arch/x86/isa/insts/simd512/floating_point/data_transfer/vmovd.py
new file mode 100644
index 0000000000..44f76a6121
--- /dev/null
+++ b/src/arch/x86/isa/insts/simd512/floating_point/data_transfer/vmovd.py
@@ -0,0 +1,32 @@
+microcode = '''
+
+def macroop VMOVD_XMM_R {
+    mov2fp xmm0, regm, srcSize=dsz, destSize=8
+    vclear dest=xmm1, destVL=8
+};
+
+def macroop VMOVD_XMM_M {
+    ldfp xmm0, seg, sib, disp, dataSize=dsz
+    vclear dest=xmm1, destVL=8
+};
+
+def macroop VMOVD_XMM_P {
+    rdip t7
+    ldfp xmm0, seg, riprel, disp, dataSize=dsz
+    vclear dest=xmm1, destVL=8
+};
+
+def macroop VMOVD_R_XMM {
+    mov2int reg, xmm0m, size=dsz
+};
+
+def macroop VMOVD_M_XMM {
+    stfp xmm0, seg, sib, disp, dataSize=dsz
+};
+
+def macroop VMOVD_P_XMM {
+    rdip t7
+    stfp xmm0, seg, riprel, disp, dataSize=dsz
+};
+
+'''
\ No newline at end of file
diff --git a/src/arch/x86/isa/insts/simd512/floating_point/data_transfer/vmovddup.py b/src/arch/x86/isa/insts/simd512/floating_point/data_transfer/vmovddup.py
new file mode 100644
index 0000000000..bce4b5235b
--- /dev/null
+++ b/src/arch/x86/isa/insts/simd512/floating_point/data_transfer/vmovddup.py
@@ -0,0 +1,82 @@
+microcode = '''
+
+def macroop VMOVDDUP_XMM_XMM {
+    movfp xmm0, xmm0m, dataSize=8
+    movfp xmm1, xmm0m, dataSize=8
+    vclear dest=xmm2, destVL=16
+};
+
+def macroop VMOVDDUP_XMM_M {
+    ldfp xmm0, seg, sib, disp, dataSize=8
+    movfp xmm1, xmm0, dataSize=8
+    vclear dest=xmm2, destVL=16
+};
+
+def macroop VMOVDDUP_XMM_P {
+    rdip t7
+    ldfp xmm0, seg, riprel, disp, dataSize=8
+    movfp xmm1, xmm0, dataSize=8
+    vclear dest=xmm2, destVL=16
+};
+
+def macroop VMOVDDUP_YMM_YMM {
+    movfp xmm0, xmm0m, dataSize=8
+    movfp xmm1, xmm0m, dataSize=8
+    movfp xmm2, xmm2m, dataSize=8
+    movfp xmm3, xmm2m, dataSize=8
+    vclear dest=xmm4, destVL=32
+};
+
+def macroop VMOVDDUP_YMM_M {
+    ldfp xmm0, seg, sib, "DISPLACEMENT + 0", dataSize=8
+    ldfp xmm2, seg, sib, "DISPLACEMENT + 16", dataSize=8
+    movfp xmm1, xmm0, dataSize=8
+    movfp xmm3, xmm2, dataSize=8
+    vclear dest=xmm4, destVL=32
+};
+
+def macroop VMOVDDUP_YMM_P {
+    rdip t7
+    ldfp xmm0, seg, riprel, "DISPLACEMENT + 0", dataSize=8
+    ldfp xmm2, seg, riprel, "DISPLACEMENT + 16", dataSize=8
+    movfp xmm1, xmm0, dataSize=8
+    movfp xmm3, xmm2, dataSize=8
+    vclear dest=xmm4, destVL=32
+};
+
+def macroop VMOVDDUP_ZMM_ZMM {
+    movfp xmm0, xmm0m, dataSize=8
+    movfp xmm1, xmm0m, dataSize=8
+    movfp xmm2, xmm2m, dataSize=8
+    movfp xmm3, xmm2m, dataSize=8
+    movfp xmm4, xmm4m, dataSize=8
+    movfp xmm5, xmm4m, dataSize=8
+    movfp xmm6, xmm6m, dataSize=8
+    movfp xmm7, xmm6m, dataSize=8
+};
+
+def macroop VMOVDDUP_ZMM_M {
+    ldfp xmm0, seg, sib, "DISPLACEMENT + 0", dataSize=8
+    ldfp xmm2, seg, sib, "DISPLACEMENT + 16", dataSize=8
+    ldfp xmm4, seg, sib, "DISPLACEMENT + 32", dataSize=8
+    ldfp xmm6, seg, sib, "DISPLACEMENT + 48", dataSize=8
+    movfp xmm1, xmm0, dataSize=8
+    movfp xmm3, xmm2, dataSize=8
+    movfp xmm5, xmm4, dataSize=8
+    movfp xmm7, xmm6, dataSize=8
+};
+
+def macroop VMOVDDUP_ZMM_P {
+    rdip t7
+    ldfp xmm0, seg, riprel, "DISPLACEMENT + 0", dataSize=8
+    ldfp xmm2, seg, riprel, "DISPLACEMENT + 16", dataSize=8
+    ldfp xmm4, seg, riprel, "DISPLACEMENT + 32", dataSize=8
+    ldfp xmm6, seg, riprel, "DISPLACEMENT + 48", dataSize=8
+    movfp xmm1, xmm0, dataSize=8
+    movfp xmm3, xmm2, dataSize=8
+    movfp xmm5, xmm4, dataSize=8
+    movfp xmm7, xmm6, dataSize=8
+};
+
+
+'''
\ No newline at end of file
diff --git a/src/arch/x86/isa/insts/simd512/floating_point/data_transfer/vmovdqa.py b/src/arch/x86/isa/insts/simd512/floating_point/data_transfer/vmovdqa.py
new file mode 100644
index 0000000000..1d3921d344
--- /dev/null
+++ b/src/arch/x86/isa/insts/simd512/floating_point/data_transfer/vmovdqa.py
@@ -0,0 +1,69 @@
+microcode = '''
+
+def macroop VMOVDQA_XMM_XMM {
+    movfp128 dest=xmm0, src1=xmm0m, dataSize=16
+};
+
+def macroop VMOVDQA_XMM_M {
+    ldfp128 xmm0, seg, sib, "DISPLACEMENT + 0", dataSize=16
+};
+
+def macroop VMOVDQA_XMM_P {
+    rdip t7
+    ldfp128 xmm0, seg, riprel, "DISPLACEMENT + 0", dataSize=16
+};
+
+def macroop VMOVDQA_M_XMM {
+    stfp128 xmm0, seg, sib, "DISPLACEMENT + 0", dataSize=16
+};
+
+def macroop VMOVDQA_P_XMM {
+    rdip t7
+    stfp128 xmm0, seg, riprel, "DISPLACEMENT + 0", dataSize=16
+};
+
+def macroop VMOVDQA_YMM_YMM {
+    movfp256 dest=xmm0, src1=xmm0m, dataSize=32
+};
+
+def macroop VMOVDQA_YMM_M {
+    ldfp256 xmm0, seg, sib, "DISPLACEMENT + 0", dataSize=32
+};
+
+def macroop VMOVDQA_YMM_P {
+    rdip t7
+    ldfp256 xmm0, seg, riprel, "DISPLACEMENT + 0", dataSize=32
+};
+
+def macroop VMOVDQA_M_YMM {
+    stfp256 xmm0, seg, sib, "DISPLACEMENT + 0", dataSize=32
+};
+
+def macroop VMOVDQA_P_YMM {
+    rdip t7
+    stfp256 xmm0, seg, riprel, "DISPLACEMENT + 0", dataSize=32
+};
+
+def macroop VMOVDQA_ZMM_ZMM {
+    movfp512 dest=xmm0, src1=xmm0m, dataSize=64
+};
+
+def macroop VMOVDQA_ZMM_M {
+    ldfp512 xmm0, seg, sib, "DISPLACEMENT + 0", dataSize=64
+};
+
+def macroop VMOVDQA_ZMM_P {
+    rdip t7
+    ldfp512 xmm0, seg, riprel, "DISPLACEMENT + 0", dataSize=64
+};
+
+def macroop VMOVDQA_M_ZMM {
+    stfp512 xmm0, seg, sib, "DISPLACEMENT + 0", dataSize=64
+};
+
+def macroop VMOVDQA_P_ZMM {
+    rdip t7
+    stfp512 xmm0, seg, riprel, "DISPLACEMENT + 0", dataSize=64
+};
+
+'''
\ No newline at end of file
diff --git a/src/arch/x86/isa/insts/simd512/floating_point/data_transfer/vmovdqu.py b/src/arch/x86/isa/insts/simd512/floating_point/data_transfer/vmovdqu.py
new file mode 100644
index 0000000000..1f074747e5
--- /dev/null
+++ b/src/arch/x86/isa/insts/simd512/floating_point/data_transfer/vmovdqu.py
@@ -0,0 +1,69 @@
+microcode = '''
+
+def macroop VMOVDQU_XMM_XMM {
+    movfp128 dest=xmm0, src1=xmm0m, dataSize=16
+};
+
+def macroop VMOVDQU_XMM_M {
+    ldfp128 xmm0, seg, sib, "DISPLACEMENT + 0", dataSize=16
+};
+
+def macroop VMOVDQU_XMM_P {
+    rdip t7
+    ldfp128 xmm0, seg, riprel, "DISPLACEMENT + 0", dataSize=16
+};
+
+def macroop VMOVDQU_M_XMM {
+    stfp128 xmm0, seg, sib, "DISPLACEMENT + 0", dataSize=16
+};
+
+def macroop VMOVDQU_P_XMM {
+    rdip t7
+    stfp128 xmm0, seg, riprel, "DISPLACEMENT + 0", dataSize=16
+};
+
+def macroop VMOVDQU_YMM_YMM {
+    movfp256 dest=xmm0, src1=xmm0m, dataSize=32
+};
+
+def macroop VMOVDQU_YMM_M {
+    ldfp256 xmm0, seg, sib, "DISPLACEMENT + 0", dataSize=32
+};
+
+def macroop VMOVDQU_YMM_P {
+    rdip t7
+    ldfp256 xmm0, seg, riprel, "DISPLACEMENT + 0", dataSize=32
+};
+
+def macroop VMOVDQU_M_YMM {
+    stfp256 xmm0, seg, sib, "DISPLACEMENT + 0", dataSize=32
+};
+
+def macroop VMOVDQU_P_YMM {
+    rdip t7
+    stfp256 xmm0, seg, riprel, "DISPLACEMENT + 0", dataSize=32
+};
+
+def macroop VMOVDQU_ZMM_ZMM {
+    movfp512 dest=xmm0, src1=xmm0m, dataSize=64
+};
+
+def macroop VMOVDQU_ZMM_M {
+    ldfp512 xmm0, seg, sib, "DISPLACEMENT + 0", dataSize=64
+};
+
+def macroop VMOVDQU_ZMM_P {
+    rdip t7
+    ldfp512 xmm0, seg, riprel, "DISPLACEMENT + 0", dataSize=64
+};
+
+def macroop VMOVDQU_M_ZMM {
+    stfp512 xmm0, seg, sib, "DISPLACEMENT + 0", dataSize=64
+};
+
+def macroop VMOVDQU_P_ZMM {
+    rdip t7
+    stfp512 xmm0, seg, riprel, "DISPLACEMENT + 0", dataSize=64
+};
+
+'''
\ No newline at end of file
diff --git a/src/arch/x86/isa/insts/simd512/floating_point/data_transfer/vmovhpd.py b/src/arch/x86/isa/insts/simd512/floating_point/data_transfer/vmovhpd.py
new file mode 100644
index 0000000000..7992d41bfa
--- /dev/null
+++ b/src/arch/x86/isa/insts/simd512/floating_point/data_transfer/vmovhpd.py
@@ -0,0 +1,16 @@
+microcode = '''
+
+def macroop VMOVHPD_XMM_M {
+    movfp xmm0, xmm0v
+    ldfp xmm1, seg, sib, disp, dataSize=8
+    vclear dest=xmm2, destVL=16
+};
+
+def macroop VMOVHPD_XMM_P {
+    movfp xmm0, xmm0v
+    rdip t7
+    ldfp xmm1, seg, riprel, disp, dataSize=8
+    vclear dest=xmm2, destVL=16
+};
+
+'''
\ No newline at end of file
diff --git a/src/arch/x86/isa/insts/simd512/floating_point/data_transfer/vmovlhps.py b/src/arch/x86/isa/insts/simd512/floating_point/data_transfer/vmovlhps.py
new file mode 100644
index 0000000000..d1dc2365a9
--- /dev/null
+++ b/src/arch/x86/isa/insts/simd512/floating_point/data_transfer/vmovlhps.py
@@ -0,0 +1,8 @@
+microcode = '''
+def macroop VMOVLHPS_XMM_XMM {
+    movfp xmm0, xmm0v, dataSize=8
+    movfp xmm1, xmm0m, dataSize=8
+    vclear dest=xmm2, destVL=16
+};
+
+'''
\ No newline at end of file
diff --git a/src/arch/x86/isa/insts/simd512/floating_point/data_transfer/vmovq.py b/src/arch/x86/isa/insts/simd512/floating_point/data_transfer/vmovq.py
new file mode 100644
index 0000000000..8d8562090d
--- /dev/null
+++ b/src/arch/x86/isa/insts/simd512/floating_point/data_transfer/vmovq.py
@@ -0,0 +1,17 @@
+microcode = '''
+
+def macroop VMOVQ_XMM_XMM {
+    movfp xmm0, xmm0m
+    vclear dest=xmm1, destVL=8
+};
+
+def macroop VMOVQ_M_XMM {
+    stfp xmm0, seg, sib, disp, dataSize=8
+};
+
+def macroop VMOVQ_P_XMM {
+    rdip t7
+    stfp xmm0, seg, riprel, disp, dataSize=8
+};
+
+'''
\ No newline at end of file
diff --git a/src/arch/x86/isa/insts/simd512/floating_point/data_transfer/vmovsd.py b/src/arch/x86/isa/insts/simd512/floating_point/data_transfer/vmovsd.py
new file mode 100644
index 0000000000..4b9204b719
--- /dev/null
+++ b/src/arch/x86/isa/insts/simd512/floating_point/data_transfer/vmovsd.py
@@ -0,0 +1,45 @@
+microcode = '''
+def macroop VMOVSD_XMM_XMM {
+    panic "VMOVSD_XMM_XMM not implemented."
+};
+
+def macroop VMOVSD_XMM_M {
+    ldfp xmm0, seg, sib, disp, dataSize=8
+    lfpimm xmm1, 0
+    vclear dest=xmm2, destVL=16
+};
+
+def macroop VMOVSD_XMM_P {
+    rdip t7
+    ldfp xmm0, seg, riprel, disp, dataSize=8
+    lfpimm xmm1, 0
+    vclear dest=xmm2, destVL=16
+};
+
+def macroop VMOVSD_M_XMM {
+    stfp xmm0, seg, sib, disp, dataSize=8
+};
+
+def macroop VMOVSD_P_XMM {
+    rdip t7
+    stfp xmm0, seg, riprel, disp, dataSize=8
+};
+
+def macroop VMOVSD_ZMM_ZMM {
+    panic "VMOVSD_ZMM_ZMM is not implemented."
+};
+
+def macroop VMOVSD_ZMM_M {
+    ldfp xmm0, seg, sib, disp, dataSize=8
+    lfpimm xmm1, 0
+    vclear dest=xmm2, destVL=16
+};
+
+def macroop VMOVSD_ZMM_P {
+    rdip t7
+    ldfp xmm0, seg, riprel, disp, dataSize=8
+    lfpimm xmm1, 0
+    vclear dest=xmm2, destVL=16
+};
+
+'''
\ No newline at end of file
diff --git a/src/arch/x86/isa/insts/simd512/floating_point/data_transfer/vmovshdup.py b/src/arch/x86/isa/insts/simd512/floating_point/data_transfer/vmovshdup.py
new file mode 100644
index 0000000000..c1dbdcfaaa
--- /dev/null
+++ b/src/arch/x86/isa/insts/simd512/floating_point/data_transfer/vmovshdup.py
@@ -0,0 +1,85 @@
+microcode = '''
+def macroop VMOVSHDUP_XMM_XMM {
+    mmovsdup dest=xmm0, src1=xmm0m, size=4, ext=1
+    mmovsdup dest=xmm1, src1=xmm1m, size=4, ext=1
+    vclear dest=xmm2, destVL=16
+};
+
+def macroop VMOVSHDUP_XMM_M {
+    ldfp128 ufp1, seg, sib, "DISPLACEMENT + 0", dataSize=16
+    mmovsdup dest=xmm0, src1=ufp1, size=4, ext=1
+    mmovsdup dest=xmm1, src1=ufp2, size=4, ext=1
+    vclear dest=xmm2, destVL=16
+};
+
+def macroop VMOVSHDUP_XMM_P {
+    rdip t7
+    ldfp128 ufp1, seg, riprel, "DISPLACEMENT + 0", dataSize=16
+    mmovsdup dest=xmm0, src1=ufp1, size=4, ext=1
+    mmovsdup dest=xmm1, src1=ufp2, size=4, ext=1
+    vclear dest=xmm2, destVL=16
+};
+
+def macroop VMOVSHDUP_YMM_YMM {
+    mmovsdup dest=xmm0, src1=xmm0m, size=4, ext=1
+    mmovsdup dest=xmm1, src1=xmm1m, size=4, ext=1
+    mmovsdup dest=xmm2, src1=xmm2m, size=4, ext=1
+    mmovsdup dest=xmm3, src1=xmm3m, size=4, ext=1
+    vclear dest=xmm4, destVL=32
+};
+
+def macroop VMOVSHDUP_YMM_M {
+    ldfp256 ufp1, seg, sib, "DISPLACEMENT + 0", dataSize=32
+    mmovsdup dest=xmm0, src1=ufp1, size=4, ext=1
+    mmovsdup dest=xmm1, src1=ufp2, size=4, ext=1
+    mmovsdup dest=xmm2, src1=ufp3, size=4, ext=1
+    mmovsdup dest=xmm3, src1=ufp4, size=4, ext=1
+    vclear dest=xmm4, destVL=32
+};
+
+def macroop VMOVSHDUP_YMM_P {
+    rdip t7
+    ldfp256 ufp1, seg, riprel, "DISPLACEMENT + 0", dataSize=32
+    mmovsdup dest=xmm0, src1=ufp1, size=4, ext=1
+    mmovsdup dest=xmm1, src1=ufp2, size=4, ext=1
+    mmovsdup dest=xmm2, src1=ufp3, size=4, ext=1
+    mmovsdup dest=xmm3, src1=ufp4, size=4, ext=1
+    vclear dest=xmm4, destVL=32
+};
+
+def macroop VMOVSHDUP_ZMM_ZMM {
+    mmovsdup dest=xmm0, src1=xmm0m, size=4, ext=1
+    mmovsdup dest=xmm1, src1=xmm1m, size=4, ext=1
+    mmovsdup dest=xmm2, src1=xmm2m, size=4, ext=1
+    mmovsdup dest=xmm3, src1=xmm3m, size=4, ext=1
+    mmovsdup dest=xmm4, src1=xmm4m, size=4, ext=1
+    mmovsdup dest=xmm5, src1=xmm5m, size=4, ext=1
+    mmovsdup dest=xmm6, src1=xmm6m, size=4, ext=1
+    mmovsdup dest=xmm7, src1=xmm7m, size=4, ext=1
+};
+
+def macroop VMOVSHDUP_ZMM_M {
+    ldfp512 ufp1, seg, sib, "DISPLACEMENT + 0", dataSize=64
+    mmovsdup dest=xmm0, src1=ufp1, size=4, ext=1
+    mmovsdup dest=xmm1, src1=ufp2, size=4, ext=1
+    mmovsdup dest=xmm2, src1=ufp3, size=4, ext=1
+    mmovsdup dest=xmm3, src1=ufp4, size=4, ext=1
+    mmovsdup dest=xmm4, src1=ufp5, size=4, ext=1
+    mmovsdup dest=xmm5, src1=ufp6, size=4, ext=1
+    mmovsdup dest=xmm6, src1=ufp7, size=4, ext=1
+    mmovsdup dest=xmm7, src1=ufp8, size=4, ext=1
+};
+
+def macroop VMOVSHDUP_ZMM_P {
+    rdip t7
+    ldfp512 ufp1, seg, riprel, "DISPLACEMENT + 0", dataSize=64
+    mmovsdup dest=xmm0, src1=ufp1, size=4, ext=1
+    mmovsdup dest=xmm1, src1=ufp2, size=4, ext=1
+    mmovsdup dest=xmm2, src1=ufp3, size=4, ext=1
+    mmovsdup dest=xmm3, src1=ufp4, size=4, ext=1
+    mmovsdup dest=xmm4, src1=ufp5, size=4, ext=1
+    mmovsdup dest=xmm5, src1=ufp6, size=4, ext=1
+    mmovsdup dest=xmm6, src1=ufp7, size=4, ext=1
+    mmovsdup dest=xmm7, src1=ufp8, size=4, ext=1
+};
+'''
\ No newline at end of file
diff --git a/src/arch/x86/isa/insts/simd512/floating_point/data_transfer/vmovsldup.py b/src/arch/x86/isa/insts/simd512/floating_point/data_transfer/vmovsldup.py
new file mode 100644
index 0000000000..d6601d0eee
--- /dev/null
+++ b/src/arch/x86/isa/insts/simd512/floating_point/data_transfer/vmovsldup.py
@@ -0,0 +1,85 @@
+microcode = '''
+def macroop VMOVSLDUP_XMM_XMM {
+    mmovsdup dest=xmm0, src1=xmm0m, size=4, ext=0
+    mmovsdup dest=xmm1, src1=xmm1m, size=4, ext=0
+    vclear dest=xmm2, destVL=16
+};
+
+def macroop VMOVSLDUP_XMM_M {
+    ldfp128 ufp1, seg, sib, "DISPLACEMENT + 0", dataSize=16
+    mmovsdup dest=xmm0, src1=ufp1, size=4, ext=0
+    mmovsdup dest=xmm1, src1=ufp2, size=4, ext=0
+    vclear dest=xmm2, destVL=16
+};
+
+def macroop VMOVSLDUP_XMM_P {
+    rdip t7
+    ldfp128 ufp1, seg, riprel, "DISPLACEMENT + 0", dataSize=16
+    mmovsdup dest=xmm0, src1=ufp1, size=4, ext=0
+    mmovsdup dest=xmm1, src1=ufp2, size=4, ext=0
+    vclear dest=xmm2, destVL=16
+};
+
+def macroop VMOVSLDUP_YMM_YMM {
+    mmovsdup dest=xmm0, src1=xmm0m, size=4, ext=0
+    mmovsdup dest=xmm1, src1=xmm1m, size=4, ext=0
+    mmovsdup dest=xmm2, src1=xmm2m, size=4, ext=0
+    mmovsdup dest=xmm3, src1=xmm3m, size=4, ext=0
+    vclear dest=xmm4, destVL=32
+};
+
+def macroop VMOVSLDUP_YMM_M {
+    ldfp256 ufp1, seg, sib, "DISPLACEMENT + 0", dataSize=32
+    mmovsdup dest=xmm0, src1=ufp1, size=4, ext=0
+    mmovsdup dest=xmm1, src1=ufp2, size=4, ext=0
+    mmovsdup dest=xmm2, src1=ufp3, size=4, ext=0
+    mmovsdup dest=xmm3, src1=ufp4, size=4, ext=0
+    vclear dest=xmm4, destVL=32
+};
+
+def macroop VMOVSLDUP_YMM_P {
+    rdip t7
+    ldfp256 ufp1, seg, riprel, "DISPLACEMENT + 0", dataSize=32
+    mmovsdup dest=xmm0, src1=ufp1, size=4, ext=0
+    mmovsdup dest=xmm1, src1=ufp2, size=4, ext=0
+    mmovsdup dest=xmm2, src1=ufp3, size=4, ext=0
+    mmovsdup dest=xmm3, src1=ufp4, size=4, ext=0
+    vclear dest=xmm4, destVL=32
+};
+
+def macroop VMOVSLDUP_ZMM_ZMM {
+    mmovsdup dest=xmm0, src1=xmm0m, size=4, ext=0
+    mmovsdup dest=xmm1, src1=xmm1m, size=4, ext=0
+    mmovsdup dest=xmm2, src1=xmm2m, size=4, ext=0
+    mmovsdup dest=xmm3, src1=xmm3m, size=4, ext=0
+    mmovsdup dest=xmm4, src1=xmm4m, size=4, ext=0
+    mmovsdup dest=xmm5, src1=xmm5m, size=4, ext=0
+    mmovsdup dest=xmm6, src1=xmm6m, size=4, ext=0
+    mmovsdup dest=xmm7, src1=xmm7m, size=4, ext=0
+};
+
+def macroop VMOVSLDUP_ZMM_M {
+    ldfp512 ufp1, seg, sib, "DISPLACEMENT + 0", dataSize=64
+    mmovsdup dest=xmm0, src1=ufp1, size=4, ext=0
+    mmovsdup dest=xmm1, src1=ufp2, size=4, ext=0
+    mmovsdup dest=xmm2, src1=ufp3, size=4, ext=0
+    mmovsdup dest=xmm3, src1=ufp4, size=4, ext=0
+    mmovsdup dest=xmm4, src1=ufp5, size=4, ext=0
+    mmovsdup dest=xmm5, src1=ufp6, size=4, ext=0
+    mmovsdup dest=xmm6, src1=ufp7, size=4, ext=0
+    mmovsdup dest=xmm7, src1=ufp8, size=4, ext=0
+};
+
+def macroop VMOVSLDUP_ZMM_P {
+    rdip t7
+    ldfp512 ufp1, seg, riprel, "DISPLACEMENT + 0", dataSize=64
+    mmovsdup dest=xmm0, src1=ufp1, size=4, ext=0
+    mmovsdup dest=xmm1, src1=ufp2, size=4, ext=0
+    mmovsdup dest=xmm2, src1=ufp3, size=4, ext=0
+    mmovsdup dest=xmm3, src1=ufp4, size=4, ext=0
+    mmovsdup dest=xmm4, src1=ufp5, size=4, ext=0
+    mmovsdup dest=xmm5, src1=ufp6, size=4, ext=0
+    mmovsdup dest=xmm6, src1=ufp7, size=4, ext=0
+    mmovsdup dest=xmm7, src1=ufp8, size=4, ext=0
+};
+'''
\ No newline at end of file
diff --git a/src/arch/x86/isa/insts/simd512/floating_point/data_transfer/vmovss.py b/src/arch/x86/isa/insts/simd512/floating_point/data_transfer/vmovss.py
new file mode 100644
index 0000000000..152fdd6dd6
--- /dev/null
+++ b/src/arch/x86/isa/insts/simd512/floating_point/data_transfer/vmovss.py
@@ -0,0 +1,50 @@
+microcode = '''
+def macroop VMOVSS_XMM_XMM {
+    panic "VMOVSS_XMM_XMM not implemented."
+};
+
+def macroop VMOVSS_XMM_M {
+    lfpimm xmm0, 0
+    lfpimm xmm1, 0
+    vclear dest=xmm2, destVL=16
+    ldfp xmm0, seg, sib, disp, dataSize=4
+};
+
+def macroop VMOVSS_XMM_P {
+    rdip t7
+    lfpimm xmm0, 0
+    lfpimm xmm1, 0
+    vclear dest=xmm2, destVL=16
+    ldfp xmm0, seg, riprel, disp, dataSize=4
+};
+
+
+def macroop VMOVSS_M_XMM {
+    stfp xmm0, seg, sib, disp, dataSize=4
+};
+
+def macroop VMOVSS_P_XMM {
+    rdip t7
+    stfp xmm0, seg, riprel, disp, dataSize=4
+};
+
+def macroop VMOVSS_ZMM_ZMM {
+    panic "VMOVSS_ZMM_ZMM is not implemented."
+};
+
+def macroop VMOVSS_ZMM_M {
+    lfpimm xmm0, 0
+    lfpimm xmm1, 0
+    vclear dest=xmm2, destVL=16
+    ldfp xmm0, seg, sib, disp, dataSize=4
+};
+
+def macroop VMOVSS_ZMM_P {
+    rdip t7
+    lfpimm xmm0, 0
+    lfpimm xmm1, 0
+    vclear dest=xmm2, destVL=16
+    ldfp xmm0, seg, riprel, disp, dataSize=4
+};
+
+'''
\ No newline at end of file
diff --git a/src/arch/x86/isa/insts/simd512/floating_point/data_transfer/vmovupd.py b/src/arch/x86/isa/insts/simd512/floating_point/data_transfer/vmovupd.py
new file mode 100644
index 0000000000..120a3e068b
--- /dev/null
+++ b/src/arch/x86/isa/insts/simd512/floating_point/data_transfer/vmovupd.py
@@ -0,0 +1,74 @@
+microcode = '''
+def macroop VMOVUPD_XMM_XMM {
+    movfp128 dest=xmm0, src1=xmm0m, dataSize=16
+    vclear dest=xmm2, destVL=16
+};
+
+def macroop VMOVUPD_XMM_M {
+    ldfp128 xmm0, seg, sib, "DISPLACEMENT + 0", dataSize=16
+    vclear dest=xmm2, destVL=16
+};
+
+def macroop VMOVUPD_XMM_P {
+    rdip t7
+    ldfp128 xmm0, seg, riprel, "DISPLACEMENT + 0", dataSize=16
+    vclear dest=xmm2, destVL=16
+};
+
+def macroop VMOVUPD_M_XMM {
+    stfp128 xmm0, seg, sib, "DISPLACEMENT + 0", dataSize=16
+};
+
+def macroop VMOVUPD_P_XMM {
+    rdip t7
+    stfp128 xmm0, seg, riprel, "DISPLACEMENT + 0", dataSize=16
+};
+
+def macroop VMOVUPD_YMM_YMM {
+    movfp256 dest=xmm0, src1=xmm0m, dataSize=32
+    vclear dest=xmm4, destVL=32
+};
+
+def macroop VMOVUPD_YMM_M {
+    ldfp256 xmm0, seg, sib, "DISPLACEMENT + 0", dataSize=32
+    vclear dest=xmm4, destVL=32
+};
+
+def macroop VMOVUPD_YMM_P {
+    rdip t7
+    ldfp256 xmm0, seg, riprel, "DISPLACEMENT + 0", dataSize=32
+    vclear dest=xmm4, destVL=32
+};
+
+def macroop VMOVUPD_M_YMM {
+    stfp256 xmm0, seg, sib, "DISPLACEMENT + 0", dataSize=32
+};
+
+def macroop VMOVUPD_P_YMM {
+    rdip t7
+    stfp256 xmm0, seg, riprel, "DISPLACEMENT + 0", dataSize=32
+};
+
+def macroop VMOVUPD_ZMM_ZMM {
+    movfp512 dest=xmm0, src1=xmm0m, dataSize=64
+};
+
+def macroop VMOVUPD_ZMM_M {
+    ldfp512 xmm0, seg, sib, "DISPLACEMENT + 0", dataSize=64
+};
+
+def macroop VMOVUPD_ZMM_P {
+    rdip t7
+    ldfp512 xmm0, seg, riprel, "DISPLACEMENT + 0", dataSize=64
+};
+
+def macroop VMOVUPD_M_ZMM {
+    stfp512 xmm0, seg, sib, "DISPLACEMENT + 0", dataSize=64
+};
+
+def macroop VMOVUPD_P_ZMM {
+    rdip t7
+    stfp512 xmm0, seg, riprel, "DISPLACEMENT + 0", dataSize=64
+};
+
+'''
\ No newline at end of file
diff --git a/src/arch/x86/isa/insts/simd512/floating_point/data_transfer/vmovups.py b/src/arch/x86/isa/insts/simd512/floating_point/data_transfer/vmovups.py
new file mode 100644
index 0000000000..9d755b77b6
--- /dev/null
+++ b/src/arch/x86/isa/insts/simd512/floating_point/data_transfer/vmovups.py
@@ -0,0 +1,74 @@
+microcode = '''
+def macroop VMOVUPS_XMM_XMM {
+    movfp128 dest=xmm0, src1=xmm0m, dataSize=16
+    vclear dest=xmm2, destVL=16
+};
+
+def macroop VMOVUPS_XMM_M {
+    ldfp128 xmm0, seg, sib, "DISPLACEMENT + 0", dataSize=16
+    vclear dest=xmm2, destVL=16
+};
+
+def macroop VMOVUPS_XMM_P {
+    rdip t7
+    ldfp128 xmm0, seg, riprel, "DISPLACEMENT + 0", dataSize=16
+    vclear dest=xmm2, destVL=16
+};
+
+def macroop VMOVUPS_M_XMM {
+    stfp128 xmm0, seg, sib, "DISPLACEMENT + 0", dataSize=16
+};
+
+def macroop VMOVUPS_P_XMM {
+    rdip t7
+    stfp128 xmm0, seg, riprel, "DISPLACEMENT + 0", dataSize=16
+};
+
+def macroop VMOVUPS_YMM_YMM {
+    movfp256 dest=xmm0, src1=xmm0m, dataSize=32
+    vclear dest=xmm4, destVL=32
+};
+
+def macroop VMOVUPS_YMM_M {
+    ldfp256 xmm0, seg, sib, "DISPLACEMENT + 0", dataSize=32
+    vclear dest=xmm4, destVL=32
+};
+
+def macroop VMOVUPS_YMM_P {
+    rdip t7
+    ldfp256 xmm0, seg, riprel, "DISPLACEMENT + 0", dataSize=32
+    vclear dest=xmm4, destVL=32
+};
+
+def macroop VMOVUPS_M_YMM {
+    stfp256 xmm0, seg, sib, "DISPLACEMENT + 0", dataSize=32
+};
+
+def macroop VMOVUPS_P_YMM {
+    rdip t7
+    stfp256 xmm0, seg, riprel, "DISPLACEMENT + 0", dataSize=32
+};
+
+def macroop VMOVUPS_ZMM_ZMM {
+    movfp512 dest=xmm0, src1=xmm0m, dataSize=64
+};
+
+def macroop VMOVUPS_ZMM_M {
+    ldfp512 xmm0, seg, sib, "DISPLACEMENT + 0", dataSize=64
+};
+
+def macroop VMOVUPS_ZMM_P {
+    rdip t7
+    ldfp512 xmm0, seg, riprel, "DISPLACEMENT + 0", dataSize=64
+};
+
+def macroop VMOVUPS_M_ZMM {
+    stfp512 xmm0, seg, sib, "DISPLACEMENT + 0", dataSize=64
+};
+
+def macroop VMOVUPS_P_ZMM {
+    rdip t7
+    stfp512 xmm0, seg, riprel, "DISPLACEMENT + 0", dataSize=64
+};
+
+'''
\ No newline at end of file
diff --git a/src/arch/x86/isa/insts/simd512/floating_point/data_transfer/vpbroadcast.py b/src/arch/x86/isa/insts/simd512/floating_point/data_transfer/vpbroadcast.py
new file mode 100644
index 0000000000..1df1eacb98
--- /dev/null
+++ b/src/arch/x86/isa/insts/simd512/floating_point/data_transfer/vpbroadcast.py
@@ -0,0 +1,92 @@
+microcode = '''
+
+def macroop VPBROADCASTQ_ZMM_R {
+    mov2fp ufp1, regm, destSize=8, srcSize=8
+    vbroadcast64 dest=xmm0, src=ufp1, destVL=64
+};
+
+def macroop VPBROADCASTQ_ZMM_XMM {
+    vbroadcast64 dest=xmm0, src=xmm0m, destVL=64
+};
+
+def macroop VPBROADCASTQ_ZMM_M {
+    ldfp ufp1, seg, sib, disp, dataSize=8
+    vbroadcast64 dest=xmm0, src=ufp1, destVL=64
+};
+
+def macroop VPBROADCASTQ_ZMM_P {
+    rdip t7
+    ldfp ufp1, seg, riprel, disp, dataSize=8
+    vbroadcast64 dest=xmm0, src=ufp1, destVL=64
+};
+
+def macroop VPBROADCASTD_XMM_XMM {
+    vbroadcast32 dest=xmm0, src=xmm0m, destVL=16
+    vclear dest=xmm2, destVL=16
+};
+
+def macroop VPBROADCASTD_XMM_M {
+    ldfp ufp1, seg, sib, disp, dataSize=4
+    vbroadcast32 dest=xmm0, src=ufp1, destVL=16
+    vclear dest=xmm2, destVL=16
+};
+
+def macroop VPBROADCASTD_XMM_P {
+    rdip t7
+    ldfp ufp1, seg, riprel, disp, dataSize=4
+    vbroadcast32 dest=xmm0, src=ufp1, destVL=16
+    vclear dest=xmm2, destVL=16
+};
+
+def macroop VPBROADCASTD_YMM_XMM {
+    vbroadcast32 dest=xmm0, src=xmm0m, destVL=32
+    vclear dest=xmm4, destVL=32
+};
+
+def macroop VPBROADCASTB_YMM_XMM {
+    vbroadcast8 dest=xmm0, src=xmm0m, destVL=32
+    vclear dest=xmm4, destVL=32
+};
+
+def macroop VPBROADCASTB_YMM_M {
+    ldfp ufp1, seg, sib, disp, dataSize=1
+    vbroadcast8 dest=xmm0, src=ufp1, destVL=32
+    vclear dest=xmm4, destVL=32
+};
+
+def macroop VPBROADCASTB_YMM_P {
+    rdip t7
+    ldfp ufp1, seg, riprel, disp, dataSize=1
+    vbroadcast8 dest=xmm0, src=ufp1, destVL=32
+    vclear dest=xmm4, destVL=32
+};
+
+def macroop VPBROADCASTD_YMM_M {
+    ldfp ufp1, seg, sib, disp, dataSize=4
+    vbroadcast32 dest=xmm0, src=ufp1, destVL=32
+    vclear dest=xmm4, destVL=32
+};
+
+def macroop VPBROADCASTD_YMM_P {
+    rdip t7
+    ldfp ufp1, seg, riprel, disp, dataSize=4
+    vbroadcast32 dest=xmm0, src=ufp1, destVL=32
+    vclear dest=xmm4, destVL=32
+};
+
+def macroop VPBROADCASTD_ZMM_XMM {
+    vbroadcast32 dest=xmm0, src=xmm0m, destVL=64
+};
+
+def macroop VPBROADCASTD_ZMM_M {
+    ldfp ufp1, seg, sib, disp, dataSize=4
+    vbroadcast32 dest=xmm0, src=ufp1, destVL=64
+};
+
+def macroop VPBROADCASTD_ZMM_P {
+    rdip t7
+    ldfp ufp1, seg, riprel, disp, dataSize=4
+    vbroadcast32 dest=xmm0, src=ufp1, destVL=64
+};
+
+'''
\ No newline at end of file
diff --git a/src/arch/x86/isa/insts/simd512/floating_point/data_transfer/vpermilpd.py b/src/arch/x86/isa/insts/simd512/floating_point/data_transfer/vpermilpd.py
new file mode 100644
index 0000000000..2c66be2c60
--- /dev/null
+++ b/src/arch/x86/isa/insts/simd512/floating_point/data_transfer/vpermilpd.py
@@ -0,0 +1,86 @@
+microcode = '''
+
+def macroop VPERMILPD_XMM_XMM_I {
+    mpermilpd dest=xmm0, src1=xmm0m, op2=xmm1m, size=8, ext="(IMMEDIATE >> 0) & 0x1"
+    mpermilpd dest=xmm1, src1=xmm0m, op2=xmm1m, size=8, ext="(IMMEDIATE >> 1) & 0x1"
+    vclear dest=xmm2, destVL=16
+};
+
+def macroop VPERMILPD_XMM_M_I {
+    ldfp128 ufp1, seg, sib, "DISPLACEMENT + 0", dataSize=16
+    mpermilpd dest=xmm0, src1=ufp1, op2=ufp2, size=8, ext="(IMMEDIATE >> 0) & 0x1"
+    mpermilpd dest=xmm1, src1=ufp1, op2=ufp2, size=8, ext="(IMMEDIATE >> 1) & 0x1"
+    vclear dest=xmm2, destVL=16
+};
+
+def macroop VPERMILPD_XMM_P_I {
+    rdip t7
+    ldfp128 ufp1, seg, riprel, "DISPLACEMENT + 0", dataSize=16
+    mpermilpd dest=xmm0, src1=ufp1, op2=ufp2, size=8, ext="(IMMEDIATE >> 0) & 0x1"
+    mpermilpd dest=xmm1, src1=ufp1, op2=ufp2, size=8, ext="(IMMEDIATE >> 1) & 0x1"
+    vclear dest=xmm2, destVL=16
+};
+
+def macroop VPERMILPD_YMM_YMM_I {
+    mpermilpd dest=xmm0, src1=xmm0m, op2=xmm1m, size=8, ext="(IMMEDIATE >> 0) & 0x1"
+    mpermilpd dest=xmm1, src1=xmm0m, op2=xmm1m, size=8, ext="(IMMEDIATE >> 1) & 0x1"
+    mpermilpd dest=xmm2, src1=xmm2m, op2=xmm3m, size=8, ext="(IMMEDIATE >> 2) & 0x1"
+    mpermilpd dest=xmm3, src1=xmm2m, op2=xmm3m, size=8, ext="(IMMEDIATE >> 3) & 0x1"
+    vclear dest=xmm4, destVL=32
+};
+
+def macroop VPERMILPD_YMM_M_I {
+    ldfp256 ufp1, seg, sib, "DISPLACEMENT + 0", dataSize=32
+    mpermilpd dest=xmm0, src1=ufp1, op2=ufp2, size=8, ext="(IMMEDIATE >> 0) & 0x1"
+    mpermilpd dest=xmm1, src1=ufp1, op2=ufp2, size=8, ext="(IMMEDIATE >> 1) & 0x1"
+    mpermilpd dest=xmm2, src1=ufp3, op2=ufp4, size=8, ext="(IMMEDIATE >> 2) & 0x1"
+    mpermilpd dest=xmm3, src1=ufp3, op2=ufp4, size=8, ext="(IMMEDIATE >> 3) & 0x1"
+    vclear dest=xmm4, destVL=32
+};
+
+def macroop VPERMILPD_YMM_P_I {
+    rdip t7
+    ldfp256 ufp1, seg, riprel, "DISPLACEMENT + 0", dataSize=32
+    mpermilpd dest=xmm0, src1=ufp1, op2=ufp2, size=8, ext="(IMMEDIATE >> 0) & 0x1"
+    mpermilpd dest=xmm1, src1=ufp1, op2=ufp2, size=8, ext="(IMMEDIATE >> 1) & 0x1"
+    mpermilpd dest=xmm2, src1=ufp3, op2=ufp4, size=8, ext="(IMMEDIATE >> 2) & 0x1"
+    mpermilpd dest=xmm3, src1=ufp3, op2=ufp4, size=8, ext="(IMMEDIATE >> 3) & 0x1"
+    vclear dest=xmm4, destVL=32
+};
+
+def macroop VPERMILPD_ZMM_ZMM_I {
+    mpermilpd dest=xmm0, src1=xmm0m, op2=xmm1m, size=8, ext="(IMMEDIATE >> 0) & 0x1"
+    mpermilpd dest=xmm1, src1=xmm0m, op2=xmm1m, size=8, ext="(IMMEDIATE >> 1) & 0x1"
+    mpermilpd dest=xmm2, src1=xmm2m, op2=xmm3m, size=8, ext="(IMMEDIATE >> 2) & 0x1"
+    mpermilpd dest=xmm3, src1=xmm2m, op2=xmm3m, size=8, ext="(IMMEDIATE >> 3) & 0x1"
+    mpermilpd dest=xmm4, src1=xmm4m, op2=xmm5m, size=8, ext="(IMMEDIATE >> 4) & 0x1"
+    mpermilpd dest=xmm5, src1=xmm4m, op2=xmm5m, size=8, ext="(IMMEDIATE >> 5) & 0x1"
+    mpermilpd dest=xmm6, src1=xmm6m, op2=xmm7m, size=8, ext="(IMMEDIATE >> 6) & 0x1"
+    mpermilpd dest=xmm7, src1=xmm6m, op2=xmm7m, size=8, ext="(IMMEDIATE >> 7) & 0x1"
+};
+
+def macroop VPERMILPD_ZMM_M_I {
+    ldfp512 ufp1, seg, sib, "DISPLACEMENT + 0", dataSize=64
+    mpermilpd dest=xmm0, src1=ufp1, op2=ufp2, size=8, ext="(IMMEDIATE >> 0) & 0x1"
+    mpermilpd dest=xmm1, src1=ufp1, op2=ufp2, size=8, ext="(IMMEDIATE >> 1) & 0x1"
+    mpermilpd dest=xmm2, src1=ufp3, op2=ufp4, size=8, ext="(IMMEDIATE >> 2) & 0x1"
+    mpermilpd dest=xmm3, src1=ufp3, op2=ufp4, size=8, ext="(IMMEDIATE >> 3) & 0x1"
+    mpermilpd dest=xmm4, src1=ufp5, op2=ufp6, size=8, ext="(IMMEDIATE >> 4) & 0x1"
+    mpermilpd dest=xmm5, src1=ufp5, op2=ufp6, size=8, ext="(IMMEDIATE >> 5) & 0x1"
+    mpermilpd dest=xmm6, src1=ufp7, op2=ufp8, size=8, ext="(IMMEDIATE >> 6) & 0x1"
+    mpermilpd dest=xmm7, src1=ufp7, op2=ufp8, size=8, ext="(IMMEDIATE >> 7) & 0x1"
+};
+
+def macroop VPERMILPD_ZMM_P_I {
+    rdip t7
+    ldfp512 ufp1, seg, riprel, "DISPLACEMENT + 0", dataSize=64
+    mpermilpd dest=xmm0, src1=ufp1, op2=ufp2, size=8, ext="(IMMEDIATE >> 0) & 0x1"
+    mpermilpd dest=xmm1, src1=ufp1, op2=ufp2, size=8, ext="(IMMEDIATE >> 1) & 0x1"
+    mpermilpd dest=xmm2, src1=ufp3, op2=ufp4, size=8, ext="(IMMEDIATE >> 2) & 0x1"
+    mpermilpd dest=xmm3, src1=ufp3, op2=ufp4, size=8, ext="(IMMEDIATE >> 3) & 0x1"
+    mpermilpd dest=xmm4, src1=ufp5, op2=ufp6, size=8, ext="(IMMEDIATE >> 4) & 0x1"
+    mpermilpd dest=xmm5, src1=ufp5, op2=ufp6, size=8, ext="(IMMEDIATE >> 5) & 0x1"
+    mpermilpd dest=xmm6, src1=ufp7, op2=ufp8, size=8, ext="(IMMEDIATE >> 6) & 0x1"
+    mpermilpd dest=xmm7, src1=ufp7, op2=ufp8, size=8, ext="(IMMEDIATE >> 7) & 0x1"
+};
+'''
\ No newline at end of file
diff --git a/src/arch/x86/isa/insts/simd512/floating_point/data_transfer/vpermilps.py b/src/arch/x86/isa/insts/simd512/floating_point/data_transfer/vpermilps.py
new file mode 100644
index 0000000000..4a287ccfdf
--- /dev/null
+++ b/src/arch/x86/isa/insts/simd512/floating_point/data_transfer/vpermilps.py
@@ -0,0 +1,54 @@
+microcode = '''
+
+def macroop VPERMILPS_XMM_XMM_I {
+    mpermilps dest=ufp1, src1=xmm0m, op2=xmm1m, size=4, ext="(IMMEDIATE >> 0) & 0xF"
+    mpermilps dest=xmm1, src1=xmm0m, op2=xmm1m, size=4, ext="(IMMEDIATE >> 4) & 0xF"
+    movfp xmm0, ufp1, dataSize=8
+    vclear dest=xmm2, destVL=16
+};
+
+def macroop VPERMILPS_XMM_M_I {
+    ldfp128 ufp1, seg, sib, "DISPLACEMENT + 0", dataSize=16
+    mpermilps dest=xmm0, src1=ufp1, op2=ufp2, size=4, ext="(IMMEDIATE >> 0) & 0xF"
+    mpermilps dest=xmm1, src1=ufp1, op2=ufp2, size=4, ext="(IMMEDIATE >> 4) & 0xF"
+    vclear dest=xmm2, destVL=16
+};
+
+def macroop VPERMILPS_XMM_P_I {
+    rdip t7
+    ldfp128 ufp1, seg, riprel, "DISPLACEMENT + 0", dataSize=16
+    mpermilps dest=xmm0, src1=ufp1, op2=ufp2, size=4, ext="(IMMEDIATE >> 0) & 0xF"
+    mpermilps dest=xmm1, src1=ufp1, op2=ufp2, size=4, ext="(IMMEDIATE >> 4) & 0xF"
+    vclear dest=xmm2, destVL=16
+};
+
+def macroop VPERMILPS_YMM_YMM_I {
+    mpermilps dest=ufp1, src1=xmm0m, op2=xmm1m, size=4, ext="(IMMEDIATE >> 0) & 0xF"
+    mpermilps dest=xmm1, src1=xmm0m, op2=xmm1m, size=4, ext="(IMMEDIATE >> 4) & 0xF"
+    mpermilps dest=ufp2, src1=xmm2m, op2=xmm3m, size=4, ext="(IMMEDIATE >> 0) & 0xF"
+    mpermilps dest=xmm3, src1=xmm2m, op2=xmm3m, size=4, ext="(IMMEDIATE >> 4) & 0xF"
+    movfp xmm0, ufp1, dataSize=8
+    movfp xmm2, ufp2, dataSize=8
+    vclear dest=xmm4, destVL=32
+};
+
+def macroop VPERMILPS_YMM_M_I {
+    ldfp256 ufp1, seg, sib, "DISPLACEMENT + 0", dataSize=32
+    mpermilps dest=xmm0, src1=ufp1, op2=ufp2, size=4, ext="(IMMEDIATE >> 0) & 0xF"
+    mpermilps dest=xmm1, src1=ufp1, op2=ufp2, size=4, ext="(IMMEDIATE >> 4) & 0xF"
+    mpermilps dest=xmm2, src1=ufp3, op2=ufp4, size=4, ext="(IMMEDIATE >> 0) & 0xF"
+    mpermilps dest=xmm3, src1=ufp3, op2=ufp4, size=4, ext="(IMMEDIATE >> 4) & 0xF"
+    vclear dest=xmm4, destVL=32
+};
+
+def macroop VPERMILPS_YMM_P_I {
+    rdip t7
+    ldfp256 ufp1, seg, riprel, "DISPLACEMENT + 0", dataSize=32
+    mpermilps dest=xmm0, src1=ufp1, op2=ufp2, size=4, ext="(IMMEDIATE >> 0) & 0xF"
+    mpermilps dest=xmm1, src1=ufp1, op2=ufp2, size=4, ext="(IMMEDIATE >> 4) & 0xF"
+    mpermilps dest=xmm2, src1=ufp3, op2=ufp4, size=4, ext="(IMMEDIATE >> 0) & 0xF"
+    mpermilps dest=xmm3, src1=ufp3, op2=ufp4, size=4, ext="(IMMEDIATE >> 4) & 0xF"
+    vclear dest=xmm4, destVL=32
+};
+
+'''
\ No newline at end of file
diff --git a/src/arch/x86/isa/insts/simd512/floating_point/data_transfer/vpextrq.py b/src/arch/x86/isa/insts/simd512/floating_point/data_transfer/vpextrq.py
new file mode 100644
index 0000000000..4e8fb0a792
--- /dev/null
+++ b/src/arch/x86/isa/insts/simd512/floating_point/data_transfer/vpextrq.py
@@ -0,0 +1,29 @@
+microcode = '''
+
+def macroop VPEXTRQL_R_XMM_I {
+    mov2int reg, xmm0m, srcSize=8, destSize=8
+};
+
+def macroop VPEXTRQL_M_XMM_I {
+    stfp xmm0, seg, sib, disp, dataSize=8
+};
+
+def macroop VPEXTRQL_P_XMM_I {
+    rdip t7
+    stfp xmm0, seg, riprel, disp, dataSize=8
+};
+
+def macroop VPEXTRQH_R_XMM_I {
+    mov2int reg, xmm1m, srcSize=8, destSize=8
+};
+
+def macroop VPEXTRQH_M_XMM_I {
+    stfp xmm1, seg, sib, disp, dataSize=8
+};
+
+def macroop VPEXTRQH_P_XMM_I {
+    rdip t7
+    stfp xmm1, seg, riprel, disp, dataSize=8
+};
+
+'''
\ No newline at end of file
diff --git a/src/arch/x86/isa/insts/simd512/floating_point/data_transfer/vpmovdq.py b/src/arch/x86/isa/insts/simd512/floating_point/data_transfer/vpmovdq.py
new file mode 100644
index 0000000000..9617568144
--- /dev/null
+++ b/src/arch/x86/isa/insts/simd512/floating_point/data_transfer/vpmovdq.py
@@ -0,0 +1,78 @@
+microcode = '''
+
+def macroop VPMOVDQ_XMM_XMM {
+    movfpl2l dest=xmm0, src1=xmm0m, dataSize=4
+    movfpl2h dest=xmm0, src1=xmm1m, dataSize=4
+    vclear dest=xmm1, destVL=8
+};
+
+def macroop VPMOVDQ_M_XMM {
+    stfp xmm0, seg, sib, "DISPLACEMENT + 0", dataSize=4
+    stfp xmm1, seg, sib, "DISPLACEMENT + 4", dataSize=4
+};
+
+def macroop VPMOVDQ_P_XMM {
+    rdip t7
+    stfp xmm0, seg, riprel, "DISPLACEMENT + 0", dataSize=4
+    stfp xmm1, seg, riprel, "DISPLACEMENT + 4", dataSize=4
+};
+
+def macroop VPMOVDQ_XMM_YMM {
+    movfpl2l dest=xmm0, src1=xmm0m, dataSize=4
+    movfpl2h dest=xmm0, src1=xmm1m, dataSize=4
+    movfpl2l dest=xmm1, src1=xmm2m, dataSize=4
+    movfpl2h dest=xmm1, src1=xmm3m, dataSize=4
+    vclear dest=xmm2, destVL=16
+};
+
+def macroop VPMOVDQ_M_YMM {
+    stfp xmm0, seg, sib, "DISPLACEMENT + 0", dataSize=4
+    stfp xmm1, seg, sib, "DISPLACEMENT + 4", dataSize=4
+    stfp xmm2, seg, sib, "DISPLACEMENT + 8", dataSize=4
+    stfp xmm3, seg, sib, "DISPLACEMENT + 12", dataSize=4
+};
+
+def macroop VPMOVDQ_P_YMM {
+    rdip t7
+    stfp xmm0, seg, riprel, "DISPLACEMENT + 0", dataSize=4
+    stfp xmm1, seg, riprel, "DISPLACEMENT + 4", dataSize=4
+    stfp xmm2, seg, riprel, "DISPLACEMENT + 8", dataSize=4
+    stfp xmm3, seg, riprel, "DISPLACEMENT + 12", dataSize=4
+};
+
+def macroop VPMOVDQ_YMM_ZMM {
+    movfpl2l dest=xmm0, src1=xmm0m, dataSize=4
+    movfpl2h dest=xmm0, src1=xmm1m, dataSize=4
+    movfpl2l dest=xmm1, src1=xmm2m, dataSize=4
+    movfpl2h dest=xmm1, src1=xmm3m, dataSize=4
+    movfpl2l dest=xmm2, src1=xmm4m, dataSize=4
+    movfpl2h dest=xmm2, src1=xmm5m, dataSize=4
+    movfpl2l dest=xmm3, src1=xmm6m, dataSize=4
+    movfpl2h dest=xmm3, src1=xmm7m, dataSize=4
+    vclear dest=xmm4, destVL=32
+};
+
+def macroop VPMOVDQ_M_ZMM {
+    stfp xmm0, seg, sib, "DISPLACEMENT + 0", dataSize=4
+    stfp xmm1, seg, sib, "DISPLACEMENT + 4", dataSize=4
+    stfp xmm2, seg, sib, "DISPLACEMENT + 8", dataSize=4
+    stfp xmm3, seg, sib, "DISPLACEMENT + 12", dataSize=4
+    stfp xmm4, seg, sib, "DISPLACEMENT + 16", dataSize=4
+    stfp xmm5, seg, sib, "DISPLACEMENT + 20", dataSize=4
+    stfp xmm6, seg, sib, "DISPLACEMENT + 24", dataSize=4
+    stfp xmm7, seg, sib, "DISPLACEMENT + 28", dataSize=4
+};
+
+def macroop VPMOVDQ_P_ZMM {
+    rdip t7
+    stfp xmm0, seg, riprel, "DISPLACEMENT + 0", dataSize=4
+    stfp xmm1, seg, riprel, "DISPLACEMENT + 4", dataSize=4
+    stfp xmm2, seg, riprel, "DISPLACEMENT + 8", dataSize=4
+    stfp xmm3, seg, riprel, "DISPLACEMENT + 12", dataSize=4
+    stfp xmm4, seg, riprel, "DISPLACEMENT + 16", dataSize=4
+    stfp xmm5, seg, riprel, "DISPLACEMENT + 20", dataSize=4
+    stfp xmm6, seg, riprel, "DISPLACEMENT + 24", dataSize=4
+    stfp xmm7, seg, riprel, "DISPLACEMENT + 28", dataSize=4
+};
+
+'''
\ No newline at end of file
diff --git a/src/arch/x86/isa/insts/simd512/floating_point/data_transfer/vpshufd.py b/src/arch/x86/isa/insts/simd512/floating_point/data_transfer/vpshufd.py
new file mode 100644
index 0000000000..774f67ec19
--- /dev/null
+++ b/src/arch/x86/isa/insts/simd512/floating_point/data_transfer/vpshufd.py
@@ -0,0 +1,56 @@
+microcode = '''
+
+def macroop VPSHUFD_XMM_XMM_I {
+    shuffle ufp1, xmm0m, xmm1m, size=4, ext="IMMEDIATE"
+    shuffle xmm1, xmm0m, xmm1m, size=4, ext="IMMEDIATE >> 4"
+    movfp xmm0, ufp1, dataSize=8
+};
+
+def macroop VPSHUFD_XMM_M_I {
+    ldfp ufp1, seg, sib, "DISPLACEMENT", dataSize=8
+    ldfp ufp2, seg, sib, "DISPLACEMENT + 8", dataSize=8
+    shuffle xmm0, ufp1, ufp2, size=4, ext="IMMEDIATE"
+    shuffle xmm1, ufp1, ufp2, size=4, ext="IMMEDIATE >> 4"
+};
+
+def macroop VPSHUFD_XMM_P_I {
+    rdip t7
+    ldfp ufp1, seg, riprel, "DISPLACEMENT", dataSize=8
+    ldfp ufp2, seg, riprel, "DISPLACEMENT + 8", dataSize=8
+    shuffle xmm0, ufp1, ufp2, size=4, ext="IMMEDIATE"
+    shuffle xmm1, ufp1, ufp2, size=4, ext="IMMEDIATE >> 4"
+};
+
+def macroop VPSHUFD_YMM_YMM_I {
+    shuffle ufp1, xmm0m, xmm1m, size=4, ext="IMMEDIATE"
+    shuffle xmm1, xmm0m, xmm1m, size=4, ext="IMMEDIATE >> 4"
+    shuffle ufp2, xmm2m, xmm3m, size=4, ext="IMMEDIATE"
+    shuffle xmm3, xmm2m, xmm3m, size=4, ext="IMMEDIATE >> 4"
+    movfp xmm0, ufp1, dataSize=8
+    movfp xmm2, ufp2, dataSize=8
+};
+
+def macroop VPSHUFD_YMM_M_I {
+    ldfp ufp1, seg, sib, "DISPLACEMENT", dataSize=8
+    ldfp ufp2, seg, sib, "DISPLACEMENT + 8", dataSize=8
+    ldfp ufp3, seg, sib, "DISPLACEMENT + 16", dataSize=8
+    ldfp ufp4, seg, sib, "DISPLACEMENT + 24", dataSize=8
+    shuffle xmm0, ufp1, ufp2, size=4, ext="IMMEDIATE"
+    shuffle xmm1, ufp1, ufp2, size=4, ext="IMMEDIATE >> 4"
+    shuffle xmm2, ufp3, ufp4, size=4, ext="IMMEDIATE"
+    shuffle xmm3, ufp3, ufp4, size=4, ext="IMMEDIATE >> 4"
+};
+
+def macroop VPSHUFD_YMM_P_I {
+    rdip t7
+    ldfp ufp1, seg, riprel, "DISPLACEMENT", dataSize=8
+    ldfp ufp2, seg, riprel, "DISPLACEMENT + 8", dataSize=8
+    ldfp ufp3, seg, riprel, "DISPLACEMENT + 16", dataSize=8
+    ldfp ufp4, seg, riprel, "DISPLACEMENT + 24", dataSize=8
+    shuffle xmm0, ufp1, ufp2, size=4, ext="IMMEDIATE"
+    shuffle xmm1, ufp1, ufp2, size=4, ext="IMMEDIATE >> 4"
+    shuffle xmm2, ufp3, ufp4, size=4, ext="IMMEDIATE"
+    shuffle xmm3, ufp3, ufp4, size=4, ext="IMMEDIATE >> 4"
+};
+
+'''
\ No newline at end of file
diff --git a/src/arch/x86/isa/insts/simd512/floating_point/data_transfer/vpternlog.py b/src/arch/x86/isa/insts/simd512/floating_point/data_transfer/vpternlog.py
new file mode 100644
index 0000000000..abb4182f4d
--- /dev/null
+++ b/src/arch/x86/isa/insts/simd512/floating_point/data_transfer/vpternlog.py
@@ -0,0 +1,107 @@
+microcode = '''
+
+def macroop VPTERNLOGD_XMM_XMM_I {
+    vpternlog dest=xmm0, src1=xmm0v, src2=xmm0m, imm8="(IMMEDIATE) & 0xFF", VL=16, size=4
+    vclear dest=xmm2, destVL=16
+};
+
+def macroop VPTERNLOGD_XMM_M_I {
+    ldfp512 ufp1, seg, sib, "DISPLACEMENT + 0", dataSize=16
+    vpternlog dest=xmm0, src1=xmm0v, src2=ufp1, imm8="(IMMEDIATE) & 0xFF", VL=16, size=4
+    vclear dest=xmm2, destVL=16
+};
+
+def macroop VPTERNLOGD_XMM_P_I {
+    rdip t7
+    ldfp512 ufp1, seg, riprel, "DISPLACEMENT + 0", dataSize=16
+    vpternlog dest=xmm0, src1=xmm0v, src2=ufp1, imm8="(IMMEDIATE) & 0xFF", VL=16, size=4
+    vclear dest=xmm2, destVL=16
+};
+
+def macroop VPTERNLOGD_YMM_YMM_I {
+    vpternlog dest=xmm0, src1=xmm0v, src2=xmm0m, imm8="(IMMEDIATE) & 0xFF", VL=32, size=4
+    vclear dest=xmm4, destVL=32
+};
+
+def macroop VPTERNLOGD_YMM_M_I {
+    ldfp512 ufp1, seg, sib, "DISPLACEMENT + 0", dataSize=32
+    vpternlog dest=xmm0, src1=xmm0v, src2=ufp1, imm8="(IMMEDIATE) & 0xFF", VL=32, size=4
+    vclear dest=xmm4, destVL=32
+};
+
+def macroop VPTERNLOGD_YMM_P_I {
+    rdip t7
+    ldfp512 ufp1, seg, riprel, "DISPLACEMENT + 0", dataSize=32
+    vpternlog dest=xmm0, src1=xmm0v, src2=ufp1, imm8="(IMMEDIATE) & 0xFF", VL=32, size=4
+    vclear dest=xmm4, destVL=32
+};
+
+def macroop VPTERNLOGD_ZMM_ZMM_I {
+    vpternlog dest=xmm0, src1=xmm0v, src2=xmm0m, imm8="(IMMEDIATE) & 0xFF", VL=64, size=4
+};
+
+def macroop VPTERNLOGD_ZMM_M_I {
+    ldfp512 ufp1, seg, sib, "DISPLACEMENT + 0", dataSize=64
+    vpternlog dest=xmm0, src1=xmm0v, src2=ufp1, imm8="(IMMEDIATE) & 0xFF", VL=64, size=4
+};
+
+def macroop VPTERNLOGD_ZMM_P_I {
+    rdip t7
+    ldfp512 ufp1, seg, riprel, "DISPLACEMENT + 0", dataSize=64
+    vpternlog dest=xmm0, src1=xmm0v, src2=ufp1, imm8="(IMMEDIATE) & 0xFF", VL=64, size=4
+};
+
+
+def macroop VPTERNLOGQ_XMM_XMM_I {
+    vpternlog dest=xmm0, src1=xmm0v, src2=xmm0m, imm8="(IMMEDIATE) & 0xFF", VL=16, size=8
+    vclear dest=xmm2, destVL=16
+};
+
+def macroop VPTERNLOGQ_XMM_M_I {
+    ldfp512 ufp1, seg, sib, "DISPLACEMENT + 0", dataSize=16
+    vpternlog dest=xmm0, src1=xmm0v, src2=ufp1, imm8="(IMMEDIATE) & 0xFF", VL=16, size=8
+    vclear dest=xmm2, destVL=16
+};
+
+def macroop VPTERNLOGQ_XMM_P_I {
+    rdip t7
+    ldfp512 ufp1, seg, riprel, "DISPLACEMENT + 0", dataSize=16
+    vpternlog dest=xmm0, src1=xmm0v, src2=ufp1, imm8="(IMMEDIATE) & 0xFF", VL=16, size=8
+    vclear dest=xmm2, destVL=16
+};
+
+def macroop VPTERNLOGQ_YMM_YMM_I {
+    vpternlog dest=xmm0, src1=xmm0v, src2=xmm0m, imm8="(IMMEDIATE) & 0xFF", VL=32, size=8
+    vclear dest=xmm4, destVL=32
+};
+
+def macroop VPTERNLOGQ_YMM_M_I {
+    ldfp512 ufp1, seg, sib, "DISPLACEMENT + 0", dataSize=32
+    vpternlog dest=xmm0, src1=xmm0v, src2=ufp1, imm8="(IMMEDIATE) & 0xFF", VL=32, size=8
+    vclear dest=xmm4, destVL=32
+};
+
+def macroop VPTERNLOGQ_YMM_P_I {
+    rdip t7
+    ldfp512 ufp1, seg, riprel, "DISPLACEMENT + 0", dataSize=32
+    vpternlog dest=xmm0, src1=xmm0v, src2=ufp1, imm8="(IMMEDIATE) & 0xFF", VL=32, size=8
+    vclear dest=xmm4, destVL=32
+};
+
+def macroop VPTERNLOGQ_ZMM_ZMM_I {
+    vpternlog dest=xmm0, src1=xmm0v, src2=xmm0m, imm8="(IMMEDIATE) & 0xFF", VL=64, size=8
+};
+
+def macroop VPTERNLOGQ_ZMM_M_I {
+    ldfp512 ufp1, seg, sib, "DISPLACEMENT + 0", dataSize=64
+    vpternlog dest=xmm0, src1=xmm0v, src2=ufp1, imm8="(IMMEDIATE) & 0xFF", VL=64, size=8
+};
+
+def macroop VPTERNLOGQ_ZMM_P_I {
+    rdip t7
+    ldfp512 ufp1, seg, riprel, "DISPLACEMENT + 0", dataSize=64
+    vpternlog dest=xmm0, src1=xmm0v, src2=ufp1, imm8="(IMMEDIATE) & 0xFF", VL=64, size=8
+};
+
+
+'''
\ No newline at end of file
diff --git a/src/arch/x86/isa/insts/simd512/floating_point/data_transfer/vshufps.py b/src/arch/x86/isa/insts/simd512/floating_point/data_transfer/vshufps.py
new file mode 100644
index 0000000000..8eeb8efd5e
--- /dev/null
+++ b/src/arch/x86/isa/insts/simd512/floating_point/data_transfer/vshufps.py
@@ -0,0 +1,62 @@
+microcode = '''
+
+def macroop VSHUFPS_XMM_XMM_I {
+    shuffle ufp1, xmm0v, xmm1v, size=4, ext="IMMEDIATE"
+    shuffle xmm1, xmm0m, xmm1m, size=4, ext="IMMEDIATE >> 4"
+    movfp xmm0, ufp1, dataSize=8
+};
+
+def macroop VSHUFPS_XMM_M_I {
+    ldfp ufp1, seg, sib, "DISPLACEMENT", dataSize=8
+    ldfp ufp2, seg, sib, "DISPLACEMENT + 8", dataSize=8
+    shuffle ufp3, xmm0v, xmm1v, size=4, ext="IMMEDIATE"
+    shuffle xmm1, ufp1, ufp2, size=4, ext="IMMEDIATE >> 4"
+    movfp xmm0, ufp3, dataSize=8
+};
+
+def macroop VSHUFPS_XMM_P_I {
+    rdip t7
+    ldfp ufp1, seg, riprel, "DISPLACEMENT", dataSize=8
+    ldfp ufp2, seg, riprel, "DISPLACEMENT + 8", dataSize=8
+    shuffle ufp3, xmm0v, xmm1v, size=4, ext="IMMEDIATE"
+    shuffle xmm1, ufp1, ufp2, size=4, ext="IMMEDIATE >> 4"
+    movfp xmm0, ufp3, dataSize=8
+};
+
+def macroop VSHUFPS_YMM_YMM_I {
+    shuffle ufp1, xmm0v, xmm1v, size=4, ext="IMMEDIATE"
+    shuffle xmm1, xmm0m, xmm1m, size=4, ext="IMMEDIATE >> 4"
+    shuffle ufp2, xmm2v, xmm3v, size=4, ext="IMMEDIATE"
+    shuffle xmm3, xmm2m, xmm3m, size=4, ext="IMMEDIATE >> 4"
+    movfp xmm0, ufp1, dataSize=8
+    movfp xmm2, ufp2, dataSize=8
+};
+
+def macroop VSHUFPS_YMM_M_I {
+    ldfp ufp1, seg, sib, "DISPLACEMENT", dataSize=8
+    ldfp ufp2, seg, sib, "DISPLACEMENT + 8", dataSize=8
+    ldfp ufp3, seg, sib, "DISPLACEMENT + 16", dataSize=8
+    ldfp ufp4, seg, sib, "DISPLACEMENT + 24", dataSize=8
+    shuffle ufp5, xmm0v, xmm1v, size=4, ext="IMMEDIATE"
+    shuffle xmm1, ufp1, ufp2, size=4, ext="IMMEDIATE >> 4"
+    shuffle ufp6, xmm2v, xmm3v, size=4, ext="IMMEDIATE"
+    shuffle xmm3, ufp3, ufp4, size=4, ext="IMMEDIATE >> 4"
+    movfp xmm0, ufp5, dataSize=8
+    movfp xmm2, ufp6, dataSize=8
+};
+
+def macroop VSHUFPS_YMM_P_I {
+    rdip t7
+    ldfp ufp1, seg, riprel, "DISPLACEMENT", dataSize=8
+    ldfp ufp2, seg, riprel, "DISPLACEMENT + 8", dataSize=8
+    ldfp ufp3, seg, riprel, "DISPLACEMENT + 16", dataSize=8
+    ldfp ufp4, seg, riprel, "DISPLACEMENT + 24", dataSize=8
+    shuffle ufp5, xmm0v, xmm1v, size=4, ext="IMMEDIATE"
+    shuffle xmm1, ufp1, ufp2, size=4, ext="IMMEDIATE >> 4"
+    shuffle ufp6, xmm2v, xmm3v, size=4, ext="IMMEDIATE"
+    shuffle xmm3, ufp3, ufp4, size=4, ext="IMMEDIATE >> 4"
+    movfp xmm0, ufp5, dataSize=8
+    movfp xmm2, ufp6, dataSize=8
+};
+
+'''
\ No newline at end of file
diff --git a/src/arch/x86/isa/insts/simd512/floating_point/data_transfer/vunpcks.py b/src/arch/x86/isa/insts/simd512/floating_point/data_transfer/vunpcks.py
new file mode 100644
index 0000000000..46c174b300
--- /dev/null
+++ b/src/arch/x86/isa/insts/simd512/floating_point/data_transfer/vunpcks.py
@@ -0,0 +1,93 @@
+microcode = '''
+
+def macroop VUNPCKLPS_XMM_XMM {
+    unpack xmm0, xmm0v, xmm0m, ext=0, size=4
+    unpack xmm1, xmm0v, xmm0m, ext=1, size=4
+};
+
+def macroop VUNPCKLPS_XMM_M {
+    ldfp ufp1, seg, sib, disp, dataSize=8
+    unpack xmm0, xmm0v, ufp1, ext=0, size=4
+    unpack xmm1, xmm0v, ufp1, ext=1, size=4
+};
+
+def macroop VUNPCKLPS_XMM_P {
+    rdip t7
+    ldfp ufp1, seg, riprel, disp, dataSize=8
+    unpack xmm0, xmm0v, ufp1, ext=0, size=4
+    unpack xmm1, xmm0v, ufp1, ext=1, size=4
+};
+
+def macroop VUNPCKLPS_YMM_YMM {
+    unpack xmm0, xmm0v, xmm0m, ext=0, size=4
+    unpack xmm1, xmm0v, xmm0m, ext=1, size=4
+    unpack xmm2, xmm2v, xmm2m, ext=0, size=4
+    unpack xmm3, xmm2v, xmm2m, ext=1, size=4
+};
+
+def macroop VUNPCKLPS_YMM_M {
+    ldfp ufp1, seg, sib, "DISPLACEMENT", dataSize=8
+    ldfp ufp2, seg, sib, "DISPLACEMENT + 16", dataSize=8
+    unpack xmm0, xmm0v, ufp1, ext=0, size=4
+    unpack xmm1, xmm0v, ufp1, ext=1, size=4
+    unpack xmm2, xmm2v, ufp2, ext=0, size=4
+    unpack xmm3, xmm2v, ufp2, ext=1, size=4
+};
+
+def macroop VUNPCKLPS_YMM_P {
+    rdip t7
+    ldfp ufp1, seg, riprel, "DISPLACEMENT", dataSize=8
+    ldfp ufp2, seg, riprel, "DISPLACEMENT + 16", dataSize=8
+    unpack xmm0, xmm0v, ufp1, ext=0, size=4
+    unpack xmm1, xmm0v, ufp1, ext=1, size=4
+    unpack xmm2, xmm2v, ufp2, ext=0, size=4
+    unpack xmm3, xmm2v, ufp2, ext=1, size=4
+};
+
+def macroop VUNPCKHPS_XMM_XMM {
+    unpack xmm0, xmm1v, xmm1m, ext=0, size=4
+    unpack xmm1, xmm1v, xmm1m, ext=1, size=4
+};
+
+def macroop VUNPCKHPS_XMM_M {
+    lea t1, seg, sib, disp, dataSize=asz
+    ldfp ufp1, seg, [1, t0, t1], 8, dataSize=8
+    unpack xmm0, xmm1v, ufp1, ext=0, size=4
+    unpack xmm1, xmm1v, ufp1, ext=1, size=4
+};
+
+def macroop VUNPCKHPS_XMM_P {
+    rdip t7
+    lea t1, seg, riprel, disp, dataSize=asz
+    ldfp ufp1, seg, [1, t0, t1], 8, dataSize=8
+    unpack xmm0, xmm1v, ufp1, ext=0, size=4
+    unpack xmm1, xmm1v, ufp1, ext=1, size=4
+};
+
+def macroop VUNPCKHPS_YMM_YMM {
+    unpack xmm0, xmm1v, xmm1m, ext=0, size=4
+    unpack xmm1, xmm1v, xmm1m, ext=1, size=4
+    unpack xmm2, xmm3v, xmm3m, ext=0, size=4
+    unpack xmm3, xmm3v, xmm3m, ext=1, size=4
+};
+
+def macroop VUNPCKHPS_YMM_M {
+    ldfp ufp1, seg, sib, "DISPLACEMENT + 8", dataSize=8
+    ldfp ufp2, seg, sib, "DISPLACEMENT + 24", dataSize=8
+    unpack xmm0, xmm1v, ufp1, ext=0, size=4
+    unpack xmm1, xmm1v, ufp1, ext=1, size=4
+    unpack xmm2, xmm3v, ufp2, ext=0, size=4
+    unpack xmm3, xmm3v, ufp2, ext=1, size=4
+};
+
+def macroop VUNPCKHPS_YMM_P {
+    rdip t7
+    ldfp ufp1, seg, riprel, "DISPLACEMENT + 8", dataSize=8
+    ldfp ufp2, seg, riprel, "DISPLACEMENT + 24", dataSize=8
+    unpack xmm0, xmm1v, ufp1, ext=0, size=4
+    unpack xmm1, xmm1v, ufp1, ext=1, size=4
+    unpack xmm2, xmm3v, ufp2, ext=0, size=4
+    unpack xmm3, xmm3v, ufp2, ext=1, size=4
+};
+
+'''
\ No newline at end of file
diff --git a/src/arch/x86/isa/insts/simd512/floating_point/data_transfer/vzeroupper.py b/src/arch/x86/isa/insts/simd512/floating_point/data_transfer/vzeroupper.py
new file mode 100644
index 0000000000..40c672435d
--- /dev/null
+++ b/src/arch/x86/isa/insts/simd512/floating_point/data_transfer/vzeroupper.py
@@ -0,0 +1,38 @@
+microcode = '''
+
+def macroop VZEROUPPER {
+    vclear dest="InstRegIndex(FLOATREG_XMM_IDX(0, 2))", destVL=16
+    vclear dest="InstRegIndex(FLOATREG_XMM_IDX(1, 2))", destVL=16
+    vclear dest="InstRegIndex(FLOATREG_XMM_IDX(2, 2))", destVL=16
+    vclear dest="InstRegIndex(FLOATREG_XMM_IDX(3, 2))", destVL=16
+    vclear dest="InstRegIndex(FLOATREG_XMM_IDX(4, 2))", destVL=16
+    vclear dest="InstRegIndex(FLOATREG_XMM_IDX(5, 2))", destVL=16
+    vclear dest="InstRegIndex(FLOATREG_XMM_IDX(6, 2))", destVL=16
+    vclear dest="InstRegIndex(FLOATREG_XMM_IDX(7, 2))", destVL=16
+    vclear dest="InstRegIndex(FLOATREG_XMM_IDX(8, 2))", destVL=16
+    vclear dest="InstRegIndex(FLOATREG_XMM_IDX(9, 2))", destVL=16
+    vclear dest="InstRegIndex(FLOATREG_XMM_IDX(10, 2))", destVL=16
+    vclear dest="InstRegIndex(FLOATREG_XMM_IDX(11, 2))", destVL=16
+    vclear dest="InstRegIndex(FLOATREG_XMM_IDX(12, 2))", destVL=16
+    vclear dest="InstRegIndex(FLOATREG_XMM_IDX(13, 2))", destVL=16
+    vclear dest="InstRegIndex(FLOATREG_XMM_IDX(14, 2))", destVL=16
+    vclear dest="InstRegIndex(FLOATREG_XMM_IDX(15, 2))", destVL=16
+    vclear dest="InstRegIndex(FLOATREG_XMM_IDX(16, 2))", destVL=16
+    vclear dest="InstRegIndex(FLOATREG_XMM_IDX(17, 2))", destVL=16
+    vclear dest="InstRegIndex(FLOATREG_XMM_IDX(18, 2))", destVL=16
+    vclear dest="InstRegIndex(FLOATREG_XMM_IDX(19, 2))", destVL=16
+    vclear dest="InstRegIndex(FLOATREG_XMM_IDX(20, 2))", destVL=16
+    vclear dest="InstRegIndex(FLOATREG_XMM_IDX(21, 2))", destVL=16
+    vclear dest="InstRegIndex(FLOATREG_XMM_IDX(22, 2))", destVL=16
+    vclear dest="InstRegIndex(FLOATREG_XMM_IDX(23, 2))", destVL=16
+    vclear dest="InstRegIndex(FLOATREG_XMM_IDX(24, 2))", destVL=16
+    vclear dest="InstRegIndex(FLOATREG_XMM_IDX(25, 2))", destVL=16
+    vclear dest="InstRegIndex(FLOATREG_XMM_IDX(26, 2))", destVL=16
+    vclear dest="InstRegIndex(FLOATREG_XMM_IDX(27, 2))", destVL=16
+    vclear dest="InstRegIndex(FLOATREG_XMM_IDX(28, 2))", destVL=16
+    vclear dest="InstRegIndex(FLOATREG_XMM_IDX(29, 2))", destVL=16
+    vclear dest="InstRegIndex(FLOATREG_XMM_IDX(30, 2))", destVL=16
+    vclear dest="InstRegIndex(FLOATREG_XMM_IDX(31, 2))", destVL=16
+};
+
+'''
\ No newline at end of file
diff --git a/src/arch/x86/isa/insts/simd512/integer/__init__.py b/src/arch/x86/isa/insts/simd512/integer/__init__.py
new file mode 100644
index 0000000000..5f4f865cd9
--- /dev/null
+++ b/src/arch/x86/isa/insts/simd512/integer/__init__.py
@@ -0,0 +1,11 @@
+
+categories = [
+    "arithmetic",
+]
+
+microcode = '''
+# AVX512 instructions
+'''
+for category in categories:
+    exec("from . import {s} as cat".format(s=category))
+    microcode += cat.microcode
diff --git a/src/arch/x86/isa/insts/simd512/integer/arithmetic/__init__.py b/src/arch/x86/isa/insts/simd512/integer/arithmetic/__init__.py
new file mode 100644
index 0000000000..cb5515f1ec
--- /dev/null
+++ b/src/arch/x86/isa/insts/simd512/integer/arithmetic/__init__.py
@@ -0,0 +1,15 @@
+categories = [
+    "vpaddd",
+    "vpaddq",
+    "vpandd",
+    "vpsubq",
+    "vpminsd",
+    "vpminsq",
+]
+
+microcode = '''
+# AVX512 instructions
+'''
+for category in categories:
+    exec("from . import {s} as cat".format(s=category))
+    microcode += cat.microcode
diff --git a/src/arch/x86/isa/insts/simd512/integer/arithmetic/vpaddd.py b/src/arch/x86/isa/insts/simd512/integer/arithmetic/vpaddd.py
new file mode 100644
index 0000000000..3c2938ff69
--- /dev/null
+++ b/src/arch/x86/isa/insts/simd512/integer/arithmetic/vpaddd.py
@@ -0,0 +1,46 @@
+microcode = '''
+def macroop VPADDD_XMM_XMM {
+    vaddi dest=xmm0, src1=xmm0v, src2=xmm0m, size=4, VL=16
+};
+
+def macroop VPADDD_XMM_M {
+    ldfp128 ufp1, seg, sib, "DISPLACEMENT + 0", dataSize=16
+    vaddi dest=xmm0, src1=xmm0v, src2=ufp1, size=4, VL=16
+};
+
+def macroop VPADDD_XMM_P {
+    rdip t7
+    ldfp128 ufp1, seg, riprel, "DISPLACEMENT + 0", dataSize=16
+    vaddi dest=xmm0, src1=xmm0v, src2=ufp1, size=4, VL=16
+};
+
+def macroop VPADDD_YMM_YMM {
+    vaddi dest=xmm0, src1=xmm0v, src2=xmm0m, size=4, VL=32
+};
+
+def macroop VPADDD_YMM_M {
+    ldfp256 ufp1, seg, sib, "DISPLACEMENT + 0", dataSize=32
+    vaddi dest=xmm0, src1=xmm0v, src2=ufp1, size=4, VL=32
+};
+
+def macroop VPADDD_YMM_P {
+    rdip t7
+    ldfp256 ufp1, seg, riprel, "DISPLACEMENT + 0", dataSize=32
+    vaddi dest=xmm0, src1=xmm0v, src2=ufp1, size=4, VL=32
+};
+
+def macroop VPADDD_ZMM_ZMM {
+    vaddi dest=xmm0, src1=xmm0v, src2=xmm0m, size=4, VL=64
+};
+
+def macroop VPADDD_ZMM_M {
+    ldfp512 ufp1, seg, sib, "DISPLACEMENT + 0", dataSize=64
+    vaddi dest=xmm0, src1=xmm0v, src2=ufp1, size=4, VL=64
+};
+
+def macroop VPADDD_ZMM_P {
+    rdip t7
+    ldfp512 ufp1, seg, riprel, "DISPLACEMENT + 0", dataSize=64
+    vaddi dest=xmm0, src1=xmm0v, src2=ufp1, size=4, VL=64
+};
+'''
\ No newline at end of file
diff --git a/src/arch/x86/isa/insts/simd512/integer/arithmetic/vpaddq.py b/src/arch/x86/isa/insts/simd512/integer/arithmetic/vpaddq.py
new file mode 100644
index 0000000000..c023967574
--- /dev/null
+++ b/src/arch/x86/isa/insts/simd512/integer/arithmetic/vpaddq.py
@@ -0,0 +1,46 @@
+microcode = '''
+def macroop VPADDQ_XMM_XMM {
+    vaddi dest=xmm0, src1=xmm0v, src2=xmm0m, size=8, VL=16
+};
+
+def macroop VPADDQ_XMM_M {
+    ldfp128 ufp1, seg, sib, "DISPLACEMENT + 0", dataSize=16
+    vaddi dest=xmm0, src1=xmm0v, src2=ufp1, size=8, VL=16
+};
+
+def macroop VPADDQ_XMM_P {
+    rdip t7
+    ldfp128 ufp1, seg, riprel, "DISPLACEMENT + 0", dataSize=16
+    vaddi dest=xmm0, src1=xmm0v, src2=ufp1, size=8, VL=16
+};
+
+def macroop VPADDQ_YMM_YMM {
+    vaddi dest=xmm0, src1=xmm0v, src2=xmm0m, size=8, VL=32
+};
+
+def macroop VPADDQ_YMM_M {
+    ldfp256 ufp1, seg, sib, "DISPLACEMENT + 0", dataSize=32
+    vaddi dest=xmm0, src1=xmm0v, src2=ufp1, size=8, VL=32
+};
+
+def macroop VPADDQ_YMM_P {
+    rdip t7
+    ldfp256 ufp1, seg, riprel, "DISPLACEMENT + 0", dataSize=32
+    vaddi dest=xmm0, src1=xmm0v, src2=ufp1, size=8, VL=32
+};
+
+def macroop VPADDQ_ZMM_ZMM {
+    vaddi dest=xmm0, src1=xmm0v, src2=xmm0m, size=8, VL=64
+};
+
+def macroop VPADDQ_ZMM_M {
+    ldfp512 ufp1, seg, sib, "DISPLACEMENT + 0", dataSize=64
+    vaddi dest=xmm0, src1=xmm0v, src2=ufp1, size=8, VL=64
+};
+
+def macroop VPADDQ_ZMM_P {
+    rdip t7
+    ldfp512 ufp1, seg, riprel, "DISPLACEMENT + 0", dataSize=64
+    vaddi dest=xmm0, src1=xmm0v, src2=ufp1, size=8, VL=64
+};
+'''
\ No newline at end of file
diff --git a/src/arch/x86/isa/insts/simd512/integer/arithmetic/vpandd.py b/src/arch/x86/isa/insts/simd512/integer/arithmetic/vpandd.py
new file mode 100644
index 0000000000..6eaae10a0d
--- /dev/null
+++ b/src/arch/x86/isa/insts/simd512/integer/arithmetic/vpandd.py
@@ -0,0 +1,46 @@
+microcode = '''
+def macroop VPANDD_XMM_XMM {
+    vandi dest=xmm0, src1=xmm0v, src2=xmm0m, size=4, VL=16
+};
+
+def macroop VPANDD_XMM_M {
+    ldfp128 ufp1, seg, sib, "DISPLACEMENT + 0", dataSize=16
+    vandi dest=xmm0, src1=xmm0v, src2=ufp1, size=4, VL=16
+};
+
+def macroop VPANDD_XMM_P {
+    rdip t7
+    ldfp128 ufp1, seg, riprel, "DISPLACEMENT + 0", dataSize=16
+    vandi dest=xmm0, src1=xmm0v, src2=ufp1, size=4, VL=16
+};
+
+def macroop VPANDD_YMM_YMM {
+    vandi dest=xmm0, src1=xmm0v, src2=xmm0m, size=4, VL=32
+};
+
+def macroop VPANDD_YMM_M {
+    ldfp256 ufp1, seg, sib, "DISPLACEMENT + 0", dataSize=32
+    vandi dest=xmm0, src1=xmm0v, src2=ufp1, size=4, VL=32
+};
+
+def macroop VPANDD_YMM_P {
+    rdip t7
+    ldfp256 ufp1, seg, riprel, "DISPLACEMENT + 0", dataSize=32
+    vandi dest=xmm0, src1=xmm0v, src2=ufp1, size=4, VL=32
+};
+
+def macroop VPANDD_ZMM_ZMM {
+    vandi dest=xmm0, src1=xmm0v, src2=xmm0m, size=4, VL=64
+};
+
+def macroop VPANDD_ZMM_M {
+    ldfp512 ufp1, seg, sib, "DISPLACEMENT + 0", dataSize=64
+    vandi dest=xmm0, src1=xmm0v, src2=ufp1, size=4, VL=64
+};
+
+def macroop VPANDD_ZMM_P {
+    rdip t7
+    ldfp512 ufp1, seg, riprel, "DISPLACEMENT + 0", dataSize=64
+    vandi dest=xmm0, src1=xmm0v, src2=ufp1, size=4, VL=64
+};
+'''
\ No newline at end of file
diff --git a/src/arch/x86/isa/insts/simd512/integer/arithmetic/vpminsd.py b/src/arch/x86/isa/insts/simd512/integer/arithmetic/vpminsd.py
new file mode 100644
index 0000000000..669f9e51c0
--- /dev/null
+++ b/src/arch/x86/isa/insts/simd512/integer/arithmetic/vpminsd.py
@@ -0,0 +1,46 @@
+microcode = '''
+def macroop VPMINSD_XMM_XMM {
+    vminsi dest=xmm0, src1=xmm0v, src2=xmm0m, size=4, VL=16
+};
+
+def macroop VPMINSD_XMM_M {
+    ldfp128 ufp1, seg, sib, "DISPLACEMENT + 0", dataSize=16
+    vminsi dest=xmm0, src1=xmm0v, src2=ufp1, size=4, VL=16
+};
+
+def macroop VPMINSD_XMM_P {
+    rdip t7
+    ldfp128 ufp1, seg, riprel, "DISPLACEMENT + 0", dataSize=16
+    vminsi dest=xmm0, src1=xmm0v, src2=ufp1, size=4, VL=16
+};
+
+def macroop VPMINSD_YMM_YMM {
+    vminsi dest=xmm0, src1=xmm0v, src2=xmm0m, size=4, VL=32
+};
+
+def macroop VPMINSD_YMM_M {
+    ldfp256 ufp1, seg, sib, "DISPLACEMENT + 0", dataSize=32
+    vminsi dest=xmm0, src1=xmm0v, src2=ufp1, size=4, VL=32
+};
+
+def macroop VPMINSD_YMM_P {
+    rdip t7
+    ldfp256 ufp1, seg, riprel, "DISPLACEMENT + 0", dataSize=32
+    vminsi dest=xmm0, src1=xmm0v, src2=ufp1, size=4, VL=32
+};
+
+def macroop VPMINSD_ZMM_ZMM {
+    vminsi dest=xmm0, src1=xmm0v, src2=xmm0m, size=4, VL=64
+};
+
+def macroop VPMINSD_ZMM_M {
+    ldfp512 ufp1, seg, sib, "DISPLACEMENT + 0", dataSize=64
+    vminsi dest=xmm0, src1=xmm0v, src2=ufp1, size=4, VL=64
+};
+
+def macroop VPMINSD_ZMM_P {
+    rdip t7
+    ldfp512 ufp1, seg, riprel, "DISPLACEMENT + 0", dataSize=64
+    vminsi dest=xmm0, src1=xmm0v, src2=ufp1, size=4, VL=64
+};
+'''
\ No newline at end of file
diff --git a/src/arch/x86/isa/insts/simd512/integer/arithmetic/vpminsq.py b/src/arch/x86/isa/insts/simd512/integer/arithmetic/vpminsq.py
new file mode 100644
index 0000000000..6f19dadc4b
--- /dev/null
+++ b/src/arch/x86/isa/insts/simd512/integer/arithmetic/vpminsq.py
@@ -0,0 +1,46 @@
+microcode = '''
+def macroop VPMINSQ_XMM_XMM {
+    vminsi dest=xmm0, src1=xmm0v, src2=xmm0m, size=8, VL=16
+};
+
+def macroop VPMINSQ_XMM_M {
+    ldfp128 ufp1, seg, sib, "DISPLACEMENT + 0", dataSize=16
+    vminsi dest=xmm0, src1=xmm0v, src2=ufp1, size=8, VL=16
+};
+
+def macroop VPMINSQ_XMM_P {
+    rdip t7
+    ldfp128 ufp1, seg, riprel, "DISPLACEMENT + 0", dataSize=16
+    vminsi dest=xmm0, src1=xmm0v, src2=ufp1, size=8, VL=16
+};
+
+def macroop VPMINSQ_YMM_YMM {
+    vminsi dest=xmm0, src1=xmm0v, src2=xmm0m, size=8, VL=32
+};
+
+def macroop VPMINSQ_YMM_M {
+    ldfp256 ufp1, seg, sib, "DISPLACEMENT + 0", dataSize=32
+    vminsi dest=xmm0, src1=xmm0v, src2=ufp1, size=8, VL=32
+};
+
+def macroop VPMINSQ_YMM_P {
+    rdip t7
+    ldfp256 ufp1, seg, riprel, "DISPLACEMENT + 0", dataSize=32
+    vminsi dest=xmm0, src1=xmm0v, src2=ufp1, size=8, VL=32
+};
+
+def macroop VPMINSQ_ZMM_ZMM {
+    vminsi dest=xmm0, src1=xmm0v, src2=xmm0m, size=8, VL=64
+};
+
+def macroop VPMINSQ_ZMM_M {
+    ldfp512 ufp1, seg, sib, "DISPLACEMENT + 0", dataSize=64
+    vminsi dest=xmm0, src1=xmm0v, src2=ufp1, size=8, VL=64
+};
+
+def macroop VPMINSQ_ZMM_P {
+    rdip t7
+    ldfp512 ufp1, seg, riprel, "DISPLACEMENT + 0", dataSize=64
+    vminsi dest=xmm0, src1=xmm0v, src2=ufp1, size=8, VL=64
+};
+'''
\ No newline at end of file
diff --git a/src/arch/x86/isa/insts/simd512/integer/arithmetic/vpsubq.py b/src/arch/x86/isa/insts/simd512/integer/arithmetic/vpsubq.py
new file mode 100644
index 0000000000..1b50107bae
--- /dev/null
+++ b/src/arch/x86/isa/insts/simd512/integer/arithmetic/vpsubq.py
@@ -0,0 +1,46 @@
+microcode = '''
+def macroop VPSUBQ_XMM_XMM {
+    vsubi dest=xmm0, src1=xmm0v, src2=xmm0m, size=8, VL=16
+};
+
+def macroop VPSUBQ_XMM_M {
+    ldfp128 ufp1, seg, sib, "DISPLACEMENT + 0", dataSize=16
+    vsubi dest=xmm0, src1=xmm0v, src2=ufp1, size=8, VL=16
+};
+
+def macroop VPSUBQ_XMM_P {
+    rdip t7
+    ldfp128 ufp1, seg, riprel, "DISPLACEMENT + 0", dataSize=16
+    vsubi dest=xmm0, src1=xmm0v, src2=ufp1, size=8, VL=16
+};
+
+def macroop VPSUBQ_YMM_YMM {
+    vsubi dest=xmm0, src1=xmm0v, src2=xmm0m, size=8, VL=32
+};
+
+def macroop VPSUBQ_YMM_M {
+    ldfp256 ufp1, seg, sib, "DISPLACEMENT + 0", dataSize=32
+    vsubi dest=xmm0, src1=xmm0v, src2=ufp1, size=8, VL=32
+};
+
+def macroop VPSUBQ_YMM_P {
+    rdip t7
+    ldfp256 ufp1, seg, riprel, "DISPLACEMENT + 0", dataSize=32
+    vsubi dest=xmm0, src1=xmm0v, src2=ufp1, size=8, VL=32
+};
+
+def macroop VPSUBQ_ZMM_ZMM {
+    vsubi dest=xmm0, src1=xmm0v, src2=xmm0m, size=8, VL=64
+};
+
+def macroop VPSUBQ_ZMM_M {
+    ldfp512 ufp1, seg, sib, "DISPLACEMENT + 0", dataSize=64
+    vsubi dest=xmm0, src1=xmm0v, src2=ufp1, size=8, VL=64
+};
+
+def macroop VPSUBQ_ZMM_P {
+    rdip t7
+    ldfp512 ufp1, seg, riprel, "DISPLACEMENT + 0", dataSize=64
+    vsubi dest=xmm0, src1=xmm0v, src2=ufp1, size=8, VL=64
+};
+'''
\ No newline at end of file
diff --git a/src/arch/x86/isa/macroop.isa b/src/arch/x86/isa/macroop.isa
index ccd065a6c2..d65fb85b23 100644
--- a/src/arch/x86/isa/macroop.isa
+++ b/src/arch/x86/isa/macroop.isa
@@ -126,6 +126,14 @@ def template MacroConstructor {{
             //alloc_microops is the code that sets up the microops
             //array in the parent class.
             %(alloc_microops)s;
+            /**
+             * We need this so that MinorCPU Fetch2 stage will try to predict
+             * the branch for macroop.
+             */
+            if(%(num_microops)s>0) {
+                flags[IsControl] = microops[%(num_microops)s-1]->isControl();
+                flags[IsCondControl] = microops[%(num_microops)s-1]->isCondCtrl();
+            }
         }
 }};
 
@@ -307,6 +315,12 @@ let {{
                 self.dataSize = "(REX_W ? 8 : 4)"
             elif self.size == 'q':
                 self.dataSize = 8
+            elif self.size == 'o':
+                self.dataSize = 16
+            elif self.size == 'do':
+                self.dataSize = 32
+            elif self.size == 'qo':
+                self.dataSize = 64
             elif self.size == 'v':
                 self.dataSize = "OPSIZE"
             elif self.size == 'w':
diff --git a/src/arch/x86/isa/microasm.isa b/src/arch/x86/isa/microasm.isa
index 856abac93a..170017780c 100644
--- a/src/arch/x86/isa/microasm.isa
+++ b/src/arch/x86/isa/microasm.isa
@@ -64,7 +64,7 @@ let {{
     # Add in symbols for the microcode registers
     for num in range(16):
         assembler.symbols["t%d" % num] = regIdx("NUM_INTREGS+%d" % num)
-    for num in range(8):
+    for num in range(16):
         assembler.symbols["ufp%d" % num] = \
             regIdx("FLOATREG_MICROFP(%d)" % num)
     # Add in symbols for the segment descriptor registers
@@ -89,9 +89,33 @@ let {{
         "reg" : regIdx("env.reg"),
         "xmml" : regIdx("FLOATREG_XMM_LOW(env.reg)"),
         "xmmh" : regIdx("FLOATREG_XMM_HIGH(env.reg)"),
+        "xmm0" : regIdx("FLOATREG_XMM_IDX(env.reg, 0)"),
+        "xmm1" : regIdx("FLOATREG_XMM_IDX(env.reg, 1)"),
+        "xmm2" : regIdx("FLOATREG_XMM_IDX(env.reg, 2)"),
+        "xmm3" : regIdx("FLOATREG_XMM_IDX(env.reg, 3)"),
+        "xmm4" : regIdx("FLOATREG_XMM_IDX(env.reg, 4)"),
+        "xmm5" : regIdx("FLOATREG_XMM_IDX(env.reg, 5)"),
+        "xmm6" : regIdx("FLOATREG_XMM_IDX(env.reg, 6)"),
+        "xmm7" : regIdx("FLOATREG_XMM_IDX(env.reg, 7)"),
         "regm" : regIdx("env.regm"),
         "xmmlm" : regIdx("FLOATREG_XMM_LOW(env.regm)"),
         "xmmhm" : regIdx("FLOATREG_XMM_HIGH(env.regm)"),
+        "xmm0m" : regIdx("FLOATREG_XMM_IDX(env.regm, 0)"),
+        "xmm1m" : regIdx("FLOATREG_XMM_IDX(env.regm, 1)"),
+        "xmm2m" : regIdx("FLOATREG_XMM_IDX(env.regm, 2)"),
+        "xmm3m" : regIdx("FLOATREG_XMM_IDX(env.regm, 3)"),
+        "xmm4m" : regIdx("FLOATREG_XMM_IDX(env.regm, 4)"),
+        "xmm5m" : regIdx("FLOATREG_XMM_IDX(env.regm, 5)"),
+        "xmm6m" : regIdx("FLOATREG_XMM_IDX(env.regm, 6)"),
+        "xmm7m" : regIdx("FLOATREG_XMM_IDX(env.regm, 7)"),
+        "xmm0v" : regIdx("FLOATREG_XMM_IDX(machInst.evex.v_extend, 0)"),
+        "xmm1v" : regIdx("FLOATREG_XMM_IDX(machInst.evex.v_extend, 1)"),
+        "xmm2v" : regIdx("FLOATREG_XMM_IDX(machInst.evex.v_extend, 2)"),
+        "xmm3v" : regIdx("FLOATREG_XMM_IDX(machInst.evex.v_extend, 3)"),
+        "xmm4v" : regIdx("FLOATREG_XMM_IDX(machInst.evex.v_extend, 4)"),
+        "xmm5v" : regIdx("FLOATREG_XMM_IDX(machInst.evex.v_extend, 5)"),
+        "xmm6v" : regIdx("FLOATREG_XMM_IDX(machInst.evex.v_extend, 6)"),
+        "xmm7v" : regIdx("FLOATREG_XMM_IDX(machInst.evex.v_extend, 7)"),
         "mmx" : regIdx("FLOATREG_MMX(env.reg)"),
         "mmxm" : regIdx("FLOATREG_MMX(env.regm)"),
         "imm" : "adjustedImm",
diff --git a/src/arch/x86/isa/microops/avxop.isa b/src/arch/x86/isa/microops/avxop.isa
new file mode 100644
index 0000000000..e85f74a2dd
--- /dev/null
+++ b/src/arch/x86/isa/microops/avxop.isa
@@ -0,0 +1,473 @@
+def template AVXOpExecute {{
+        Fault %(class_name)s::execute(
+            ExecContext *xc, Trace::InstRecord *traceData) const
+        {
+            Fault fault = NoFault;
+
+            %(op_decl)s;
+            %(op_rd)s;
+
+            %(code)s;
+
+            //Write the resulting state to the execution context
+            if(fault == NoFault)
+            {
+                %(op_wb)s;
+            }
+            return fault;
+        }
+}};
+
+def template AVXOpDeclare {{
+    class %(class_name)s : public %(base_class)s
+    {
+      public:
+        %(class_name)s(ExtMachInst _machInst, const char *_instMnem,
+                  uint64_t _setFlags, SrcType _srcType,
+                  InstRegIndex _dest, InstRegIndex _src1,
+                  InstRegIndex _src2, uint8_t _destSize, uint8_t _destVL,
+                  uint8_t _srcSize, uint8_t _srcVL,
+                  uint8_t _imm8, uint8_t _ext);
+
+        Fault execute(ExecContext *, Trace::InstRecord *) const;
+    };
+}};
+
+def template AVXOpConstructor {{
+    %(class_name)s::%(class_name)s(
+        ExtMachInst _machInst, const char *_instMnem,
+        uint64_t _setFlags, SrcType _srcType,
+        InstRegIndex _dest, InstRegIndex _src1,
+        InstRegIndex _src2, uint8_t _destSize, uint8_t _destVL,
+        uint8_t _srcSize, uint8_t _srcVL,
+        uint8_t _imm8, uint8_t _ext)
+        : %(base_class)s(_machInst, "%(mnemonic)s", _instMnem, _setFlags,
+        %(op_class)s, _srcType, _dest, _src1, _src2, _destSize, _destVL,
+        _srcSize, _srcVL, _imm8, _ext)
+    {
+        %(constructor)s;
+        %(constructorCode)s;
+    }
+}};
+
+let {{
+
+    import six
+
+    # Make these empty strings so that concatenating onto
+    # them will always work.
+    header_output = ""
+    decoder_output = ""
+    exec_output = ""
+
+    class AVXOpMeta(type):
+        def buildCppClasses(self, name, Name, suffix,
+            constructorCode, code, additional_params):
+
+            # Globals to stick the output in
+            global header_output
+            global decoder_output
+            global exec_output
+
+            base = "X86ISA::AVXOpBase"
+            templates = (
+                AVXOpDeclare,
+                AVXOpConstructor,
+                AVXOpExecute
+            )
+
+            # Get everything ready for the substitution
+            opt_args = []
+            if self.opClass:
+                opt_args.append(self.opClass)
+            iop = InstObjParams(
+                name,
+                Name + suffix,
+                base,
+                {
+                    "constructorCode": constructorCode,
+                    "code" : code
+                },
+                opt_args
+            )
+
+            # Generate the actual code (finally!)
+            header_output += templates[0].subst(iop)
+            decoder_output += templates[1].subst(iop)
+            exec_output += templates[2].subst(iop)
+
+
+        def __new__(mcls, Name, bases, dict):
+            abstract = False
+            name = Name.lower()
+            if "abstract" in dict:
+                abstract = dict['abstract']
+                del dict['abstract']
+            if not "opClass" in dict:
+                dict["opClass"] = None
+
+            cls = super(AVXOpMeta, mcls).__new__(mcls, Name, bases, dict)
+            if not abstract:
+                cls.className = Name
+                cls.base_mnemonic = name
+                constructorCode = cls.constructorCode
+                code = cls.code
+
+                # Set up the C++ classes
+                additional_params = []
+                if hasattr(cls, 'opClass'):
+                    additional_params.append(cls.opClass)
+                mcls.buildCppClasses(cls, name, Name, "",
+                    constructorCode, code, additional_params)
+
+                # Hook into the microassembler dict
+                global microopClasses
+                microopClasses[name] = cls
+
+            return cls
+
+    @six.add_metaclass(AVXOpMeta)
+    class AVXOp(X86Microop):
+        # This class itself doesn't act as a microop
+        abstract = True
+
+        def __init__(self, dest,
+            src1='InstRegIndex(0)',
+            src2='InstRegIndex(0)',
+            destSize=0,
+            destVL=16,
+            srcSize=0,
+            srcVL=16,
+            imm8=0,
+            ext=0):
+            self.dest = dest
+            self.src1 = src1
+            self.src2 = src2
+            self.destSize = destSize
+            self.destVL = destVL
+            self.srcSize = srcSize
+            self.srcVL = srcVL
+            self.imm8 = imm8
+            self.ext = ext
+
+        def getAllocator(self, microFlags):
+            className = self.className
+            allocator = '''new %(class_name)s(machInst, macrocodeBlock,
+                    %(flags)s, %(srcType)s, %(dest)s, %(src1)s, %(src2)s,
+                    %(destSize)s, %(destVL)s, %(srcSize)s, %(srcVL)s, %(imm8)s, %(ext)s)''' % {
+                "class_name" : className,
+                "flags" : self.microFlagsText(microFlags),
+                "srcType": self.srcType,
+                "src1" : self.src1, "src2" : self.src2,
+                "dest" : self.dest,
+                "srcSize" : self.srcSize,
+                "srcVL": self.srcVL,
+                "destSize" : self.destSize,
+                "destVL": self.destVL,
+                "imm8": self.imm8,
+                "ext" : self.ext}
+            return allocator
+
+    class Vclear(AVXOp):
+        # Helper microop to clear higher bits.
+        def __init__(self, dest, destVL):
+            super(Vclear, self).__init__(
+                dest=dest,
+                destVL=destVL,
+                destSize=64 - destVL,
+            )
+        opClass = 'SimdMiscOp'
+        srcType = 'AVXOpBase::SrcType::Non'
+        constructorCode = '''
+            // Add MAXVL-1:VL to destination.
+            auto vRegs = destVL / sizeof(uint64_t);
+            assert(vRegs <= NumXMMSubRegs && "VL overflow.");
+            _numDestRegs = NumXMMSubRegs - vRegs;
+            assert(_numDestRegs <= MaxInstDestRegs && "DestRegs overflow.");
+            assert(NumXMMSubRegs == 8 && "We assume 64-byte zmm registers.");
+            _numFPDestRegs = _numDestRegs;
+            for (int i = 0; i < _numDestRegs; i++) {
+                setDestRegIdx(i, RegId(FloatRegClass, dest + i));
+            }
+        '''
+        code = '''
+            for (int i = 0; i < _numDestRegs; i++) {
+                xc->setFloatRegOperandBits(this, i, 0);
+            }
+        '''
+
+    class Varithp(AVXOp):
+        # Used in packed arithmetic ops, e.g. vaddps.
+        abstract = True
+        def __init__(self, dest, src1, src2, size, VL):
+            super(Varithp, self).__init__(
+                dest=dest, src1=src1, src2=src2,
+                destSize=size, destVL=VL, srcSize=size, srcVL=VL
+            )
+        srcType = 'AVXOpBase::SrcType::RegReg'
+        constructorCode = '''
+            this->addAVXDestRegs();
+            auto vRegs = destVL / sizeof(uint64_t);
+            _numSrcRegs = 2 * vRegs;
+            assert(_numSrcRegs <= MaxInstSrcRegs && "SrcRegs overflow.");
+            for (int i = 0; i < vRegs; i++) {
+                setSrcRegIdx(i * 2 + 0, RegId(FloatRegClass, src1 + i));
+                setSrcRegIdx(i * 2 + 1, RegId(FloatRegClass, src2 + i));
+            }
+        '''
+
+    class Vaddf(Varithp):
+        opClass = 'SimdFloatAddOp'
+        code = '''
+            this->doPackedBinaryOp(xc, BinaryOp::FloatAdd);
+        '''
+
+    class Vandf(Varithp):
+        opClass = 'SimdAddOp'
+        code = '''
+            this->doPackedBinaryOp(xc, BinaryOp::IntAnd);
+        '''
+
+    class Vsubf(Varithp):
+        opClass = 'SimdFloatAddOp'
+        code = '''
+            this->doPackedBinaryOp(xc, BinaryOp::FloatSub);
+        '''
+
+    class Vmulf(Varithp):
+        opClass = 'SimdFloatMultOp'
+        code = '''
+            this->doPackedBinaryOp(xc, BinaryOp::FloatMul);
+        '''
+
+    class Vdivf(Varithp):
+        opClass = 'SimdFloatDivOp'
+        code = '''
+            this->doPackedBinaryOp(xc, BinaryOp::FloatDiv);
+        '''
+
+    class Vaddi(Varithp):
+        opClass = 'SimdAddOp'
+        code = '''
+            this->doPackedBinaryOp(xc, BinaryOp::IntAdd);
+        '''
+
+    class Vsubi(Varithp):
+        opClass = 'SimdAddOp'
+        code = '''
+            this->doPackedBinaryOp(xc, BinaryOp::IntSub);
+        '''
+
+    class Vandi(Varithp):
+        opClass = 'SimdAddOp'
+        code = '''
+            this->doPackedBinaryOp(xc, BinaryOp::IntAnd);
+        '''
+
+    class Vminsi(Varithp):
+        opClass = 'SimdCmpOp'
+        code = '''
+            this->doPackedBinaryOp(xc, BinaryOp::SIntMin);
+        '''
+    
+    class Vfused(AVXOp):
+        # Used in packed arithmetic ops with three operands, e.g. vfmaddps
+        abstract = True
+        def __init__(self, dest, src1, src2, size, VL):
+            super(Vfused, self).__init__(
+                dest=dest, src1=src1, src2=src2,
+                destSize=size, destVL=VL, srcSize=size, srcVL=VL
+            )
+        srcType = 'AVXOpBase::SrcType::RegRegReg'
+        constructorCode = '''
+            this->addAVXDestRegs();
+            auto vRegs = destVL / sizeof(uint64_t);
+            _numSrcRegs = 3 * vRegs;
+            assert(_numSrcRegs <= MaxInstSrcRegs && "SrcRegs overflow.");
+            for (int i = 0; i < vRegs; i++) {
+                setSrcRegIdx(i * 3 + 0, RegId(FloatRegClass, src1 + i));
+                setSrcRegIdx(i * 3 + 1, RegId(FloatRegClass, src2 + i));
+                setSrcRegIdx(i * 3 + 2, RegId(FloatRegClass, dest + i));
+            }
+        '''
+    
+    class Vfmadd231f(Vfused):
+        opClass = 'SimdFloatMultOp'
+        code = '''
+            this->doFusedPackedBinaryOp(xc, BinaryOp::FloatMul, BinaryOp::FloatAdd);
+        '''
+
+    class Vbroadcast8(AVXOp):
+        def __init__(self, dest, src, destVL):
+            super(Vbroadcast8, self).__init__(
+                dest=dest, src1=src, destVL=destVL
+            )
+        srcType = 'AVXOpBase::SrcType::Reg'
+        constructorCode = '''
+            this->addAVXDestRegs();
+            _numSrcRegs = 1;
+            setSrcRegIdx(0, RegId(FloatRegClass, src1));
+        '''
+        code = '''
+            FloatInt src;
+            src.ul = xc->readFloatRegOperandBits(this, 0);
+            src.uc.i2 = src.uc.i1;
+            src.uc.i3 = src.uc.i1;
+            src.uc.i4 = src.uc.i1;
+            src.uc.i5 = src.uc.i1;
+            src.uc.i6 = src.uc.i1;
+            src.uc.i7 = src.uc.i1;
+            src.uc.i8 = src.uc.i1;
+            auto vDestRegs = destVL / sizeof(uint64_t);
+            for (int i = 0; i < vDestRegs; ++i) {
+                xc->setFloatRegOperandBits(this, i, src.ul);
+            }
+        '''
+
+    class Vbroadcast32(AVXOp):
+        def __init__(self, dest, src, destVL):
+            super(Vbroadcast32, self).__init__(
+                dest=dest, src1=src, destVL=destVL
+            )
+        srcType = 'AVXOpBase::SrcType::Reg'
+        constructorCode = '''
+            this->addAVXDestRegs();
+            _numSrcRegs = 1;
+            setSrcRegIdx(0, RegId(FloatRegClass, src1));
+        '''
+        code = '''
+            FloatInt src;
+            src.ul = xc->readFloatRegOperandBits(this, 0);
+            src.ui.i2 = src.ui.i1;
+            auto vDestRegs = destVL / sizeof(uint64_t);
+            for (int i = 0; i < vDestRegs; ++i) {
+                xc->setFloatRegOperandBits(this, i, src.ul);
+            }
+        '''
+
+    class Vbroadcast64(AVXOp):
+        def __init__(self, dest, src, destVL):
+            super(Vbroadcast64, self).__init__(
+                dest=dest, src1=src, destVL=destVL
+            )
+        srcType = 'AVXOpBase::SrcType::Reg'
+        constructorCode = '''
+            this->addAVXDestRegs();
+            _numSrcRegs = 1;
+            setSrcRegIdx(0, RegId(FloatRegClass, src1));
+        '''
+        code = '''
+            FloatInt src;
+            src.ul = xc->readFloatRegOperandBits(this, 0);
+            auto vDestRegs = destVL / sizeof(uint64_t);
+            for (int i = 0; i < vDestRegs; ++i) {
+                xc->setFloatRegOperandBits(this, i, src.ul);
+            }
+        '''
+
+    class Vcvtp(AVXOp):
+        # Used in packed convert ops, e.g. vcvtps2pd.
+        abstract = True
+        def __init__(self, dest, src, VL):
+            super(Varithp, self).__init__(
+                dest=dest, src1=src1, destVL=VL, srcVL=VL
+            )
+        srcType = 'AVXOpBase::SrcType::Reg'
+        constructorCode = '''
+            this->addAVXDestRegs();
+            auto vRegs = destVL / sizeof(uint64_t);
+            _numSrcRegs = vRegs;
+            assert(_numSrcRegs <= MaxInstSrcRegs && "SrcRegs overflow.");
+            for (int i = 0; i < vRegs; i++) {
+                setSrcRegIdx(i, RegId(FloatRegClass, src1 + i));
+            }
+        '''
+
+    class Valign(AVXOp):
+        def __init__(self, dest, src1, src2, imm8, VL, size):
+            super(Valign, self).__init__(
+                dest=dest, src1=src1, src2=src2, imm8=imm8,
+                srcVL=VL, destVL=VL, srcSize=size, destSize=size,
+            )
+        srcType = 'AVXOpBase::SrcType::RegRegImm'
+        constructorCode = '''
+            this->addAVXDestRegs();
+            auto vRegs = srcVL / sizeof(uint64_t);
+            _numSrcRegs = 2 * vRegs;
+            assert(_numSrcRegs <= MaxInstSrcRegs && "SrcRegs overflow.");
+            // First src1, then src2.
+            for (int i = 0; i < vRegs; i++) {
+                setSrcRegIdx(i, RegId(FloatRegClass, src1 + i));
+                setSrcRegIdx(i + vRegs, RegId(FloatRegClass, src2 + i));
+            }
+        '''
+        code = '''
+            int shift = imm8;
+            auto vDestRegs = destVL / sizeof(uint64_t);
+            FloatInt src;
+            if (srcSize == 8) {
+                for (int i = 0; i < vDestRegs; ++i) {
+                    auto idx = i + shift;
+                    src.ul = xc->readFloatRegOperandBits(this, idx);
+                    xc->setFloatRegOperandBits(this, i, src.ul);
+                }
+            } else if (srcSize == 4) {
+                if (shift % 2 == 0) {
+                    for (int i = 0; i < vDestRegs; ++i) {
+                        auto idx = i + shift / 2;
+                        src.ul = xc->readFloatRegOperandBits(this, idx);
+                        xc->setFloatRegOperandBits(this, i, src.ul);
+                    }
+                } else {
+                    for (int i = 0; i < vDestRegs; ++i) {
+                        auto idx = i + shift / 2;
+                        src.ul = xc->readFloatRegOperandBits(this, idx);
+                        FloatInt result;
+                        result.ui.i1 = src.ui.i2;
+                        src.ul = xc->readFloatRegOperandBits(this, idx + 1);
+                        result.ui.i2 = src.ui.i1;
+                        xc->setFloatRegOperandBits(this, i, result.ul);
+                    }
+                }
+            }
+        '''
+
+    class Vpternlog(AVXOp):
+        def __init__(self, dest, src1, src2, imm8, VL, size):
+            super(Vpternlog, self).__init__(
+                dest=dest, src1=src1, src2=src2, imm8=imm8,
+                srcVL=VL, destVL=VL, srcSize=size, destSize=size,
+            )
+            # So far destSize/srcSize is not used.
+        srcType = 'AVXOpBase::SrcType::RegRegImm'
+        constructorCode = '''
+            this->addAVXDestRegs();
+            auto vRegs = srcVL / sizeof(uint64_t);
+            _numSrcRegs = 3 * vRegs;
+            assert(_numSrcRegs <= MaxInstSrcRegs && "SrcRegs overflow.");
+            // First dest, src1, then src2.
+            for (int i = 0; i < vRegs; i++) {
+                setSrcRegIdx(i * 3 + 0, RegId(FloatRegClass, dest + i));
+                setSrcRegIdx(i * 3 + 1, RegId(FloatRegClass, src1 + i));
+                setSrcRegIdx(i * 3 + 2, RegId(FloatRegClass, src2 + i));
+            }
+        '''
+        code = '''
+            auto vDestRegs = destVL / sizeof(uint64_t);
+            for (int i = 0; i < vDestRegs; ++i) {
+                uint64_t result = 0;
+                uint64_t destValue = xc->readFloatRegOperandBits(this, i * 3 + 0);
+                uint64_t src1Value = xc->readFloatRegOperandBits(this, i * 3 + 1);
+                uint64_t src2Value = xc->readFloatRegOperandBits(this, i * 3 + 2);
+                for (int bit = 0; bit < sizeof(uint64_t) * 8; ++bit) {
+                    int destBit = (destValue >> bit) & 0x1;
+                    int src1Bit = (src1Value >> bit) & 0x1;
+                    int src2Bit = (src2Value >> bit) & 0x1;
+                    int idx = (destBit << 2) | (src1Bit << 1) | src2Bit;
+                    int resultBit = (imm8 >> idx) & 0x1;
+                    result |= (resultBit << bit);
+                }
+                xc->setFloatRegOperandBits(this, i, result);
+            }
+        '''
+}};
diff --git a/src/arch/x86/isa/microops/fpop.isa b/src/arch/x86/isa/microops/fpop.isa
index 238fa93108..976fb5ea86 100644
--- a/src/arch/x86/isa/microops/fpop.isa
+++ b/src/arch/x86/isa/microops/fpop.isa
@@ -76,16 +76,13 @@ def template MicroFpOpExecute {{
 def template MicroFpOpDeclare {{
     class %(class_name)s : public %(base_class)s
     {
-      private:
-        %(reg_idx_arr_decl)s;
-
       public:
         %(class_name)s(ExtMachInst _machInst,
                 const char * instMnem, uint64_t setFlags,
                 InstRegIndex _src1, InstRegIndex _src2, InstRegIndex _dest,
                 uint8_t _dataSize, int8_t _spm);
 
-        Fault execute(ExecContext *, Trace::InstRecord *) const override;
+        Fault execute(ExecContext *, Trace::InstRecord *) const;
     };
 }};
 
@@ -98,7 +95,6 @@ def template MicroFpOpConstructor {{
                 _src1, _src2, _dest, _dataSize, _spm,
                 %(op_class)s)
     {
-        %(set_reg_idx_arr)s;
         %(constructor)s;
     }
 }};
@@ -272,8 +268,69 @@ let {{
                 "spm" : self.spm}
 
     class Movfp(FpUnaryOp):
-        code = 'FpDestReg_uqw = FpSrcReg1_uqw;'
-        else_code = 'FpDestReg_uqw = FpDestReg_uqw;'
+        code = '''
+            FpDestReg_uqw = FpSrcReg1_uqw;
+            //hack("Move %s->%s %#x\\n", srcRegIdx(0), destRegIdx(0), FpSrcReg1_uqw);
+        '''
+        else_code = '''
+            FpDestReg_uqw = FpDestReg_uqw;
+            //hack("Unmove\\n");
+        '''
+        cond_check = "checkCondition(ccFlagBits | cfofBits | dfBit | \
+                                     ecfBit | ezfBit, src2)"
+        op_class = 'IntAluOp'
+
+    class Movfp128(FpUnaryOp):
+        code = '''
+            FpDestReg0_uqw = FpSrcReg1x0_uqw;
+            FpDestReg1_uqw = FpSrcReg1x1_uqw;
+        '''
+        else_code = '''
+            FpDestReg0_uqw = FpDestReg0_uqw;
+            FpDestReg1_uqw = FpDestReg1_uqw;
+        '''
+        cond_check = "checkCondition(ccFlagBits | cfofBits | dfBit | \
+                                     ecfBit | ezfBit, src2)"
+        op_class = 'IntAluOp'
+
+    class Movfp256(FpUnaryOp):
+        code = '''
+            FpDestReg0_uqw = FpSrcReg1x0_uqw;
+            FpDestReg1_uqw = FpSrcReg1x1_uqw;
+            FpDestReg2_uqw = FpSrcReg1x2_uqw;
+            FpDestReg3_uqw = FpSrcReg1x3_uqw;
+        '''
+        else_code = '''
+            FpDestReg0_uqw = FpDestReg0_uqw;
+            FpDestReg1_uqw = FpDestReg1_uqw;
+            FpDestReg2_uqw = FpDestReg2_uqw;
+            FpDestReg3_uqw = FpDestReg3_uqw;
+        '''
+        cond_check = "checkCondition(ccFlagBits | cfofBits | dfBit | \
+                                     ecfBit | ezfBit, src2)"
+        op_class = 'IntAluOp'
+
+    class Movfp512(FpUnaryOp):
+        code = '''
+            FpDestReg0_uqw = FpSrcReg1x0_uqw;
+            FpDestReg1_uqw = FpSrcReg1x1_uqw;
+            FpDestReg2_uqw = FpSrcReg1x2_uqw;
+            FpDestReg3_uqw = FpSrcReg1x3_uqw;
+            FpDestReg4_uqw = FpSrcReg1x4_uqw;
+            FpDestReg5_uqw = FpSrcReg1x5_uqw;
+            FpDestReg6_uqw = FpSrcReg1x6_uqw;
+            FpDestReg7_uqw = FpSrcReg1x7_uqw;
+        '''
+        else_code = '''
+            FpDestReg0_uqw = FpDestReg0_uqw;
+            FpDestReg1_uqw = FpDestReg1_uqw;
+            FpDestReg2_uqw = FpDestReg2_uqw;
+            FpDestReg3_uqw = FpDestReg3_uqw;
+            FpDestReg4_uqw = FpDestReg4_uqw;
+            FpDestReg5_uqw = FpDestReg5_uqw;
+            FpDestReg6_uqw = FpDestReg6_uqw;
+            FpDestReg7_uqw = FpDestReg7_uqw;
+        '''
         cond_check = "checkCondition(ccFlagBits | cfofBits | dfBit | \
                                      ecfBit | ezfBit, src2)"
         op_class = 'IntAluOp'
@@ -285,6 +342,27 @@ let {{
         code = 'FpDestReg = sqrt(FpSrcReg2);'
         op_class = 'FloatSqrtOp'
 
+    class Movfph2h(FpUnaryOp):
+        code = '''
+            uint64_t v = bits(FpSrcReg1_uqw, 63, 32);
+            FpDestReg_uqw = insertBits(FpDestReg_uqw, 63, 32, v);
+        '''
+        op_class = 'IntAluOp'
+
+    class Movfpl2h(FpUnaryOp):
+        code = '''
+            uint64_t v = bits(FpSrcReg1_uqw, 31, 0);
+            FpDestReg_uqw = insertBits(FpDestReg_uqw, 63, 32, v);
+        '''
+        op_class = 'IntAluOp'
+
+    class Movfpl2l(FpUnaryOp):
+        code = '''
+            uint64_t v = bits(FpSrcReg1_uqw, 31, 0);
+            FpDestReg_uqw = insertBits(FpDestReg_uqw, 31, 0, v);
+        '''
+        op_class = 'IntAluOp'
+
     class Cosfp(FpUnaryOp):
         code = 'FpDestReg = cos(FpSrcReg1);'
         op_class = 'FloatSqrtOp'
diff --git a/src/arch/x86/isa/microops/ldstop.isa b/src/arch/x86/isa/microops/ldstop.isa
index 79aadfa887..1276bd88cd 100644
--- a/src/arch/x86/isa/microops/ldstop.isa
+++ b/src/arch/x86/isa/microops/ldstop.isa
@@ -449,15 +449,23 @@ let {{
         name = mnemonic.lower()
 
         # Build up the all register version of this micro op
-        iops = [InstObjParams(name, Name, 'X86ISA::LdStOp',
-                              { "code": code,
-                                "ea_code": calculateEA,
-                                "memDataSize": "dataSize" })]
+        iops = [
+            InstObjParams(name, Name, 'X86ISA::LdStOp',
+                {
+                    "code": code,
+                    "ea_code": calculateEA,
+                    "memDataSize": "dataSize"
+                },
+                )]
         if big:
-            iops += [InstObjParams(name, Name + "Big", 'X86ISA::LdStOp',
-                                   { "code": bigCode,
-                                     "ea_code": calculateEA,
-                                     "memDataSize": "dataSize" })]
+            iops += [
+                InstObjParams(name, Name + "Big", 'X86ISA::LdStOp',
+                    {
+                        "code": bigCode,
+                        "ea_code": calculateEA,
+                        "memDataSize": "dataSize"
+                    },
+                    )]
         for iop in iops:
             header_output += MicroLdStOpDeclare.subst(iop)
             decoder_output += MicroLdStOpConstructor.subst(iop)
@@ -505,6 +513,28 @@ let {{
 
     defineMicroLoadOp('Ldfp', code='FpData_uqw = Mem', big = False)
 
+    # Used to implement AVX512 load, only used with 32/64-byte data.
+    defineMicroLoadOp('Ldfp128', code='''
+        FpData0_uqw = Mem_u2qw[0];
+        FpData1_uqw = Mem_u2qw[1];
+    ''', big = False)
+    defineMicroLoadOp('Ldfp256', code='''
+        FpData0_uqw = Mem_u4qw[0];
+        FpData1_uqw = Mem_u4qw[1];
+        FpData2_uqw = Mem_u4qw[2];
+        FpData3_uqw = Mem_u4qw[3];
+    ''', big = False)
+    defineMicroLoadOp('Ldfp512', code='''
+        FpData0_uqw = Mem_u8qw[0];
+        FpData1_uqw = Mem_u8qw[1];
+        FpData2_uqw = Mem_u8qw[2];
+        FpData3_uqw = Mem_u8qw[3];
+        FpData4_uqw = Mem_u8qw[4];
+        FpData5_uqw = Mem_u8qw[5];
+        FpData6_uqw = Mem_u8qw[6];
+        FpData7_uqw = Mem_u8qw[7];
+    ''', big = False)
+
     defineMicroLoadOp('Ldfp87', code='''
         switch (dataSize)
         {
@@ -634,6 +664,28 @@ let {{
 
     defineMicroStoreOp('Stfp', code='Mem = FpData_uqw;')
 
+    # Used to implement AVX512.
+    defineMicroStoreOp('Stfp128', code='''
+        Mem_u2qw[0] = FpData0_uqw;
+        Mem_u2qw[1] = FpData1_uqw;
+    ''')
+    defineMicroStoreOp('Stfp256', code='''
+        Mem_u4qw[0] = FpData0_uqw;
+        Mem_u4qw[1] = FpData1_uqw;
+        Mem_u4qw[2] = FpData2_uqw;
+        Mem_u4qw[3] = FpData3_uqw;
+    ''')
+    defineMicroStoreOp('Stfp512', code='''
+        Mem_u8qw[0] = FpData0_uqw;
+        Mem_u8qw[1] = FpData1_uqw;
+        Mem_u8qw[2] = FpData2_uqw;
+        Mem_u8qw[3] = FpData3_uqw;
+        Mem_u8qw[4] = FpData4_uqw;
+        Mem_u8qw[5] = FpData5_uqw;
+        Mem_u8qw[6] = FpData6_uqw;
+        Mem_u8qw[7] = FpData7_uqw;
+    ''')
+
     defineMicroStoreOp('Stfp87', code='''
         switch (dataSize)
         {
diff --git a/src/arch/x86/isa/microops/mediaop.isa b/src/arch/x86/isa/microops/mediaop.isa
index bf5fc67664..aea2197551 100644
--- a/src/arch/x86/isa/microops/mediaop.isa
+++ b/src/arch/x86/isa/microops/mediaop.isa
@@ -125,7 +125,7 @@ let {{
             MediaOpExecute)
 
     class MediaOpMeta(type):
-        def buildCppClasses(self, name, Name, suffix, code):
+        def buildCppClasses(self, name, Name, suffix, code, additional_params):
 
             # Globals to stick the output in
             global header_output
@@ -142,9 +142,9 @@ let {{
                     typeQual = match.group("typeQual")
                 src2_name = "%sFpSrcReg2%s" % (match.group("prefix"), typeQual)
                 self.buildCppClasses(name, Name, suffix,
-                        matcher.sub(src2_name, code))
+                        matcher.sub(src2_name, code), additional_params)
                 self.buildCppClasses(name + "i", Name, suffix + "Imm",
-                        matcher.sub("imm8", code))
+                        matcher.sub("imm8", code), additional_params)
                 return
 
             base = "X86ISA::MediaOp"
@@ -188,7 +188,10 @@ let {{
                 code = cls.code
 
                 # Set up the C++ classes
-                mcls.buildCppClasses(cls, name, Name, "", code)
+                additional_params = []
+                if hasattr(cls, 'op_class'):
+                    additional_params.append(cls.op_class)
+                mcls.buildCppClasses(cls, name, Name, "", code, additional_params)
 
                 # Hook into the microassembler dict
                 global microopClasses
@@ -365,6 +368,137 @@ let {{
                 int loIndex = (i + 0) * sizeBits;
                 result = insertBits(result, hiIndex, loIndex, resBits);
             }
+            DPRINTF(X86MediaMicroop, "shuffle sel %#x %#x %#x -> %#x.\\n",
+                sel, FpSrcReg1_uqw, FpSrcReg2_uqw, result);
+            FpDestReg_uqw = result;
+        '''
+
+    class Mblend(MediaOp):
+        op_class = 'SimdMiscOp'
+        code = '''
+            assert(srcSize == destSize);
+            int size = destSize;
+            int sizeBits = size * 8;
+            int items = sizeof(double) / size;
+            uint64_t result = 0;
+            uint8_t selector = ext;
+            for (int i = 0; i < items; ++i) {
+                int msb = (i + 1) * sizeBits - 1;
+                int lsb = i * sizeBits;
+                uint64_t v1 = bits(FpSrcReg1_uqw, msb, lsb);
+                uint64_t v2 = bits(FpSrcReg2_uqw, msb, lsb);
+                if (selector & (1 << i))
+                    result = insertBits(result, msb, lsb, v2);
+                else
+                    result = insertBits(result, msb, lsb, v1);
+            }
+            FpDestReg_uqw = result;
+        '''
+
+    class Mmovsdup(MediaOp):
+        def __init__(self, dest, src1, \
+                size=None, destSize=None, srcSize=None, ext=None):
+            # Make op2 = src1
+            super(Mmovsdup, self).__init__(dest, src1,\
+                    src1, size, destSize, srcSize, ext)
+        op_class = 'SimdMiscOp'
+        code = '''
+            assert(srcSize == destSize);
+            assert(destSize == 4);
+            uint64_t v = 0;
+            uint64_t result = 0;
+            bool high = ext;
+            if (high) {
+                v = bits(FpSrcReg1_uqw, 63, 32);
+            } else {
+                v = bits(FpSrcReg1_uqw, 31, 0);
+            }
+            result = insertBits(result, 31, 0, v);
+            result = insertBits(result, 64, 32, v);
+            FpDestReg_uqw = result;
+        '''
+
+    class Mpermilps(MediaOp):
+        op_class = 'SimdMiscOp'
+        code = '''
+            assert(srcSize == destSize);
+            assert(srcSize == 4);
+            uint64_t vs[4];
+            vs[0] = bits(FpSrcReg1_uqw, 31, 0);
+            vs[1] = bits(FpSrcReg1_uqw, 63, 32);
+            vs[2] = bits(FpSrcReg2_uqw, 31, 0);
+            vs[3] = bits(FpSrcReg2_uqw, 63, 32);
+            uint64_t result = 0;
+            uint8_t sel0 = (ext >> 0) & 0x3;
+            result = insertBits(result, 31, 0, vs[sel0]);
+            uint8_t sel1 = (ext >> 2) & 0x3;
+            result = insertBits(result, 63, 32, vs[sel1]);
+            FpDestReg_uqw = result;
+        '''
+
+    class Mpermilpd(MediaOp):
+        op_class = 'SimdMiscOp'
+        code = '''
+            assert(srcSize == destSize);
+            assert(srcSize == 8);
+            uint8_t sel0 = (ext >> 0) & 0x1;
+            uint64_t result = sel0 ? FpSrcReg2_uqw : FpSrcReg1_uqw;
+            FpDestReg_uqw = result;
+        '''
+
+    class Minsertpsl(MediaOp):
+        op_class = 'SimdMiscOp'
+        code = '''
+            assert(srcSize == destSize);
+            assert(srcSize == 4);
+            uint64_t vs[4];
+            vs[0] = bits(FpSrcReg1_uqw, 31, 0);
+            vs[1] = bits(FpSrcReg1_uqw, 63, 32);
+            vs[2] = bits(FpSrcReg2_uqw, 31, 0);
+            vs[3] = bits(FpSrcReg2_uqw, 63, 32);
+            uint8_t zmask = (ext >> 0) & 0xF;
+            uint8_t countD = (ext >> 4) & 0x3;
+            uint8_t countS = (ext >> 6) & 0x3;
+            uint64_t result = FpDestReg_uqw;
+            // Insert into countD.
+            if (countD == 0) {
+                result = insertBits(result, 31, 0, vs[countS]);
+            } else if (countD == 1) {
+                result = insertBits(result, 64, 32, vs[countS]);
+            }
+            // Apply zero mask.
+            if ((zmask >> 0) & 0x1)
+                result = insertBits(result, 31, 0, 0);
+            if ((zmask >> 1) & 0x1)
+                result = insertBits(result, 64, 32, 0);
+            FpDestReg_uqw = result;
+        '''
+
+    class Minsertpsh(MediaOp):
+        op_class = 'SimdMiscOp'
+        code = '''
+            assert(srcSize == destSize);
+            assert(srcSize == 4);
+            uint64_t vs[4];
+            vs[0] = bits(FpSrcReg1_uqw, 31, 0);
+            vs[1] = bits(FpSrcReg1_uqw, 63, 32);
+            vs[2] = bits(FpSrcReg2_uqw, 31, 0);
+            vs[3] = bits(FpSrcReg2_uqw, 63, 32);
+            uint8_t zmask = (ext >> 0) & 0xF;
+            uint8_t countD = (ext >> 4) & 0x3;
+            uint8_t countS = (ext >> 6) & 0x3;
+            uint64_t result = FpDestReg_uqw;
+            // Insert into countD.
+            if (countD == 2) {
+                result = insertBits(result, 31, 0, vs[countS]);
+            } else if (countD == 3) {
+                result = insertBits(result, 64, 32, vs[countS]);
+            }
+            // Apply zero mask.
+            if ((zmask >> 2) & 0x1)
+                result = insertBits(result, 31, 0, 0);
+            if ((zmask >> 3) & 0x1)
+                result = insertBits(result, 64, 32, 0);
             FpDestReg_uqw = result;
         '''
 
@@ -790,12 +924,20 @@ let {{
                     arg1.i = arg1Bits;
                     arg2.i = arg2Bits;
                     res.f = arg1.f + arg2.f;
+                    DPRINTF(X86MediaMicroop, "maddf32 %s(%f) + %s(%f) = %s(%f).\\n",
+                        srcRegIdx(0), arg1.f,
+                        srcRegIdx(1), arg2.f,
+                        destRegIdx(0), res.f);
                     resBits = res.i;
                 } else {
                     doubleInt arg1, arg2, res;
                     arg1.i = arg1Bits;
                     arg2.i = arg2Bits;
                     res.d = arg1.d + arg2.d;
+                    DPRINTF(X86MediaMicroop, "maddf64 %s(%f) + %s(%f) = %s(%f).\\n",
+                        srcRegIdx(0), arg1.d,
+                        srcRegIdx(1), arg2.d,
+                        destRegIdx(0), res.d);
                     resBits = res.i;
                 }
 
@@ -837,6 +979,9 @@ let {{
                     arg1.i = arg1Bits;
                     arg2.i = arg2Bits;
                     res.f = arg1.f - arg2.f;
+                    DPRINTF(X86MediaMicroop, "msubf32 %s - %s = %s, %f - %f = %f.\\n",
+                        srcRegIdx(0), srcRegIdx(1), destRegIdx(0),
+                        arg1.f, arg2.f, res.f);
                     resBits = res.i;
                 } else {
                     doubleInt arg1, arg2, res;
@@ -884,12 +1029,20 @@ let {{
                     arg1.i = arg1Bits;
                     arg2.i = arg2Bits;
                     res.f = arg1.f * arg2.f;
+                    DPRINTF(X86MediaMicroop, "mmulf32 %s(%f) * %s(%f) = %s(%f).\\n",
+                        srcRegIdx(0), arg1.f,
+                        srcRegIdx(1), arg2.f,
+                        destRegIdx(0), res.f);
                     resBits = res.i;
                 } else {
                     doubleInt arg1, arg2, res;
                     arg1.i = arg1Bits;
                     arg2.i = arg2Bits;
                     res.d = arg1.d * arg2.d;
+                    DPRINTF(X86MediaMicroop, "mmulf64 %s(%f) * %s(%f) = %s(%f).\\n",
+                        srcRegIdx(0), arg1.d,
+                        srcRegIdx(1), arg2.d,
+                        destRegIdx(0), res.d);
                     resBits = res.i;
                 }
 
@@ -961,6 +1114,12 @@ let {{
                 uint64_t arg2Bits = bits(FpSrcReg2_uqw, hiIndex, loIndex);
                 uint64_t resBits = arg1Bits + arg2Bits;
 
+                DPRINTF(X86MediaMicroop, "MAddi %d %s(%#x) + %s(#x) = %s(#x), rm %d, v %d.\\n",
+                    i, srcRegIdx(0), arg1Bits,
+                    srcRegIdx(1), arg2Bits,
+                    destRegIdx(0), resBits,
+                    machInst.modRM.rm, machInst.evex.v_extend);
+
                 if (ext & 0x2) {
                     if (signedOp()) {
                         int arg1Sign = bits(arg1Bits, sizeBits - 1);
@@ -1322,6 +1481,70 @@ let {{
                     (0 - (argBits & (ULL(1) << (srcSizeBits - 1))));
                 double arg = sArg;
 
+                if (destSize == 4) {
+                    floatInt fi;
+                    fi.f = arg;
+                    argBits = fi.i;
+                    DPRINTF(X86MediaMicroop, "cvti2f32 %d -> %f.\\n",
+                        arg, fi.f);
+                } else {
+                    doubleInt di;
+                    di.d = arg;
+                    argBits = di.i;
+                    DPRINTF(X86MediaMicroop, "cvti2f64 %d -> %f.\\n",
+                        arg, di.d);
+                }
+                int destHiIndex = destStart + (i + 1) * destSizeBits - 1;
+                int destLoIndex = destStart + (i + 0) * destSizeBits;
+                result = insertBits(result, destHiIndex, destLoIndex, argBits);
+            }
+            FpDestReg_uqw = result;
+        '''
+
+    class Cvtui2f(MediaOp):
+        def __init__(self, dest, src, \
+                size = None, destSize = None, srcSize = None, ext = None):
+            super(Cvtui2f, self).__init__(dest, src,\
+                    "InstRegIndex(0)", size, destSize, srcSize, ext)
+        op_class = 'SimdFloatCvtOp'
+        code = '''
+            union floatInt
+            {
+                float f;
+                uint32_t i;
+            };
+            union doubleInt
+            {
+                double d;
+                uint64_t i;
+            };
+
+            assert(destSize == 4 || destSize == 8);
+            assert(srcSize == 4 || srcSize == 8);
+            int srcSizeBits = srcSize * 8;
+            int destSizeBits = destSize * 8;
+            int items;
+            int srcStart = 0;
+            int destStart = 0;
+            if (srcSize == 2 * destSize) {
+                items = numItems(srcSize);
+                if (ext & 0x2)
+                    destStart = destSizeBits * items;
+            } else if (destSize == 2 * srcSize) {
+                items = numItems(destSize);
+                if (ext & 0x2)
+                    srcStart = srcSizeBits * items;
+            } else {
+                items = numItems(destSize);
+            }
+            uint64_t result = FpDestReg_uqw;
+
+            for (int i = 0; i < items; i++) {
+                int srcHiIndex = srcStart + (i + 1) * srcSizeBits - 1;
+                int srcLoIndex = srcStart + (i + 0) * srcSizeBits;
+                uint64_t argBits = bits(FpSrcReg1_uqw, srcHiIndex, srcLoIndex);
+                double arg = argBits;
+
                 if (destSize == 4) {
                     floatInt fi;
                     fi.f = arg;
diff --git a/src/arch/x86/isa/microops/microops.isa b/src/arch/x86/isa/microops/microops.isa
index a8ae2da4e4..05bbf37b28 100644
--- a/src/arch/x86/isa/microops/microops.isa
+++ b/src/arch/x86/isa/microops/microops.isa
@@ -51,6 +51,9 @@
 //Media microop definitions
 ##include "mediaop.isa"
 
+//AVX microop definitions
+##include "avxop.isa"
+
 //Control flow microop definitions
 ##include "seqop.isa"
 
diff --git a/src/arch/x86/isa/operands.isa b/src/arch/x86/isa/operands.isa
index 504deb73fe..0941c4933f 100644
--- a/src/arch/x86/isa/operands.isa
+++ b/src/arch/x86/isa/operands.isa
@@ -49,6 +49,8 @@ def operand_types {{
     'sqw' : 'int64_t',
     'uqw' : 'uint64_t',
     'u2qw' : 'std::array<uint64_t, 2>',
+    'u4qw' : 'std::array<uint64_t, 4>',
+    'u8qw' : 'std::array<uint64_t, 8>',
     'sf' : 'float',
     'df' : 'double',
 }};
@@ -112,12 +114,10 @@ def operands {{
         'Rbp':           intReg('(INTREG_RBP)', 17),
         'Rsi':           intReg('(INTREG_RSI)', 18),
         'Rdi':           intReg('(INTREG_RDI)', 19),
-        'R8':            intReg('(INTREG_R8)', 20),
-        'R9':            intReg('(INTREG_R9)', 21),
-        'FpSrcReg1':     floatReg('src1', 22),
-        'FpSrcReg2':     floatReg('src2', 23),
-        'FpDestReg':     floatReg('dest', 24),
-        'FpData':        floatReg('data', 25),
+        'FpSrcReg1':     floatReg('src1', 20),
+        'FpSrcReg2':     floatReg('src2', 21),
+        'FpDestReg':     floatReg('dest', 22),
+        'FpData':        floatReg('data', 23),
         'RIP':           ('PCState', 'uqw', 'pc',
                           (None, None, 'IsControl'), 50),
         'NRIP':          ('PCState', 'uqw', 'npc',
@@ -207,5 +207,40 @@ def operands {{
         'TscOp':         controlReg('MISCREG_TSC', 212),
         'M5Reg':         squashCReg('MISCREG_M5_REG', 213),
         'Mem':           ('Mem', 'uqw', None, \
-                          (None, 'IsLoad', 'IsStore'), 300)
+                          (None, 'IsLoad', 'IsStore'), 300),
+
+        # Operands to access AVX512 registers.
+        # TODO: Move the true vector register implementation.
+        'FpData0':        floatReg('data + 0', 310),
+        'FpData1':        floatReg('data + 1', 311),
+        'FpData2':        floatReg('data + 2', 312),
+        'FpData3':        floatReg('data + 3', 313),
+        'FpData4':        floatReg('data + 4', 314),
+        'FpData5':        floatReg('data + 5', 315),
+        'FpData6':        floatReg('data + 6', 316),
+        'FpData7':        floatReg('data + 7', 317),
+        'FpSrcReg1x0':    floatReg('src1 + 0', 320),
+        'FpSrcReg1x1':    floatReg('src1 + 1', 321),
+        'FpSrcReg1x2':    floatReg('src1 + 2', 322),
+        'FpSrcReg1x3':    floatReg('src1 + 3', 323),
+        'FpSrcReg1x4':    floatReg('src1 + 4', 324),
+        'FpSrcReg1x5':    floatReg('src1 + 5', 325),
+        'FpSrcReg1x6':    floatReg('src1 + 6', 326),
+        'FpSrcReg1x7':    floatReg('src1 + 7', 327),
+        'FpSrcReg2x0':    floatReg('src2 + 0', 330),
+        'FpSrcReg2x1':    floatReg('src2 + 1', 331),
+        'FpSrcReg2x2':    floatReg('src2 + 2', 332),
+        'FpSrcReg2x3':    floatReg('src2 + 3', 333),
+        'FpSrcReg2x4':    floatReg('src2 + 4', 334),
+        'FpSrcReg2x5':    floatReg('src2 + 5', 335),
+        'FpSrcReg2x6':    floatReg('src2 + 6', 336),
+        'FpSrcReg2x7':    floatReg('src2 + 7', 337),
+        'FpDestReg0':     floatReg('dest + 0', 340),
+        'FpDestReg1':     floatReg('dest + 1', 341),
+        'FpDestReg2':     floatReg('dest + 2', 342),
+        'FpDestReg3':     floatReg('dest + 3', 343),
+        'FpDestReg4':     floatReg('dest + 4', 344),
+        'FpDestReg5':     floatReg('dest + 5', 345),
+        'FpDestReg6':     floatReg('dest + 6', 346),
+        'FpDestReg7':     floatReg('dest + 7', 347),
 }};
diff --git a/src/arch/x86/isa/specialize.isa b/src/arch/x86/isa/specialize.isa
index 946732f260..0bdf5ab1e6 100644
--- a/src/arch/x86/isa/specialize.isa
+++ b/src/arch/x86/isa/specialize.isa
@@ -104,7 +104,8 @@ let {{
 
 let {{
     class OpType(object):
-        parser = re.compile(r"(?P<tag>[A-Z]+)(?P<size>[a-z]*)|(r(?P<reg>[A-Z0-9]+)(?P<rsize>[a-z]*))")
+        parser = re.compile(
+            r"(?P<tag>[A-Z]+)(?P<size>[a-z]*)|(r(?P<reg>[A-Z0-9]+)(?P<rsize>[a-z]*))")
         def __init__(self, opTypeString):
             match = OpType.parser.search(opTypeString)
             if match == None:
@@ -116,8 +117,10 @@ let {{
             if not self.size:
                 self.size = match.group("rsize")
 
-    ModRMRegIndex = "(MODRM_REG | (REX_R << 3))"
-    ModRMRMIndex = "(MODRM_RM | (REX_B << 3))"
+    # EVEX will extend ModRMReg with EVEX_R'.
+    ModRMRegIndex = "(MODRM_REG | (REX_R << 3) | ((EVEX_PRESENT ? EVEX_R_PRIME : 0) << 4))"
+    # EVEX will extend ModRMRM with REX_X.
+    ModRMRMIndex = "(MODRM_RM | (REX_B << 3) | ((EVEX_PRESENT ? REX_X : 0) << 4))"
     InstRegIndex = "(OPCODE_OP_BOTTOM3 | (REX_B << 3))"
 
     # This function specializes the given piece of code to use a particular
@@ -129,7 +132,7 @@ let {{
             opType = OpType(opTypes[0])
             opTypes.pop(0)
 
-            if opType.tag not in ("I", "J", "P", "PR", "Q", "V", "VR", "W"):
+            if opType.tag not in ("I", "J", "P", "PR", "Q", "V", "VR", "W", "WY", "WZ"):
                 if opType.size:
                     env.setSize(opType.size)
 
@@ -184,7 +187,7 @@ let {{
                 env.addToDisassembly(
                         "printSegment(out, %s);\n" % ModRMRegIndex)
                 Name += "_S"
-            elif opType.tag in ("G", "P", "T", "V"):
+            elif opType.tag in ("G", "P", "T", "V", "VY", "VZ"):
                 # Use the "reg" field of the ModRM byte to select the register
                 env.addReg(ModRMRegIndex)
                 env.addToDisassembly(
@@ -192,13 +195,16 @@ let {{
                                                                  ModRMRegIndex)
 
                 if opType.tag == "P":
-
                     Name += "_MMX"
                 elif opType.tag == "V":
                     Name += "_XMM"
+                elif opType.tag == "VY":
+                    Name += "_YMM"
+                elif opType.tag == "VZ":
+                    Name += "_ZMM"
                 else:
                     Name += "_R"
-            elif opType.tag in ("E", "Q", "W"):
+            elif opType.tag in ("E", "Q", "W", "WY", "WZ"):
                 # This might refer to memory or to a register. We need to
                 # divide it up farther.
                 regEnv = copy.copy(env)
@@ -217,11 +223,19 @@ let {{
                     regSuffix = "_MMX"
                 elif opType.tag == "W":
                     regSuffix = "_XMM"
-                return doSplitDecode("MODRM_MOD",
-                    {"3" : (specializeInst, Name + regSuffix,
-                            copy.copy(opTypes), regEnv)},
-                           (doRipRelativeDecode, Name,
-                            copy.copy(opTypes), memEnv))
+                elif opType.tag == "WY":
+                    regSuffix = "_YMM"
+                elif opType.tag == "WZ":
+                    regSuffix = "_ZMM"
+                return doSplitDecode(
+                    switchVal="MODRM_MOD",
+                    vals={
+                        "3": (
+                            specializeInst, Name + regSuffix, copy.copy(opTypes), regEnv
+                        )
+                    },
+                    default=(doRipRelativeDecode, Name, copy.copy(opTypes), memEnv)
+                )
             elif opType.tag in ("I", "J"):
                 # Immediates
                 env.addToDisassembly(
diff --git a/src/arch/x86/memhelpers.hh b/src/arch/x86/memhelpers.hh
index 35dfac6b05..e5eb87b574 100644
--- a/src/arch/x86/memhelpers.hh
+++ b/src/arch/x86/memhelpers.hh
@@ -95,7 +95,8 @@ getMem(PacketPtr pkt, std::array<uint64_t, N> &mem, unsigned dataSize,
         getPackedMem<uint64_t, N>(pkt, mem, dataSize);
         break;
       default:
-        panic("Unhandled element size in getMem.\n");
+        panic_if(dataSize != sizeof(mem), "Unhandled element size in getMem.\n");
+        getPackedMem<uint64_t, N>(pkt, mem, dataSize);
     }
     if (traceData)
         traceData->setData(mem[0]);
@@ -156,7 +157,8 @@ readMemAtomic(ExecContext *xc, Trace::InstRecord *traceData, Addr addr,
         fault = readPackedMemAtomic<uint64_t, N>(xc, addr, mem, flags);
         break;
       default:
-        panic("Unhandled element size in readMemAtomic\n");
+        panic_if(dataSize != sizeof(mem), "Unhandled element size in readMemAtomic.\n");
+        fault = readPackedMemAtomic<uint64_t, N>(xc, addr, mem, flags);
     }
     if (fault == NoFault && traceData)
         traceData->setData(mem[0]);
@@ -207,7 +209,8 @@ writeMemTiming(ExecContext *xc, Trace::InstRecord *traceData,
       case 8:
         return writePackedMem<uint64_t, N>(xc, mem, addr, flags, res);
       default:
-        panic("Unhandled element size in writeMemTiming.\n");
+        panic_if(dataSize != sizeof(mem), "Unhandled element size in writeMemTiming.\n");
+        return writePackedMem<uint64_t, N>(xc, mem, addr, flags, res);
     }
 }
 
@@ -245,7 +248,8 @@ writeMemAtomic(ExecContext *xc, Trace::InstRecord *traceData,
         fault = writePackedMem<uint64_t, N>(xc, mem, addr, flags, res);
         break;
       default:
-        panic("Unhandled element size in writeMemAtomic.\n");
+        panic_if(dataSize != sizeof(mem), "Unhandled element size in writeMemAtomic.\n");
+        fault = writePackedMem<uint64_t, N>(xc, mem, addr, flags, res);
     }
 
     if (fault == NoFault && res)
diff --git a/src/arch/x86/registers.hh b/src/arch/x86/registers.hh
index c041a07f97..53bf964ec6 100644
--- a/src/arch/x86/registers.hh
+++ b/src/arch/x86/registers.hh
@@ -61,7 +61,7 @@ const int NumCCRegs = NUM_CCREGS;
 // Each 128 bit xmm register is broken into two effective 64 bit registers.
 // Add 8 for the indices that are mapped over the fp stack
 const int NumFloatRegs =
-    NumMMXRegs + 2 * NumXMMRegs + NumMicroFpRegs + 8;
+    NumMMXRegs + NumXMMSubRegs * NumXMMRegs + NumMicroFpRegs + 8;
 
 // These enumerate all the registers for dependence tracking.
 enum DependenceTags {
diff --git a/src/arch/x86/regs/float.hh b/src/arch/x86/regs/float.hh
index 6cba603fb1..0246d9943f 100644
--- a/src/arch/x86/regs/float.hh
+++ b/src/arch/x86/regs/float.hh
@@ -67,40 +67,51 @@ namespace X86ISA
         FLOATREG_FPR7,
 
         FLOATREG_XMM_BASE = FLOATREG_MMX_BASE + NumMMXRegs,
-        FLOATREG_XMM0_LOW = FLOATREG_XMM_BASE,
-        FLOATREG_XMM0_HIGH,
-        FLOATREG_XMM1_LOW,
-        FLOATREG_XMM1_HIGH,
-        FLOATREG_XMM2_LOW,
-        FLOATREG_XMM2_HIGH,
-        FLOATREG_XMM3_LOW,
-        FLOATREG_XMM3_HIGH,
-        FLOATREG_XMM4_LOW,
-        FLOATREG_XMM4_HIGH,
-        FLOATREG_XMM5_LOW,
-        FLOATREG_XMM5_HIGH,
-        FLOATREG_XMM6_LOW,
-        FLOATREG_XMM6_HIGH,
-        FLOATREG_XMM7_LOW,
-        FLOATREG_XMM7_HIGH,
-        FLOATREG_XMM8_LOW,
-        FLOATREG_XMM8_HIGH,
-        FLOATREG_XMM9_LOW,
-        FLOATREG_XMM9_HIGH,
-        FLOATREG_XMM10_LOW,
-        FLOATREG_XMM10_HIGH,
-        FLOATREG_XMM11_LOW,
-        FLOATREG_XMM11_HIGH,
-        FLOATREG_XMM12_LOW,
-        FLOATREG_XMM12_HIGH,
-        FLOATREG_XMM13_LOW,
-        FLOATREG_XMM13_HIGH,
-        FLOATREG_XMM14_LOW,
-        FLOATREG_XMM14_HIGH,
-        FLOATREG_XMM15_LOW,
-        FLOATREG_XMM15_HIGH,
+        // ! Keep consistent with NumXMMSubRegs
+#define FLOATREG_XMM_IDX(i) \
+        FLOATREG_XMM ## i ## _0 = FLOATREG_XMM_BASE + i * NumXMMSubRegs + 0, \
+        FLOATREG_XMM ## i ## _1 = FLOATREG_XMM_BASE + i * NumXMMSubRegs + 1, \
+        FLOATREG_XMM ## i ## _2 = FLOATREG_XMM_BASE + i * NumXMMSubRegs + 2, \
+        FLOATREG_XMM ## i ## _3 = FLOATREG_XMM_BASE + i * NumXMMSubRegs + 3, \
+        FLOATREG_XMM ## i ## _4 = FLOATREG_XMM_BASE + i * NumXMMSubRegs + 4, \
+        FLOATREG_XMM ## i ## _5 = FLOATREG_XMM_BASE + i * NumXMMSubRegs + 5, \
+        FLOATREG_XMM ## i ## _6 = FLOATREG_XMM_BASE + i * NumXMMSubRegs + 6, \
+        FLOATREG_XMM ## i ## _7 = FLOATREG_XMM_BASE + i * NumXMMSubRegs + 7
+        FLOATREG_XMM_IDX(0),
+        FLOATREG_XMM_IDX(1),
+        FLOATREG_XMM_IDX(2),
+        FLOATREG_XMM_IDX(3),
+        FLOATREG_XMM_IDX(4),
+        FLOATREG_XMM_IDX(5),
+        FLOATREG_XMM_IDX(6),
+        FLOATREG_XMM_IDX(7),
+        FLOATREG_XMM_IDX(8),
+        FLOATREG_XMM_IDX(9),
+        FLOATREG_XMM_IDX(10),
+        FLOATREG_XMM_IDX(11),
+        FLOATREG_XMM_IDX(12),
+        FLOATREG_XMM_IDX(13),
+        FLOATREG_XMM_IDX(14),
+        FLOATREG_XMM_IDX(15),
+        FLOATREG_XMM_IDX(16),
+        FLOATREG_XMM_IDX(17),
+        FLOATREG_XMM_IDX(18),
+        FLOATREG_XMM_IDX(19),
+        FLOATREG_XMM_IDX(20),
+        FLOATREG_XMM_IDX(21),
+        FLOATREG_XMM_IDX(22),
+        FLOATREG_XMM_IDX(23),
+        FLOATREG_XMM_IDX(24),
+        FLOATREG_XMM_IDX(25),
+        FLOATREG_XMM_IDX(26),
+        FLOATREG_XMM_IDX(27),
+        FLOATREG_XMM_IDX(28),
+        FLOATREG_XMM_IDX(29),
+        FLOATREG_XMM_IDX(30),
+        FLOATREG_XMM_IDX(31),
+#undef FLOATREG_XMM_IDX
 
-        FLOATREG_MICROFP_BASE = FLOATREG_XMM_BASE + 2 * NumXMMRegs,
+        FLOATREG_MICROFP_BASE = FLOATREG_XMM_BASE + NumXMMSubRegs * NumXMMRegs,
         FLOATREG_MICROFP0 = FLOATREG_MICROFP_BASE,
         FLOATREG_MICROFP1,
         FLOATREG_MICROFP2,
@@ -109,6 +120,14 @@ namespace X86ISA
         FLOATREG_MICROFP5,
         FLOATREG_MICROFP6,
         FLOATREG_MICROFP7,
+        FLOATREG_MICROFP8,
+        FLOATREG_MICROFP9,
+        FLOATREG_MICROFP10,
+        FLOATREG_MICROFP11,
+        FLOATREG_MICROFP12,
+        FLOATREG_MICROFP13,
+        FLOATREG_MICROFP14,
+        FLOATREG_MICROFP15,
 
         NUM_FLOATREGS = FLOATREG_MICROFP_BASE + NumMicroFpRegs
     };
@@ -128,13 +147,19 @@ namespace X86ISA
     static inline FloatRegIndex
     FLOATREG_XMM_LOW(int index)
     {
-        return (FloatRegIndex)(FLOATREG_XMM_BASE + 2 * index);
+        return (FloatRegIndex)(FLOATREG_XMM_BASE + NumXMMSubRegs * index);
     }
 
     static inline FloatRegIndex
     FLOATREG_XMM_HIGH(int index)
     {
-        return (FloatRegIndex)(FLOATREG_XMM_BASE + 2 * index + 1);
+        return (FloatRegIndex)(FLOATREG_XMM_BASE + NumXMMSubRegs * index + 1);
+    }
+
+    static inline FloatRegIndex
+    FLOATREG_XMM_IDX(int index, int sub_idx)
+    {
+        return (FloatRegIndex)(FLOATREG_XMM_BASE + NumXMMSubRegs * index + sub_idx);
     }
 
     static inline FloatRegIndex
diff --git a/src/arch/x86/types.cc b/src/arch/x86/types.cc
index 8588467481..9c1587a3f9 100644
--- a/src/arch/x86/types.cc
+++ b/src/arch/x86/types.cc
@@ -40,7 +40,7 @@ paramOut(CheckpointOut &cp, const string &name, ExtMachInst const &machInst)
     // Prefixes
     paramOut(cp, name + ".legacy", (uint8_t)machInst.legacy);
     paramOut(cp, name + ".rex", (uint8_t)machInst.rex);
-    paramOut(cp, name + ".vex", (uint32_t)machInst.vex);
+    paramOut(cp, name + ".evex", (uint32_t)machInst.evex);
 
     // Opcode
     paramOut(cp, name + ".opcode.type", (uint8_t)machInst.opcode.type);
@@ -76,8 +76,8 @@ paramIn(CheckpointIn &cp, const string &name, ExtMachInst &machInst)
     machInst.rex = temp8;
 
     uint32_t temp32;
-    paramIn(cp, name + ".vex", temp32);
-    machInst.vex = temp32;
+    paramIn(cp, name + ".evex", temp32);
+    machInst.evex = temp32;
 
     // Opcode
     paramIn(cp, name + ".opcode.type", temp8);
diff --git a/src/arch/x86/types.hh b/src/arch/x86/types.hh
index 890a9e5cf4..e5864ed863 100644
--- a/src/arch/x86/types.hh
+++ b/src/arch/x86/types.hh
@@ -67,6 +67,7 @@ namespace X86ISA
         Repne,
         Vex2Prefix,
         Vex3Prefix,
+        EVexPrefix,
         XopPrefix,
     };
 
@@ -135,14 +136,71 @@ namespace X86ISA
         Bitfield<1, 0> p;
     EndBitUnion(Vex2Of2)
 
-    BitUnion8(VexInfo)
-        // Extra register index.
-        Bitfield<6, 3> v;
-        // Vector length specifier.
-        Bitfield<2> l;
-        // Whether the VEX prefix was used.
-        Bitfield<0> present;
-    EndBitUnion(VexInfo)
+    BitUnion8(EVex2Of4)
+        // Inverted bit from the REX prefix.
+        Bitfield<7> r;
+        Bitfield<6> x;
+        Bitfield<5> b;
+        // Inverted bit of R'.
+        Bitfield<4> r_prime;
+        // Zero bit.
+        Bitfield<3, 2> zero;
+        // Selector for what would be two or three byte opcode types.
+        Bitfield<1, 0> m;
+    EndBitUnion(EVex2Of4)
+
+    BitUnion8(EVex3Of4)
+        // Bit from the REX prefix.
+        Bitfield<7> w;
+        // Inverted extra register index.
+        Bitfield<6, 3>  v;
+        // Always 1 in EVEX.
+        Bitfield<2> one;
+        // Implied 66, F2, or F3 opcode prefix.
+        Bitfield<1, 0> p;
+    EndBitUnion(EVex3Of4)
+
+    BitUnion8(EVex4Of4)
+        // Bit z for merging mode.
+        Bitfield<7> z;
+        // Bit L' specifying 512bit vector length, or rounding control
+        // mode when combined with L.
+        Bitfield<6> l_prime;
+        // Bit L specifying 256bit vector length.
+        Bitfield<5> l;
+        // Bit b specifying broadcasting.
+        Bitfield<4> b;
+        // Inverted bit V'.
+        Bitfield<3> v_prime;
+        // Operand mask register.
+        Bitfield<2, 0> a;
+    EndBitUnion(EVex4Of4)
+
+    // Aggregated EVex prefix info.
+    BitUnion16(EVexInfo)
+        // Bit z.
+        Bitfield<15>      z;
+        // Operand mask register a.
+        Bitfield<14, 12>  a;
+        // Extend L'L
+        Bitfield<11, 10>  l_extend;
+        Bitfield<11>      l_prime;
+        Bitfield<10>      l;
+        // Bit b.
+        Bitfield<9>      b;
+        // Extend V'vvvv
+        Bitfield<8, 4>   v_extend;
+        Bitfield<8>      v_prime;
+        Bitfield<7, 4>   v;
+        // Extend R'R
+        Bitfield<3, 2>   r_extend;
+        Bitfield<3>      r_prime;
+        Bitfield<2>      r;
+        // 01 VEX 10 EVEX.
+        Bitfield<1, 0>   present;
+        Bitfield<1>      evex_present;
+        Bitfield<0>      vex_present;
+    EndBitUnion(EVexInfo)
 
     enum OpcodeType {
         BadOpcode,
@@ -204,7 +262,7 @@ namespace X86ISA
         //Prefixes
         LegacyPrefixVector legacy;
         Rex rex;
-        VexInfo vex;
+        EVexInfo evex;
 
         //This holds all of the bytes of the opcode
         struct
@@ -237,13 +295,13 @@ namespace X86ISA
         operator << (std::ostream & os, const ExtMachInst & emi)
     {
         ccprintf(os, "\n{\n\tleg = %#x,\n\trex = %#x,\n\t"
-                     "vex/xop = %#x,\n\t"
+                     "evex = %#x,\n\t"
                      "op = {\n\t\ttype = %s,\n\t\top = %#x,\n\t\t},\n\t"
                      "modRM = %#x,\n\tsib = %#x,\n\t"
                      "immediate = %#x,\n\tdisplacement = %#x\n\t"
                      "dispSize = %d}\n",
                      (uint8_t)emi.legacy, (uint8_t)emi.rex,
-                     (uint8_t)emi.vex,
+                     (uint16_t)emi.evex,
                      opcodeTypeToStr(emi.opcode.type), (uint8_t)emi.opcode.op,
                      (uint8_t)emi.modRM, (uint8_t)emi.sib,
                      emi.immediate, emi.displacement, emi.dispSize);
@@ -257,7 +315,7 @@ namespace X86ISA
             return false;
         if (emi1.rex != emi2.rex)
             return false;
-        if (emi1.vex != emi2.vex)
+        if (emi1.evex != emi2.evex)
             return false;
         if (emi1.opcode.type != emi2.opcode.type)
             return false;
@@ -354,9 +412,9 @@ namespace std {
     template<>
     struct hash<X86ISA::ExtMachInst> {
         size_t operator()(const X86ISA::ExtMachInst &emi) const {
-            return (((uint64_t)emi.legacy << 48) |
-                    ((uint64_t)emi.rex << 40) |
-                    ((uint64_t)emi.vex << 32) |
+            return (((uint64_t)emi.legacy << 56) |
+                    ((uint64_t)emi.rex << 48) |
+                    ((uint64_t)emi.evex << 32) |
                     ((uint64_t)emi.modRM << 24) |
                     ((uint64_t)emi.sib << 16) |
                     ((uint64_t)emi.opcode.type << 8) |
diff --git a/src/arch/x86/utility.hh b/src/arch/x86/utility.hh
index 39a142c2ab..b311eefcdc 100644
--- a/src/arch/x86/utility.hh
+++ b/src/arch/x86/utility.hh
@@ -113,6 +113,13 @@ namespace X86ISA
      */
     void setRFlags(ThreadContext *tc, uint64_t val);
 
+    /**
+     * Extract the bit string representing a double value.
+     */
+    inline uint64_t getDoubleBits(double val) {
+        return *(uint64_t *)(&val);
+    }
+
     /**
      * Convert an x87 tag word to abridged tag format.
      *
diff --git a/src/arch/x86/x86_traits.hh b/src/arch/x86/x86_traits.hh
index 6f1c9ae366..50390b9c3d 100644
--- a/src/arch/x86/x86_traits.hh
+++ b/src/arch/x86/x86_traits.hh
@@ -55,8 +55,13 @@ namespace X86ISA
     //6. The register to use for shift doubles
 
     const int NumMMXRegs = 8;
-    const int NumXMMRegs = 16;
-    const int NumMicroFpRegs = 8;
+    const int NumXMMRegs = 32;
+    /**
+     * Float registers are broken into 64-bit sub-registers.
+     * 512bit / 64bit = 8.
+     */
+    const int NumXMMSubRegs = 8;
+    const int NumMicroFpRegs = 16;
 
     const int NumCRegs = 16;
     const int NumDRegs = 8;
diff --git a/src/cpu/o3/O3CPU.py b/src/cpu/o3/O3CPU.py
index 1118775547..9e97e879d0 100644
--- a/src/cpu/o3/O3CPU.py
+++ b/src/cpu/o3/O3CPU.py
@@ -136,8 +136,8 @@ class DerivO3CPU(BaseCPU):
 
     numRobs = Param.Unsigned(1, "Number of Reorder Buffers");
 
-    numPhysIntRegs = Param.Unsigned(256, "Number of physical integer registers")
-    numPhysFloatRegs = Param.Unsigned(256, "Number of physical floating point "
+    numPhysIntRegs = Param.Unsigned(1024, "Number of physical integer registers")
+    numPhysFloatRegs = Param.Unsigned(1024, "Number of physical floating point "
                                       "registers")
     # most ISAs don't use condition-code regs, so default is 0
     _defaultNumPhysCCRegs = 0
diff --git a/src/sim/process.cc b/src/sim/process.cc
index 315f86b7e2..d3b79ab620 100644
--- a/src/sim/process.cc
+++ b/src/sim/process.cc
@@ -319,6 +319,21 @@ Process::drain()
 void
 Process::allocateMem(Addr vaddr, int64_t size, bool clobber)
 {
+    // Check if the page has been mapped by other cores if not to clobber.
+    // When running multithreaded programs in SE-mode with DerivO3CPU model,
+    // there are cases where two or more cores have page faults on the same
+    // page in nearby ticks. When the cores try to handle the faults at the
+    // commit stage (also in nearby ticks/cycles), the first core will ask for
+    // a physical page frame to map with the virtual page. Other cores can
+    // return if the page has been mapped and `!clobber`.
+    if (!clobber) {
+        const EmulationPageTable::Entry *pte = pTable->lookup(vaddr);
+        if (pte) {
+            warn("Process::allocateMem: addr %#x already mapped\n", vaddr);
+            return;
+        }
+    }
+
     int npages = divCeil(size, pTable->pageSize());
     Addr paddr = system->allocPhysPages(npages);
     pTable->map(vaddr, paddr, size,
